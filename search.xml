<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python操作Excel</title>
    <url>/2020/02/14/python%E6%93%8D%E4%BD%9CExcel/</url>
    <content><![CDATA[<h1 id="python操作Excel"><a href="#python操作Excel" class="headerlink" title="python操作Excel"></a>python操作Excel</h1><p><strong>python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。</strong> </p>
<h2 id="一、xlrd"><a href="#一、xlrd" class="headerlink" title="一、xlrd"></a>一、xlrd</h2><h3 id="1-安装xlrd模块"><a href="#1-安装xlrd模块" class="headerlink" title="1. 安装xlrd模块"></a>1. 安装xlrd模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xlrd</span><br></pre></td></tr></table></figure>

<h3 id="2-使用介绍"><a href="#2-使用介绍" class="headerlink" title="2. 使用介绍"></a>2. 使用介绍</h3><h4 id="1-常用单元格中的数据类型"><a href="#1-常用单元格中的数据类型" class="headerlink" title="1. 常用单元格中的数据类型"></a>1. 常用单元格中的数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  empty（空的）</span><br><span class="line">1  string（text）</span><br><span class="line">2  number</span><br><span class="line">3  date</span><br><span class="line">4  boolean</span><br><span class="line">5  error </span><br><span class="line">6  blank（空白表格）</span><br></pre></td></tr></table></figure>

<h4 id="2-导入模块"><a href="#2-导入模块" class="headerlink" title="2. 导入模块"></a>2. 导入模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xlrd</span><br></pre></td></tr></table></figure>

<h4 id="3-打开Excel文件读取数据"><a href="#3-打开Excel文件读取数据" class="headerlink" title="3. 打开Excel文件读取数据"></a>3. 打开Excel文件读取数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = xlrd.open_workbook(excel_path)</span><br><span class="line"><span class="comment"># 文件名以及路径，如果路径或者文件名有中文给前面加一个r转成原生字符。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-常用的函数"><a href="#4-常用的函数" class="headerlink" title="4. 常用的函数"></a>4. 常用的函数</h4><p>excel中最重要的方法就是book和sheet的操作</p>
<p><strong>1）获取book中一个工作表</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = data.sheets()[<span class="number">0</span>]          <span class="comment"># 通过索引顺序获取</span></span><br><span class="line"></span><br><span class="line">table = data.sheet_by_index(sheet_indx) <span class="comment"># 通过索引顺序获取</span></span><br><span class="line"></span><br><span class="line">table = data.sheet_by_name(sheet_name)	<span class="comment"># 通过名称获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上三个函数都会返回一个xlrd.sheet.Sheet()对象</span></span><br><span class="line"></span><br><span class="line">names = data.sheet_names()    <span class="comment"># 返回book中所有工作表的名字</span></span><br><span class="line"></span><br><span class="line">data.sheet_loaded(sheet_name <span class="keyword">or</span> indx)   <span class="comment"># 检查某个sheet是否导入完毕</span></span><br></pre></td></tr></table></figure>

<p> <strong>2）行的操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nrows = table.nrows  <span class="comment"># 获取该sheet中的有效行数</span></span><br><span class="line"></span><br><span class="line">table.row(rowx)  <span class="comment"># 返回由该行中所有的单元格对象组成的列表</span></span><br><span class="line"></span><br><span class="line">table.row_slice(rowx)  <span class="comment"># 返回由该行中所有的单元格对象组成的列表</span></span><br><span class="line"></span><br><span class="line">table.row_types(rowx, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)    </span><br><span class="line"><span class="comment"># 返回由该行中所有单元格的数据类型组成的列表</span></span><br><span class="line"></span><br><span class="line">table.row_values(rowx, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)   </span><br><span class="line"><span class="comment"># 返回由该行中所有单元格的数据组成的列表</span></span><br><span class="line"></span><br><span class="line">table.row_len(rowx) <span class="comment"># 返回该列的有效单元格长度</span></span><br></pre></td></tr></table></figure>

<p><strong>3）列的操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ncols = table.ncols   <span class="comment"># 获取列表的有效列数</span></span><br><span class="line"></span><br><span class="line">table.col(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)  <span class="comment"># 返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line"></span><br><span class="line">table.col_slice(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)  <span class="comment"># 返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line"></span><br><span class="line">table.col_types(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)    </span><br><span class="line"><span class="comment"># 返回由该列中所有单元格的数据类型组成的列表</span></span><br><span class="line"></span><br><span class="line">table.col_values(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)   </span><br><span class="line"><span class="comment"># 返回由该列中所有单元格的数据组成的列表</span></span><br></pre></td></tr></table></figure>

<p><strong>4）单元格的操作</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table.cell(rowx,colx)   <span class="comment"># 返回单元格对象 .value可以获取值</span></span><br><span class="line"></span><br><span class="line">table.cell_type(rowx,colx)    <span class="comment"># 返回单元格中的数据类型</span></span><br><span class="line"></span><br><span class="line">table.cell_value(rowx,colx)   <span class="comment"># 返回单元格中的数据</span></span><br><span class="line"></span><br><span class="line">table.cell_xf_index(rowx, colx)   <span class="comment"># 暂时还没有搞懂</span></span><br></pre></td></tr></table></figure>

<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelReade</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, excel_name, sheet_name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        # 我把excel放在工程包的data文件夹中：</span></span><br><span class="line"><span class="string">        # 1.需要先获取到工程文件的地址</span></span><br><span class="line"><span class="string">        # 2.再找到excel的文件地址（比写死的绝对路径灵活）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            os.path.relpath(__file__)</span></span><br><span class="line"><span class="string">            1.根据系统获取绝对路径</span></span><br><span class="line"><span class="string">            2.会根据电脑系统自动匹配路径：mac路径用/,windows路径用\</span></span><br><span class="line"><span class="string">            3.直接使用__file__方法是不会自动适配环境的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 获取当前.py文件所在文件夹层</span></span><br><span class="line">        dir_path = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">        <span class="comment"># 获取excel所在文件目录</span></span><br><span class="line">        self.excel_path = os.path.join(dir_path, <span class="string">"data"</span>, excel_name)</span><br><span class="line">        print(self.excel_path)</span><br><span class="line">        <span class="comment"># 打开指定的excel文件</span></span><br><span class="line">        self.date = xlrd.open_workbook(self.excel_path)</span><br><span class="line">        <span class="comment"># 找到指定的sheet页</span></span><br><span class="line">        self.table = self.date.sheet_by_name(sheet_name)</span><br><span class="line">        self.rows = self.table.nrows  <span class="comment"># 获取总行数</span></span><br><span class="line">        self.cols = self.table.ncols  <span class="comment"># 获取总列数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.rows &lt;= <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">"总行数小于等于1，路径："</span>,self.excel_path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将列表的第一行设置为字典的key值</span></span><br><span class="line">            keys = self.table.row_values(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 定义一个数组</span></span><br><span class="line">            data = []</span><br><span class="line">            <span class="comment"># 从第二行开始读取数据，循环rows（总行数）-1次</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.rows):</span><br><span class="line">                <span class="comment"># 循环内定义一个字典，每次循环都会清空</span></span><br><span class="line">                dict = &#123;&#125;</span><br><span class="line">                <span class="comment"># 从第一列开始读取数据，循环cols（总列数）次</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, self.cols):</span><br><span class="line">                    <span class="comment"># 将value值关联同一列的key值</span></span><br><span class="line">                    dict[keys[j]] = self.table.row_values(i)[j]</span><br><span class="line">                <span class="comment"># 将关联后的字典放到数组里</span></span><br><span class="line">                data.append(dict)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = ExcelReade(<span class="string">'01.xlsx'</span>,<span class="string">'Sheet1'</span>)</span><br><span class="line">    data = start.data_dict()</span><br><span class="line">    print(data)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">            print(data[i])</span><br></pre></td></tr></table></figure>

<h2 id="二、xlwt"><a href="#二、xlwt" class="headerlink" title="二、xlwt"></a>二、xlwt</h2><h3 id="1-安装xlwt模块"><a href="#1-安装xlwt模块" class="headerlink" title="1. 安装xlwt模块"></a>1. 安装xlwt模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xlwt</span><br></pre></td></tr></table></figure>

<h3 id="2-使用介绍-1"><a href="#2-使用介绍-1" class="headerlink" title="2. 使用介绍"></a>2. 使用介绍</h3><h4 id="1-导入xlwt"><a href="#1-导入xlwt" class="headerlink" title="1. 导入xlwt"></a>1. 导入xlwt</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br></pre></td></tr></table></figure>

<h4 id="2-创建一个工作簿"><a href="#2-创建一个工作簿" class="headerlink" title="2.  创建一个工作簿"></a>2.  创建一个工作簿</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">excel = xlwt.Workbook()</span><br><span class="line"><span class="comment"># 参数encoding设置编码格式</span></span><br></pre></td></tr></table></figure>

<h4 id="3-创建一个工作表"><a href="#3-创建一个工作表" class="headerlink" title="3. 创建一个工作表"></a>3. 创建一个工作表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet = self.excel.add_sheet(<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-写入excel"><a href="#4-写入excel" class="headerlink" title="4. 写入excel"></a>4. 写入excel</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet.write(row,col,value)	<span class="comment"># 不带样式的写入</span></span><br><span class="line">sheet.write(row,col,value,style) <span class="comment"># 带样式的写入</span></span><br><span class="line"><span class="comment"># 参数对应行、列、值</span></span><br></pre></td></tr></table></figure>

<h4 id="5-保存"><a href="#5-保存" class="headerlink" title="5. 保存"></a>5. 保存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">excel.save(excel_path)</span><br><span class="line"><span class="comment"># 参数为写入文件的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="6-设置Excel样式"><a href="#6-设置Excel样式" class="headerlink" title="6. 设置Excel样式"></a>6. 设置Excel样式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化样式</span></span><br><span class="line">style = xlwt.XFStyle()</span><br></pre></td></tr></table></figure>

<p><strong>1）为样式创建字体</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">font = xlwt.Font() </span><br><span class="line">font.name = <span class="string">'Times New Roman'</span>	<span class="comment"># 字体的名称</span></span><br><span class="line">font.bold = <span class="literal">True</span>	<span class="comment"># 字体是否加粗</span></span><br><span class="line">font.underline = <span class="literal">True</span>	<span class="comment"># 字体是否加下划线</span></span><br><span class="line">font.italic = <span class="literal">True</span>	<span class="comment"># 字体是否斜体字</span></span><br><span class="line">style.font = font	<span class="comment"># 设定样式</span></span><br></pre></td></tr></table></figure>

<p><strong>2）设置单元格宽度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">worksheet.col(<span class="number">0</span>).width = <span class="number">3333</span></span><br></pre></td></tr></table></figure>

<p><strong>3）输入一个日期到单元格</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">style = xlwt.XFStyle()</span><br><span class="line">style.num_format_str = <span class="string">'M/D/YY'</span> </span><br><span class="line"><span class="comment"># 其他的方式:D-MMM-YY, D-MMM, MMM-YY, h:mm, h:mm:ss, h:mm, h:mm:ss, M/D/YY h:mm, mm:ss, [h]:mm:ss, mm:ss.0</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">0</span>, datetime.datetime.now(), style)</span><br></pre></td></tr></table></figure>

<p><strong>4）向单元格添加一个公式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet.write(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment"># 第一行第一列写入5 单元格位置A1	(字母代表列，数字代表行)</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 第一行第二列写入2 单元格位置B1</span></span><br><span class="line">sheet.write(<span class="number">1</span>, <span class="number">0</span>, xlwt.Formula(<span class="string">'A1*B1'</span>)) </span><br><span class="line"><span class="comment"># 在第二行第一列写入 A1*B1的结果 "10" (A1[5] * A2[2])</span></span><br><span class="line">sheet.write(<span class="number">1</span>, <span class="number">1</span>, xlwt.Formula(<span class="string">'SUM(A1,B1)'</span>)) </span><br><span class="line"><span class="comment"># 在第二行第二列写入 A1+B1的结果 "7" (A1[5] + A2[2])</span></span><br></pre></td></tr></table></figure>

<p><strong>5）向单元格添加超链接</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet.write(<span class="number">0</span>, <span class="number">0</span>, xlwt.Formula(<span class="string">'HYPERLINK("http://www.google.com";"Google")'</span>)) </span><br><span class="line"><span class="comment"># 写入文字 "Google"  超链接 http://www.google.com</span></span><br></pre></td></tr></table></figure>

<p><strong>6）合并行和列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet.write_merge(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'First Merge'</span>) </span><br><span class="line"><span class="comment"># 合并第0行的0到3列</span></span><br><span class="line">sheet.write_merge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'Second Merge'</span>) </span><br><span class="line"><span class="comment"># 合并第1行到第2行的第0列到第3列</span></span><br></pre></td></tr></table></figure>

<p> <strong>7）设置单元格内容的对齐方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alignment = xlwt.Alignment()</span><br><span class="line">alignment.horz = xlwt.Alignment.HORZ_CENTER <span class="comment"># 水平居中</span></span><br><span class="line"><span class="comment"># 别的选项：HORZ_GENERAL, HORZ_LEFT, HORZ_CENTER, HORZ_RIGHT, HORZ_FILLED, HORZ_JUSTIFIED, HORZ_CENTER_ACROSS_SEL, HORZ_DISTRIBUTED</span></span><br><span class="line">alignment.vert = xlwt.Alignment.VERT_CENTER <span class="comment"># 垂直居中</span></span><br><span class="line"><span class="comment"># 别的选项: VERT_TOP, VERT_CENTER, VERT_BOTTOM, VERT_JUSTIFIED, VERT_DISTRIBUTED</span></span><br><span class="line">style = xlwt.XFStyle()</span><br><span class="line">style.alignment = alignment <span class="comment"># 设置对齐方式</span></span><br></pre></td></tr></table></figure>

<p><strong>8）为单元格添加边框</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">borders = xlwt.Borders()</span><br><span class="line"><span class="comment"># DASHED虚线 NO_LINE没有 THIN实线</span></span><br><span class="line"><span class="comment"># 别的选项: NO_LINE, THIN, MEDIUM, DASHED, DOTTED, THICK, DOUBLE, HAIR, MEDIUM_DASHED, THIN_DASH_DOTTED, MEDIUM_DASH_DOTTED, THIN_DASH_DOT_DOTTED, MEDIUM_DASH_DOT_DOTTED, SLANTED_MEDIUM_DASH_DOTTED, or 0x00 through 0x0D.</span></span><br><span class="line">borders.left = xlwt.Borders.DASHED</span><br><span class="line">borders.right = xlwt.Borders.DASHED</span><br><span class="line">borders.top = xlwt.Borders.DASHED</span><br><span class="line">borders.bottom = xlwt.Borders.DASHED</span><br><span class="line"><span class="comment"># 线的颜色</span></span><br><span class="line">borders.left_colour = <span class="number">0x40</span></span><br><span class="line">borders.right_colour = <span class="number">0x40</span></span><br><span class="line">borders.top_colour = <span class="number">0x40</span></span><br><span class="line">borders.bottom_colour = <span class="number">0x40</span></span><br><span class="line">style = xlwt.XFStyle() <span class="comment"># 创建样式</span></span><br><span class="line">style.borders = borders <span class="comment"># 设置边框样式</span></span><br></pre></td></tr></table></figure>

<p><strong>10）为单元格设置背景色</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = xlwt.Pattern()</span><br><span class="line">pattern.pattern = xlwt.Pattern.SOLID_PATTERN </span><br><span class="line"><span class="comment"># 其它选项: NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12</span></span><br><span class="line">pattern.pattern_fore_colour = <span class="number">5</span> </span><br><span class="line"><span class="comment"># 其它选项:0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on...</span></span><br><span class="line">style = xlwt.XFStyle()</span><br><span class="line">style.pattern = pattern	<span class="comment"># 设置背景样式</span></span><br></pre></td></tr></table></figure>

<h3 id="3-例子-1"><a href="#3-例子-1" class="headerlink" title="3. 例子"></a>3. 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># excel的存放路径</span></span><br><span class="line">excel_path = <span class="string">r'C:\Users\asus\Desktop\demo\data\02.xls'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelWrite</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.excel = xlwt.Workbook(encoding = <span class="string">'utf-8'</span>)  <span class="comment"># 创建一个工作簿</span></span><br><span class="line">        self.sheet = self.excel.add_sheet(<span class="string">'Sheet1'</span>)  <span class="comment"># 创建一个工作表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入单个值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_value</span><span class="params">(self, cell, value)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">            - cell: 传入一个单元格坐标参数，例如：cell=(0,0),表示修改第一行第一列</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.sheet.write(*cell, value)</span><br><span class="line">        <span class="comment"># （覆盖写入）要先用remove(),移动到指定路径，不然第二次在同一个路径保存会报错</span></span><br><span class="line">        os.remove(excel_path)</span><br><span class="line">        self.excel.save(excel_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入多个值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_values</span><span class="params">(self, cells, values)</span>:</span></span><br><span class="line">        <span class="string">''' </span></span><br><span class="line"><span class="string">            - cells: 传入一个单元格坐标参数的list，</span></span><br><span class="line"><span class="string">            - values: 传入一个修改值的list，</span></span><br><span class="line"><span class="string">            例如：cells = [(0, 0), (0, 1)],values = ('a', 'b')</span></span><br><span class="line"><span class="string">            表示将列表第一行第一列和第一行第二列，分别修改为 a 和 b</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 判断坐标参数和写入值的数量是否相等</span></span><br><span class="line">        <span class="keyword">if</span> len(cells) == len(values):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(values)):</span><br><span class="line">                <span class="comment"># 循环使用单个写入方法</span></span><br><span class="line">                self.write_value(cells[i], values[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"传参错误,单元格：%i个,写入值：%i个"</span> % (len(cells), len(values)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    EW = ExcelWrite()</span><br><span class="line">    cells1 = [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">0</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">2</span>)]</span><br><span class="line">    values1 = [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'score'</span>, <span class="number">1.0</span>, <span class="string">'张三'</span>, <span class="number">88.0</span>, <span class="number">2.0</span>, <span class="string">'李四'</span>, <span class="number">54.0</span>, <span class="number">3.0</span>, <span class="string">'王五'</span>, <span class="number">63.0</span>, <span class="number">4.0</span>, <span class="string">'赵六'</span>, <span class="number">84.0</span>]</span><br><span class="line">    EW.write_values(cells1, values1)</span><br></pre></td></tr></table></figure>

<h1 id="python操作xml文件"><a href="#python操作xml文件" class="headerlink" title="python操作xml文件"></a>python操作xml文件</h1><h2 id="一、xml文件概述"><a href="#一、xml文件概述" class="headerlink" title="一、xml文件概述"></a>一、xml文件概述</h2><h3 id="1-什么是xml文件？"><a href="#1-什么是xml文件？" class="headerlink" title="1. 什么是xml文件？"></a>1. 什么是xml文件？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml即可扩展标记语言，它可以用来标记数据，定义数据类型，是一种允许用户对自己标记语言进行定义的源语言。</span><br><span class="line">从结构上，很像HTML超文本标记语言。但他们被设计的目的是不同的。</span><br><span class="line">XML被设计用来传输和存储数据，HTML被设计用来显示数据。</span><br><span class="line"></span><br><span class="line">总结：xml用来组织，存储和发送信息的。</span><br></pre></td></tr></table></figure>

<h3 id="2-xml的特征"><a href="#2-xml的特征" class="headerlink" title="2. xml的特征"></a>2. xml的特征</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它是由标签对组成，例如标签的名称可以自定义标签可以有属性。标签对可以嵌入数据。abc标签对可以嵌入子标签对，具有层级关系。</span><br></pre></td></tr></table></figure>

<h3 id="3-XML文件结构"><a href="#3-XML文件结构" class="headerlink" title="3. XML文件结构"></a>3. XML文件结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XML文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。</span><br><span class="line">第一行是XML的声明，它定义XML的版本(1.0)和所使用的编码是根元素，也成为根节点是子元素(子节点)。</span><br><span class="line">XML文档必须包含根元素。该元素是所有其他元素的父元素。</span><br></pre></td></tr></table></figure>

<h2 id="二、python解析XML文件"><a href="#二、python解析XML文件" class="headerlink" title="二、python解析XML文件"></a>二、python解析XML文件</h2><p>python解析XML常见的有两种方法：</p>
<ol>
<li><strong>xml.dom模块</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它是W3C DOM API的实现，若需要处理DOM API则该模块很适合，注意xml.dom包里面有许多模块，须区分它们间的不同.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>xml.etree.ElementTree模块（简称 ET）</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它提供了轻量级的Python式的API，相对于DOM来说ET 快了很多，而且有很多令人愉悦的API可以使用，相对于SAX来说ET的ET.iterparse也提供了 “在空中” 的处理方式，没有必要加载整个文档到内存，ET的性能的平均值和SAX差不多，但是API的效率更高一点而且使用起来很方便。</span><br></pre></td></tr></table></figure>

<h3 id="1-xml-etree-ElementTree-模块"><a href="#1-xml-etree-ElementTree-模块" class="headerlink" title="1.  xml.etree.ElementTree 模块"></a>1.  <strong>xml.etree.ElementTree</strong> 模块</h3><h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 导入</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="comment"># 2. 打开xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">'./data/03.xml'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取根元素</span></span><br><span class="line"><span class="comment"># 根元素并没有属性,根元素（root）是一个Element对象.</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 XML 字符串</span></span><br><span class="line"><span class="comment"># ET 模块的fromstring()函数提供从 XML 字符串构造一个Element对象的功能。</span></span><br><span class="line">xml_str = ET.tostring(root)</span><br><span class="line">print(xml_str)</span><br><span class="line">root = ET.fromstring(xml_str)</span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性</span></span><br><span class="line">child.attrib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取标签</span></span><br><span class="line">root.tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素下的内容</span></span><br><span class="line">child.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引值来访问特定的子元素</span></span><br><span class="line">child[<span class="number">0</span>].tag</span><br><span class="line">child[<span class="number">0</span>].text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对某个元素对象之下所有的子元素进行深度优先遍历（DFS）</span></span><br><span class="line">tree.iter()</span><br><span class="line"><span class="comment"># iter方法可以接受tag名称</span></span><br><span class="line"><span class="comment"># 遍历所有具备所提供tag的元素</span></span><br><span class="line">tree.iter(tag=<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找xml节点</span></span><br><span class="line"><span class="comment"># 使用Element.findall()或者Element.find()方法，会从结点的直接子结点中查找，并不会递归查找。 </span></span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'food'</span>):	<span class="comment"># 查找所有food元素</span></span><br><span class="line">    rank = country.find(<span class="string">'price'</span>).text	<span class="comment"># 查找price元素</span></span><br><span class="line">    name = country.get(<span class="string">'ID'</span>)	<span class="comment"># 获取元素的ID属性</span></span><br></pre></td></tr></table></figure>

<h4 id="3-支持通过XPath查找元素"><a href="#3-支持通过XPath查找元素" class="headerlink" title="3. 支持通过XPath查找元素"></a>3. 支持通过XPath查找元素</h4><p>​    使用XPath查找感兴趣的元素，更加方便。Element对象中有一些find方法可以接受Xpath路径作为参数，find方法会返回第一个匹配的子元素，findall以列表的形式返回所有匹配的子元素, iterfind则返回一个所有匹配元素的迭代器（iterator）。ElementTree对象也具备这些方法，相应地它的查找是从根节点开始的。</p>
<p>下面是一个使用XPath查找元素的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> tree.iterfind(<span class="string">'food/name'</span>):</span><br><span class="line">    print(elem.tag, elem.text)</span><br></pre></td></tr></table></figure>

<p>上面的代码返回了food元素之下所有tag为name的元素。</p>
<p>接下来查找所有具备某个ID属性的food元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> tree.iterfind(<span class="string">'food[@ID="02"]'</span>):    </span><br><span class="line">	print(elem.attrib)</span><br></pre></td></tr></table></figure>

<h4 id="4-构建XML文档"><a href="#4-构建XML文档" class="headerlink" title="4. 构建XML文档"></a>4. 构建XML文档</h4><p>一般来说，有两种主要使用场景 :</p>
<ol>
<li><strong>先读取一个XML文档，进行修改，然后再将修改写入文档.</strong></li>
<li><strong>从头创建一个新XML文档。</strong></li>
</ol>
<p><strong>修改文档</strong>的话，可以通过调整Element对象来实现。请看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">tree = ET.parse(<span class="string">'./data/03.xml'</span>)    <span class="comment"># 打开xml文件</span></span><br><span class="line">root = tree.getroot()         <span class="comment">#获得根元素</span></span><br><span class="line"><span class="keyword">del</span> root[<span class="number">1</span>]		<span class="comment"># 删除一个元素</span></span><br><span class="line">root[<span class="number">0</span>].set(<span class="string">'name'</span>, <span class="string">'waffle'</span>)	<span class="comment"># 给元素添加一个属性 </span></span><br><span class="line">root[<span class="number">0</span>].attrib[<span class="string">'ID'</span>] = <span class="string">'001'</span>	<span class="comment"># 更改元素属性 </span></span><br><span class="line">root[<span class="number">0</span>].text = <span class="string">'11111111'</span>	<span class="comment"># 更改标签下的内容</span></span><br><span class="line">tree.write(<span class="string">'./data/03.xml'</span>,encoding=<span class="string">'utf-8'</span>)	<span class="comment"># 重新写入文件</span></span><br></pre></td></tr></table></figure>

<p>如果我们需要<strong>从头构造 XML 文档</strong>，可以使用 ET 模块的 Element类以及<code>SubElement()</code>函数。</p>
<p>可以使用Element类来生成一个Element对象作为根结点，然后使用<code>ET.SubElement()</code>函数生成子结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">a = ET.Element(<span class="string">'a'</span>) <span class="comment"># 创造一个根元素</span></span><br><span class="line">b = ET.SubElement(a, <span class="string">'b'</span>)   <span class="comment"># 在a根元素下创建一个b子元素</span></span><br><span class="line">b.text = <span class="string">'leehao.me'</span>    <span class="comment"># 添加b子元素的内容</span></span><br><span class="line">c = ET.SubElement(a, <span class="string">'c'</span>)   <span class="comment"># 创建子元素</span></span><br><span class="line">c.attrib[<span class="string">'greeting'</span>] = <span class="string">'hello'</span>  <span class="comment"># 给子元素创建属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先构造一个 ElementTree 以便使用其 write 方法</span></span><br><span class="line">tree = ET.ElementTree(a)</span><br><span class="line">tree.write(<span class="string">'a.xml'</span>, encoding=<span class="string">'UTF-8'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-xml-dom模块"><a href="#2-xml-dom模块" class="headerlink" title="2. xml.dom模块"></a>2. xml.dom模块</h3><p><a href="http://www.php100.com/manual/w/xmldom/index.asp.htm" target="_blank" rel="noopener">xml.dom详情</a></p>
<h4 id="1-使用-1"><a href="#1-使用-1" class="headerlink" title="1. 使用"></a>1. 使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> parse</span><br><span class="line"><span class="comment"># 加载读取XML文件</span></span><br><span class="line">domTree = parse(<span class="string">"./data/03.xml"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取XML文件的根节点</span></span><br><span class="line">root = domTree.documentElement</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点名称</span></span><br><span class="line">root.nodeName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点的值</span></span><br><span class="line">root.nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点的类型</span></span><br><span class="line">root.nodeType</span><br></pre></td></tr></table></figure>

<p><strong>更多节点类型：</strong></p>
<table>
<thead>
<tr>
<th><strong>NodeType</strong></th>
<th><strong>Named Constant</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ELEMENT_NODE</td>
</tr>
<tr>
<td>2</td>
<td>ATTRIBUTE_NODE</td>
</tr>
<tr>
<td>3</td>
<td>TEXT_NODE</td>
</tr>
<tr>
<td>4</td>
<td>CDATA_SECTION_NODE</td>
</tr>
<tr>
<td>5</td>
<td>ENTITY_REFERENCE_NODE</td>
</tr>
<tr>
<td>6</td>
<td>ENTITY_NODE</td>
</tr>
<tr>
<td>7</td>
<td>PROCESSING_INSTRUCTION_NODE</td>
</tr>
<tr>
<td>8</td>
<td>COMMENT_NODE</td>
</tr>
<tr>
<td>9</td>
<td>DOCUMENT_NODE</td>
</tr>
<tr>
<td>10</td>
<td>DOCUMENT_TYPE_NODE</td>
</tr>
<tr>
<td>11</td>
<td>DOCUMENT_FRAGMENT_NODE</td>
</tr>
<tr>
<td>12</td>
<td>NOTATION_NODE</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取XML节点属性值</span></span><br><span class="line">node.getAttribute(AttributeName)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取XML节点对象集合</span></span><br><span class="line">node.getElementsByTagName(TagName)	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回子节点列表</span></span><br><span class="line">node.childNodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第一个节点，root.childNodes[0]</span></span><br><span class="line">node.firstChild</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回Node节点的xml表示的文本，括号中可写编码格式</span></span><br><span class="line">domTree.toxml()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素属性</span></span><br><span class="line">a = node.attributes[<span class="string">"ID"</span>]</span><br><span class="line">a.name 		<span class="comment"># 属性名称</span></span><br><span class="line">a.value 	<span class="comment"># 属性的值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断属性是否存在 存在返回true 否则返回false</span></span><br><span class="line">food.hasAttribute(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取节点下的文本</span></span><br><span class="line">node.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个节点</span></span><br><span class="line">domTree.createElement(nodeName)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个属性</span></span><br><span class="line">node.setAttribute(attributeName,attributeValue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文档对象，文档对象用于创建各种节点。</span></span><br><span class="line">xml.dom.getDOMImplementation()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新 Document 对象和指定的根元素。</span></span><br><span class="line">nodeObject.createDocument(namespaceURI,qualifiedName,doctype)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">namespaceURI</td>
<td align="left">为文档创建的根元素的命名空间的唯一标识符。如果没有命名空间，则为 null。</td>
</tr>
<tr>
<td align="left">qualifiedName</td>
<td align="left">为文档创建的根元素的名称。如果 namespaceURI 不为 null，该名称应该包括命名空间前缀和冒号。</td>
</tr>
<tr>
<td align="left">doctype</td>
<td align="left">新创建的 Document 对象的 DocumentType 对象。如果没有想得到的 DocumentType 对象，则为 null。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置节点的文本</span></span><br><span class="line">domTree.createTextNode(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载子节点</span></span><br><span class="line">name_node.appendChild(name_text_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">xmlfile = open(<span class="string">'03.xml'</span>, <span class="string">'w'</span>)</span><br><span class="line">domTree.writexml(xmlfile,encoding=<span class="string">'GBK'</span>,)</span><br><span class="line">xmlfile.close()</span><br></pre></td></tr></table></figure>

<h4 id="3-创建xml文件"><a href="#3-创建xml文件" class="headerlink" title="3. 创建xml文件"></a>3. 创建xml文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_element</span><span class="params">(doc,tag,attr)</span>:</span></span><br><span class="line">    <span class="comment">#创建一个元素节点</span></span><br><span class="line">    elementNode=doc.createElement(tag)</span><br><span class="line">    <span class="comment">#创建一个文本节点</span></span><br><span class="line">    textNode=doc.createTextNode(attr)</span><br><span class="line">    <span class="comment">#将文本节点作为元素节点的子节点</span></span><br><span class="line">    elementNode.appendChild(textNode)</span><br><span class="line">    <span class="keyword">return</span> elementNode</span><br><span class="line"></span><br><span class="line">dom1=xml.dom.getDOMImplementation() <span class="comment">#创建文档对象，文档对象用于创建各种节点。</span></span><br><span class="line">doc=dom1.createDocument(<span class="literal">None</span>,<span class="string">"breakfast_menu"</span>,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">top_element = doc.documentElement<span class="comment"># 得到根节点</span></span><br><span class="line">books=[&#123;<span class="string">'name'</span>: <span class="string">u'早餐'</span>, <span class="string">'price'</span>: <span class="string">u'6'</span>, <span class="string">'description'</span>: <span class="string">u'两个鸡蛋，熏肉或香肠和烤面包。'</span>, <span class="string">'id'</span>: <span class="string">u'01'</span>&#125;,</span><br><span class="line">       &#123;<span class="string">'name'</span>: <span class="string">'午餐'</span>, <span class="string">'price'</span>: <span class="string">'7'</span>, <span class="string">'description'</span>: <span class="string">'两个鸡蛋，熏肉或香肠和烤面包。'</span>, <span class="string">'id'</span>: <span class="string">'02'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    sNode=doc.createElement(<span class="string">'food'</span>)</span><br><span class="line">    sNode.setAttribute(<span class="string">'id'</span>,str(book[<span class="string">'id'</span>]))</span><br><span class="line">    nameNode=create_element(doc,<span class="string">'name'</span>,book[<span class="string">'name'</span>])</span><br><span class="line">    priceNode=create_element(doc,<span class="string">'price'</span>,book[<span class="string">'price'</span>])</span><br><span class="line">    descriptionNode=create_element(doc,<span class="string">'description'</span>,book[<span class="string">'description'</span>])</span><br><span class="line"></span><br><span class="line">    sNode.appendChild(nameNode)</span><br><span class="line">    sNode.appendChild(priceNode)</span><br><span class="line">    sNode.appendChild(descriptionNode)</span><br><span class="line">    top_element.appendChild(sNode)<span class="comment"># 将遍历的节点添加到根节点下</span></span><br><span class="line"></span><br><span class="line">xmlfile=open(<span class="string">'03.xml'</span>,<span class="string">'w'</span>)</span><br><span class="line">doc.writexml(xmlfile,addindent=<span class="string">' '</span>*<span class="number">4</span>, newl=<span class="string">'\n'</span>, encoding=<span class="string">'GBK'</span>)</span><br><span class="line">xmlfile.close()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python拓展库</tag>
      </tags>
  </entry>
  <entry>
    <title>异常、断言</title>
    <url>/2020/02/08/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>所谓的异常就是我们代码中的BUG，想必大家都不陌生，比如逻辑错误，语法错误。也就是我们常见的ERROR。异常的出现会导致程序无法继续向下执行。</p>
</li>
<li><p>程序测试阶段，异常出现，我们要根据抛出的异常来修改我们的造成错误的代码。</p>
</li>
<li><p>异常的处理除去根据报错信息进行修改代码外，还可以使用<strong>try</strong>/<strong>except</strong>来捕获异常</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except.png" alt="异常捕获"></p>
<ul>
<li>异常捕获的目的是为了提高我们代码的健壮性。保证我们代码的可执行性。异常捕获可以帮助我们做好留痕工作，对有问题的数据进行收集处理。 </li>
</ul>
</li>
</ul>
<h2 id="常见的几种异常"><a href="#常见的几种异常" class="headerlink" title="常见的几种异常"></a>常见的几种异常</h2><ul>
<li><p><strong>NAMEError</strong>(使用未定义变量)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys<span class="comment">##在这儿我们使用了未定义的变量，引发了NAMEError的错误，并且告诉我们在代码的第一行</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'keys'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">#解决办法，根据提示找到对应的变量，在使用前先定义。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>ModuleNotFoundError</strong>(引入错误)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> a <span class="comment">##我们尝试导入未有的模块a，引发了ModuleNotFoundError的错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'a'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">#解决办法，导入正确的模块</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>IndexError</strong>(索引错误）</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]<span class="comment">##我们定义列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list1[<span class="number">5</span>])<span class="comment">##输出列表中索引5的元素引发IndexError的错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line"><span class="comment">##解决办法，不要超出列表索引范围</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>KeyError</strong>(字典错误)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1=&#123;<span class="string">'1'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dict1[<span class="string">'2'</span>])<span class="comment">##输出未定义key，引发KeyError错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'2'</span></span><br><span class="line"><span class="comment">##解决办法，使用存在的key</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>*<em>IndentationError *</em>(缩进错误)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">1</span>==<span class="literal">True</span>:<span class="comment">#判断条件下午缩进，引发IndentationError 错误</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'True'</span>)</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span></span><br><span class="line">    print(<span class="string">'True'</span>)</span><br><span class="line">        ^</span><br><span class="line">IndentationError: expected an indented block</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">##解决办法，注意缩进问题。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>*<em>SyntaxError *</em>(语法错误)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">1</span>==<span class="literal">True</span><span class="comment">##缺少冒号，引发SyntaxError </span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>==<span class="literal">True</span></span><br><span class="line">             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">#解决办法，正确使用python语法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>*<em>TypeError *</em>(类型错误)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>+<span class="string">'1'</span><span class="comment">#整型字符串相加，引发TypeError </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">##正确使用数据类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>*<em>ZeroDivisionError *</em>(除数为0)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">0</span><span class="comment">#除数为0，引发ZeroDivisionError 错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">##0不能为除数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>AttributeError</strong>(位置对象属性)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.open()<span class="comment">#列表没有open（）属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'list'</span> object has no attribute <span class="string">'open'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>ValueError</strong>(传给函数的参数不正确)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">"99 years ago."</span>)<span class="comment">#字符串不能int</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'99 years ago.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">demo = &#123;<span class="string">"China"</span>: <span class="string">"Beijing"</span>, <span class="string">"Japan"</span>: <span class="string">"Tokyo"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> demo:<span class="comment">#这样只能遍历出key</span></span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="python标准异常"><a href="#python标准异常" class="headerlink" title="python标准异常"></a>python标准异常</h2><table>
<thead>
<tr>
<th align="left">异常名称</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">BaseException</td>
<td align="right">所有异常的基类</td>
</tr>
<tr>
<td align="left">SystemExit</td>
<td align="right">解释器请求退出</td>
</tr>
<tr>
<td align="left">KeyboardInterrupt</td>
<td align="right">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td align="left">Exception</td>
<td align="right">常规错误的基类</td>
</tr>
<tr>
<td align="left">StopIteration</td>
<td align="right">迭代器没有更多的值</td>
</tr>
<tr>
<td align="left">GeneratorExit</td>
<td align="right">生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td align="left">StandardError</td>
<td align="right">所有的内建标准异常的基类</td>
</tr>
<tr>
<td align="left">ArithmeticError</td>
<td align="right">所有数值计算错误的基类</td>
</tr>
<tr>
<td align="left">FloatingPointError</td>
<td align="right">浮点计算错误</td>
</tr>
<tr>
<td align="left">OverflowError</td>
<td align="right">数值运算超出最大限制</td>
</tr>
<tr>
<td align="left">ZeroDivisionError</td>
<td align="right">除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td align="left">AssertionError</td>
<td align="right">断言语句失败</td>
</tr>
<tr>
<td align="left">AttributeError</td>
<td align="right">对象没有这个属性</td>
</tr>
<tr>
<td align="left">EOFError</td>
<td align="right">没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td align="left">EnvironmentError</td>
<td align="right">操作系统错误的基类</td>
</tr>
<tr>
<td align="left">IOError</td>
<td align="right">输入/输出操作失败</td>
</tr>
<tr>
<td align="left">OSError</td>
<td align="right">操作系统错误</td>
</tr>
<tr>
<td align="left">WindowsError</td>
<td align="right">系统调用失败</td>
</tr>
<tr>
<td align="left">ImportError</td>
<td align="right">导入模块/对象失败</td>
</tr>
<tr>
<td align="left">LookupError</td>
<td align="right">无效数据查询的基类</td>
</tr>
<tr>
<td align="left">IndexError</td>
<td align="right">序列中没有此索引(index)</td>
</tr>
<tr>
<td align="left">KeyError</td>
<td align="right">映射中没有这个键</td>
</tr>
<tr>
<td align="left">MemoryError</td>
<td align="right">内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td align="left">NameError</td>
<td align="right">未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td align="left">UnboundLocalError</td>
<td align="right">访问未初始化的本地变量</td>
</tr>
<tr>
<td align="left">ReferenceError</td>
<td align="right">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td align="left">RuntimeError</td>
<td align="right">一般的运行时错误</td>
</tr>
<tr>
<td align="left">NotImplementedError</td>
<td align="right">尚未实现的方法</td>
</tr>
<tr>
<td align="left">SyntaxError</td>
<td align="right">Python 语法错误</td>
</tr>
<tr>
<td align="left">IndentationError</td>
<td align="right">缩进错误</td>
</tr>
<tr>
<td align="left">TabError</td>
<td align="right">Tab 和空格混用</td>
</tr>
<tr>
<td align="left">SystemError</td>
<td align="right">一般的解释器系统错误</td>
</tr>
<tr>
<td align="left">TypeError</td>
<td align="right">对类型无效的操作</td>
</tr>
<tr>
<td align="left">ValueError</td>
<td align="right">传入无效的参数</td>
</tr>
<tr>
<td align="left">UnicodeError</td>
<td align="right">Unicode 相关的错误</td>
</tr>
<tr>
<td align="left">UnicodeDecodeError</td>
<td align="right">Unicode 解码时的错误</td>
</tr>
<tr>
<td align="left">UnicodeEncodeError</td>
<td align="right">Unicode 编码时错误</td>
</tr>
<tr>
<td align="left">UnicodeTranslateError</td>
<td align="right">Unicode 转换时错误</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="right">警告的基类</td>
</tr>
<tr>
<td align="left">DeprecationWarning</td>
<td align="right">关于被弃用的特征的警告</td>
</tr>
<tr>
<td align="left">FutureWarning</td>
<td align="right">关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td align="left">OverflowWarning</td>
<td align="right">旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td align="left">PendingDeprecationWarning</td>
<td align="right">关于特性将会被废弃的警告</td>
</tr>
<tr>
<td align="left">RuntimeWarning</td>
<td align="right">可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td align="left">SyntaxWarning</td>
<td align="right">可疑的语法的警告</td>
</tr>
<tr>
<td align="left">UserWarning</td>
<td align="right">用户代码生成的警告</td>
</tr>
</tbody></table>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><ul>
<li><p>异常捕获也就是上面说过的<strong>try</strong>/<strong>except</strong>，也可加上<strong>else</strong>或者<strong>finally</strong>一起使用</p>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常的操作</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">except</span>:<span class="comment">##如果后面不添加错误类型，则捕获所有错误，也可以使用(Exception1[, Exception2[,...ExceptionN]]])将需要捕获的错误类型写入</span></span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    不管异常是否发生，都会执行</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li>有时候系统提供的异常类型不能满足开发的需求。这时候你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.用户自定义异常类型，只要该类继承了Exception类即可，至于类的主题内容用户自定义，可参考官方异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'测试'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    rasie MyError()</span><br></pre></td></tr></table></figure>

<ul>
<li>系统的自带的异常只要触发会自动抛出，比如NameError，但用户自定义的异常需要用户自己决定什么时候抛出。 raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。大多数的异常的名字都以”Error”结尾，所以实际命名时尽量跟标准的异常命名一样。</li>
</ul>
<h2 id="断言（assert"><a href="#断言（assert" class="headerlink" title="断言（assert)"></a>断言（<strong>assert</strong>)</h2><ul>
<li><strong>assert</strong>用于判断一个表达式，在表达式条件为flase的时候触发异常</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/07/assert.png" alt="断言"></p>
<ul>
<li><p>语法格式 assert  expression 等价于</p>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> expression:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下实例判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码： </p>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">assert</span> (<span class="string">'linux'</span> <span class="keyword">in</span> sys.platform), <span class="string">"该代码只能在 Linux 下执行"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来要执行的代码</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python四大模块</title>
    <url>/2020/02/08/python%E5%9B%9B%E5%A4%A7%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><ul>
<li><p><strong>OS</strong>是Operating System的缩写，是操作系统的意思，<strong>OS</strong>模块是python标准库中的一个用于访问操作系统功能的模块。</p>
</li>
<li><p>os.name，指示你使用的工作平台 Windows（nt），Linux（posix）</p>
</li>
<li><p>os.environ，返回环境相关的信息，主要是各类环境变量</p>
</li>
<li><p>os.walk（），这个函数需要传入一个路径作为<code>top</code>参数，函数的作用是在以<code>top</code>为根节点的目录树中游走，对树中的每个目录生成一个由<code>(dirpath, dirnames, filenames)</code>三项组成的三元组。 </p>
</li>
<li><p>os.listdir（）列出（当前）目录下的全部路径（及文件）。该函数存在一个参数，用以指定要列出子目录的路径，默认为<code>“.”</code>，即“当前路径”。 </p>
</li>
<li><p>os.mkdir（）用处是“新建一个路径”。需要传入一个类路径参数用以指</p>
</li>
<li><p>定新建路径的位置和名称，如果指定路径已存在，则会抛出<code>FileExistsError</code>异常。 新建一级路径 </p>
</li>
<li><p>os.remove（）用于删除文件，如果指定路径是目录而非文件的话，就会抛出<code>IsADirectoryError</code>异常。 </p>
</li>
<li><p>os.rmdir（）用于删除目录</p>
</li>
<li><p>os.makedirs() 新建多级路径 ，函数<code>os.makedirs()</code>执行的是递归创建 </p>
</li>
<li><p>os.removedirs() 递归删除 ，该函数会尝试从最下级目录开始，逐级删除指定的路径，几乎就是一个<code>os.makedirs()</code>的逆过程；一旦遇到非空目录即停止。 </p>
</li>
<li><p>os.rename（）该函数的作用是将文件或路径重命名，一般调用格式为<code>os.rename(src, dst)</code>，即将<code>src</code>指向的文件或路径重命名为<code>dst</code>指定的名称。 </p>
</li>
<li><p>os.getcwd（）获取当前工作路径 </p>
</li>
<li><p>os.chdir（）切换当前工作路径为指定路径。 </p>
<h3 id="OS-PATH模块"><a href="#OS-PATH模块" class="headerlink" title="OS.PATH模块"></a><strong>OS.PATH模块</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>os.path.abspath(path)</td>
<td>返回绝对路径</td>
</tr>
<tr>
<td>os.path.basename(path)</td>
<td>返回文件名</td>
</tr>
<tr>
<td>os.path.commonprefix(list)</td>
<td>返回list(多个路径)中，所有path共有的最长的路径</td>
</tr>
<tr>
<td>os.path.dirname(path)</td>
<td>返回文件路径</td>
</tr>
<tr>
<td>os.path.exists(path)</td>
<td>如果路径 path 存在，返回 True；如果路径 path 不存在，返回 False。</td>
</tr>
<tr>
<td>os.path.lexists</td>
<td>路径存在则返回True,路径损坏也返回True</td>
</tr>
<tr>
<td>os.path.expanduser(path)</td>
<td>把path中包含的”<del>“和”</del>user”转换成用户目录</td>
</tr>
<tr>
<td>os.path.expandvars(path)</td>
<td>根据环境变量的值替换path中包含的”$name”和”${name}”</td>
</tr>
<tr>
<td>os.path.getatime(path)</td>
<td>返回最近访问时间（浮点型秒数）</td>
</tr>
<tr>
<td>os.path.getmtime(path)</td>
<td>返回最近文件修改时间</td>
</tr>
<tr>
<td>os.path.getctime(path)</td>
<td>返回文件 path 创建时间</td>
</tr>
<tr>
<td>os.path.getsize(path)</td>
<td>返回文件大小，如果文件不存在就返回错误</td>
</tr>
<tr>
<td>os.path.isabs(path)</td>
<td>判断是否为绝对路径</td>
</tr>
<tr>
<td>os.path.isfile(path)</td>
<td>判断路径是否为文件</td>
</tr>
<tr>
<td>os.path.isdir(path)</td>
<td>判断路径是否为目录</td>
</tr>
<tr>
<td>os.path.islink(path)</td>
<td>判断路径是否为链接</td>
</tr>
<tr>
<td>os.path.ismount(path)</td>
<td>判断路径是否为挂载点</td>
</tr>
<tr>
<td>os.path.join(path1[, path2[, …]])</td>
<td>把目录和文件名合成一个路径</td>
</tr>
<tr>
<td>os.path.normcase(path)</td>
<td>转换path的大小写和斜杠</td>
</tr>
<tr>
<td>os.path.normpath(path)</td>
<td>规范path字符串形式</td>
</tr>
<tr>
<td>os.path.realpath(path)</td>
<td>返回path的真实路径</td>
</tr>
<tr>
<td>os.path.relpath(path[, start])</td>
<td>从start开始计算相对路径</td>
</tr>
<tr>
<td>os.path.samefile(path1, path2)</td>
<td>判断目录或文件是否相同</td>
</tr>
<tr>
<td>os.path.sameopenfile(fp1, fp2)</td>
<td>判断fp1和fp2是否指向同一文件</td>
</tr>
<tr>
<td>os.path.samestat(stat1, stat2)</td>
<td>判断stat tuple stat1和stat2是否指向同一个文件</td>
</tr>
<tr>
<td>os.path.split(path)</td>
<td>把路径分割成 dirname 和 basename，返回一个元组</td>
</tr>
<tr>
<td>os.path.splitdrive(path)</td>
<td>一般用在 windows 下，返回驱动器名和路径组成的元组</td>
</tr>
<tr>
<td>os.path.splitext(path)</td>
<td>分割路径，返回路径名和文件扩展名的元组</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>os.path.supports_unicode_filenames</td>
<td>设置是否支持unicode路径名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="https://www.runoob.com/python/os-access.html" target="_blank" rel="noopener">os.access(path, mode)</a> 检验权限模式</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/python/os-chdir.html" target="_blank" rel="noopener">os.chdir(path)</a> 改变当前工作目录</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/python/os-chflags.html" target="_blank" rel="noopener">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/python/os-chmod.html" target="_blank" rel="noopener">os.chmod(path, mode)</a> 更改权限</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.runoob.com/python/os-chown.html" target="_blank" rel="noopener">os.chown(path, uid, gid)</a> 更改文件所有者</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/python/os-chroot.html" target="_blank" rel="noopener">os.chroot(path)</a> 改变当前进程的根目录</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.runoob.com/python/os-close.html" target="_blank" rel="noopener">os.close(fd)</a> 关闭文件描述符 fd</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.runoob.com/python/os-closerange.html" target="_blank" rel="noopener">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.runoob.com/python/os-dup.html" target="_blank" rel="noopener">os.dup(fd)</a> 复制文件描述符 fd</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/python/os-dup2.html" target="_blank" rel="noopener">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.runoob.com/python/os-fchdir.html" target="_blank" rel="noopener">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/python/os-fchmod.html" target="_blank" rel="noopener">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/python/os-fchown.html" target="_blank" rel="noopener">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/python/os-fdatasync.html" target="_blank" rel="noopener">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td>15</td>
<td>[os.fdopen(fd[, mode[, bufsize]])](<a href="https://www.runoob.com/python/os-fdopen.html" target="_blank" rel="noopener">https://www.runoob.com/python/os-fdopen.html</a>) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td>16</td>
<td><a href="https://www.runoob.com/python/os-fpathconf.html" target="_blank" rel="noopener">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/python/os-fstat.html" target="_blank" rel="noopener">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td>18</td>
<td><a href="https://www.runoob.com/python/os-fstatvfs.html" target="_blank" rel="noopener">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td>19</td>
<td><a href="https://www.runoob.com/python/os-fsync.html" target="_blank" rel="noopener">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td>20</td>
<td><a href="https://www.runoob.com/python/os-ftruncate.html" target="_blank" rel="noopener">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td>21</td>
<td><a href="https://www.runoob.com/python/os-getcwd.html" target="_blank" rel="noopener">os.getcwd()</a> 返回当前工作目录</td>
</tr>
<tr>
<td>22</td>
<td><a href="https://www.runoob.com/python/os-getcwdu.html" target="_blank" rel="noopener">os.getcwdu()</a> 返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td>23</td>
<td><a href="https://www.runoob.com/python/os-isatty.html" target="_blank" rel="noopener">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td>24</td>
<td><a href="https://www.runoob.com/python/os-lchflags.html" target="_blank" rel="noopener">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td>25</td>
<td><a href="https://www.runoob.com/python/os-lchmod.html" target="_blank" rel="noopener">os.lchmod(path, mode)</a> 修改连接文件权限</td>
</tr>
<tr>
<td>26</td>
<td><a href="https://www.runoob.com/python/os-lchown.html" target="_blank" rel="noopener">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://www.runoob.com/python/os-link.html" target="_blank" rel="noopener">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td>28</td>
<td><a href="https://www.runoob.com/python/os-listdir.html" target="_blank" rel="noopener">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td>29</td>
<td><a href="https://www.runoob.com/python/os-lseek.html" target="_blank" rel="noopener">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td>30</td>
<td><a href="https://www.runoob.com/python/os-lstat.html" target="_blank" rel="noopener">os.lstat(path)</a> 像stat(),但是没有软链接</td>
</tr>
<tr>
<td>31</td>
<td><a href="https://www.runoob.com/python/os-major.html" target="_blank" rel="noopener">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td>32</td>
<td><a href="https://www.runoob.com/python/os-makedev.html" target="_blank" rel="noopener">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td>33</td>
<td><a href="https://www.runoob.com/python/os-makedirs.html" target="_blank" rel="noopener">os.makedirs(path[, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td>34</td>
<td><a href="https://www.runoob.com/python/os-minor.html" target="_blank" rel="noopener">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td>35</td>
<td><a href="https://www.runoob.com/python/os-mkdir.html" target="_blank" rel="noopener">os.mkdir(path[, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td>36</td>
<td><a href="https://www.runoob.com/python/os-mkfifo.html" target="_blank" rel="noopener">os.mkfifo(path[, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td>37</td>
<td><a href="https://www.runoob.com/python/os-mknod.html" target="_blank" rel="noopener">os.mknod(filename[, mode=0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td>38</td>
<td><a href="https://www.runoob.com/python/os-open.html" target="_blank" rel="noopener">os.open(file, flags[, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td>39</td>
<td><a href="https://www.runoob.com/python/os-openpty.html" target="_blank" rel="noopener">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td>40</td>
<td><a href="https://www.runoob.com/python/os-pathconf.html" target="_blank" rel="noopener">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td>41</td>
<td><a href="https://www.runoob.com/python/os-pipe.html" target="_blank" rel="noopener">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td>42</td>
<td>[os.popen(command[, mode[, bufsize]])](<a href="https://www.runoob.com/python/os-popen.html" target="_blank" rel="noopener">https://www.runoob.com/python/os-popen.html</a>) 从一个 command 打开一个管道</td>
</tr>
<tr>
<td>43</td>
<td><a href="https://www.runoob.com/python/os-read.html" target="_blank" rel="noopener">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td>44</td>
<td><a href="https://www.runoob.com/python/os-readlink.html" target="_blank" rel="noopener">os.readlink(path)</a> 返回软链接所指向的文件</td>
</tr>
<tr>
<td>45</td>
<td><a href="https://www.runoob.com/python/os-remove.html" target="_blank" rel="noopener">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td>46</td>
<td><a href="https://www.runoob.com/python/os-removedirs.html" target="_blank" rel="noopener">os.removedirs(path)</a> 递归删除目录。</td>
</tr>
<tr>
<td>47</td>
<td><a href="https://www.runoob.com/python/os-rename.html" target="_blank" rel="noopener">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td>48</td>
<td><a href="https://www.runoob.com/python/os-renames.html" target="_blank" rel="noopener">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td>49</td>
<td><a href="https://www.runoob.com/python/os-rmdir.html" target="_blank" rel="noopener">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td>50</td>
<td><a href="https://www.runoob.com/python/os-stat.html" target="_blank" rel="noopener">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td>51</td>
<td><a href="https://www.runoob.com/python/os-stat_float_times.html" target="_blank" rel="noopener">os.stat_float_times([newvalue])</a> 决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td>52</td>
<td><a href="https://www.runoob.com/python/os-statvfs.html" target="_blank" rel="noopener">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td>53</td>
<td><a href="https://www.runoob.com/python/os-symlink.html" target="_blank" rel="noopener">os.symlink(src, dst)</a> 创建一个软链接</td>
</tr>
<tr>
<td>54</td>
<td><a href="https://www.runoob.com/python/os-tcgetpgrp.html" target="_blank" rel="noopener">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td>55</td>
<td><a href="https://www.runoob.com/python/os-tcsetpgrp.html" target="_blank" rel="noopener">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td>56</td>
<td>[os.tempnam([dir[, prefix]])](<a href="https://www.runoob.com/python/os-tempnam.html" target="_blank" rel="noopener">https://www.runoob.com/python/os-tempnam.html</a>) 返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td>57</td>
<td><a href="https://www.runoob.com/python/os-tmpfile.html" target="_blank" rel="noopener">os.tmpfile()</a> 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td>58</td>
<td><a href="https://www.runoob.com/python/os-tmpnam.html" target="_blank" rel="noopener">os.tmpnam()</a> 为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td>59</td>
<td><a href="https://www.runoob.com/python/os-ttyname.html" target="_blank" rel="noopener">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td>60</td>
<td><a href="https://www.runoob.com/python/os-unlink.html" target="_blank" rel="noopener">os.unlink(path)</a> 删除文件路径</td>
</tr>
<tr>
<td>61</td>
<td><a href="https://www.runoob.com/python/os-utime.html" target="_blank" rel="noopener">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td>62</td>
<td>[os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](<a href="https://www.runoob.com/python/os-walk.html" target="_blank" rel="noopener">https://www.runoob.com/python/os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td>63</td>
<td><a href="https://www.runoob.com/python/os-write.html" target="_blank" rel="noopener">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
</tbody></table>
</li>
</ul>
<p>##SYS模块</p>
<ul>
<li><strong>SYS</strong>是system的缩写，即系统的意思。该模块提供对解释器使用或维护的一些变量的访问，以及与解释器强烈交互的函数。它始终可用 </li>
<li>sys.argv          获取当前正在执行的命令行参数的参数列表（list）</li>
<li>sys.modules.keys()   返回所有已经导入的模块列表</li>
<li>sys.platform     获取当前执行环境的平台</li>
<li>sys.path   path是一个目录列表，供Python从中查找第三方扩展模块。</li>
<li>sys.exit(n)     调用sys,exit(n)可以中途退出程序，sys.exit(0)表示正常退出，n不为0时，会引发SystemExit异常，从而在主程序中可以捕获该异常。 </li>
<li>sys.version  获取python解释程序的版本信息</li>
<li>sys.stdin 标准输入，标准输入：一般为键盘输入，stdin对象为解释器提供输入字符流，一般使用raw_input()和input()函数 </li>
<li>sys.stdout 标准输出，标准输出：一般为屏幕。stdout对象接收到print语句产生的输出 </li>
<li>sys.stderr 错误输出，错误输出：一般是错误信息，stderr对象接收出错的信息 。</li>
<li><a href="https://blog.csdn.net/qq_38526635/article/details/81739321" target="_blank" rel="noopener">更多</a></li>
</ul>
<h2 id="Time模块"><a href="#Time模块" class="headerlink" title="Time模块"></a>Time模块</h2><ul>
<li>time.time()函数获取的是Unix时间戳。 返回的是一个float类型的数值。 </li>
<li>time.struct_time () 它是一个具有命名元组接口的对象：可以通过索引和属性名访问值 </li>
<li>time.localtime() 这个函数可以接受一个unix时间戳，然后转换为struct_time。 如果不传入second参数，则会返回当前时间的时间戳的struct_time对象 </li>
<li>time.gmtime() 和localtime函数类似，默认情况gmtime函数获取当前时间的utc时间。 返回当前时间的utc时间的struct_time对象。 也可以传入任意的unix时间戳，来得到utc时间。 </li>
<li>time.mktime(struct_time)  将一个时间戳struct_time对象转换为时间戳。 </li>
<li>time.asctime() 传入一个struct_time对象，返回”Sun Jun 20 23:21:05 1993”这种格式的字符串。不传参数，返回当前时间的这种格式的字符串。 </li>
<li>time.strftime(format ,[struct_time] ) 传入格式和struct_time，返回按照format格式格式化后的时间字符串。 </li>
<li>time.sleep(<em>second</em> ) 暂停程序，接收参数为秒</li>
<li><a href="https://www.cnblogs.com/pal-duan/p/10568829.html" target="_blank" rel="noopener">更多</a></li>
</ul>
<h2 id="Datetime模块"><a href="#Datetime模块" class="headerlink" title="Datetime模块"></a>Datetime模块</h2><ul>
<li><p>datetime.date.ctime(),返回格式如 Sun Apr 16 00:00:00 2017</p>
</li>
<li><p>datetime.date.fromtimestamp(timestamp),根据给定的时间戮，返回一个date对象；datetime.date.today()作用相同</p>
</li>
<li><p>datetime.date.isocalendar():返回格式如(year，month，day)的元组,(2017, 15, 6)</p>
</li>
<li><p>datetime.date.isoformat()：返回格式如YYYY-MM-DD</p>
</li>
<li><p>datetime.date.isoweekday()：返回给定日期的星期（0-6），星期一=0，星期日=6</p>
</li>
<li><p>datetime.date.replace(year,month,day)：替换给定日期，但不改变原日期</p>
</li>
<li><p>datetime.date.strftime(format):把日期时间按照给定的format进行格式化。</p>
</li>
<li><p>datetime.date.timetuple()：返回日期对应的time.struct_time对象</p>
</li>
<li><p>datetime.datetime.now().date()：返回当前日期时间的日期部分</p>
</li>
<li><p>datetime.datetime.now().time()：返回当前日期时间的时间部分</p>
</li>
<li><p>datetime.datetime.fromtimestamp()</p>
</li>
<li><p>datetime.datetime.now()：返回当前系统时间</p>
</li>
<li><p>datetime.datetime.replace()</p>
</li>
<li><p>datetime.datetime.strftime()：由日期格式转化为字符串格式</p>
<ul>
<li>datetime.datetime.now().strftime(‘%b-%d-%Y %H:%M:%S’)</li>
</ul>
</li>
<li><p>datetime.datetime.strptime():由字符串格式转化为日期格式</p>
<ul>
<li>datetime.datetime.strptime(‘Apr-16-2017 21:01:35’, ‘%b-%d-%Y %H:%M:%S’)</li>
</ul>
</li>
<li><p>datetime.datetime.timedelta用于计算两个日期之间的差值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; b=datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">871000</span>)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">603000</span>)</span><br><span class="line">&gt;&gt;&gt; b-a</span><br><span class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">8</span>, <span class="number">732000</span>)</span><br><span class="line">&gt;&gt;&gt; (b-a).seconds</span><br><span class="line"><span class="number">8</span></span><br><span class="line">time1 = datetime.datetime(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">time2 = datetime.datetime(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">"""计算天数差值"""</span></span><br><span class="line">print(time1-time2).days</span><br><span class="line"><span class="string">"""计算两个日期之间相隔的秒数"""</span></span><br><span class="line"><span class="keyword">print</span> (time1-time2).total_seconds()</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime.time.replace() 返回一个替换指定日期字段的新date对象。参数3个可选参数，分别为year,month,day。注意替换是产生新对象，不影响原date对象。 </p>
</li>
<li><p>datetime.time.strftime(format):按照format格式返回时间</p>
</li>
<li><p>datetime.time.tzname()：返回时区名字</p>
</li>
<li><p>datetime.time.utcoffset()：返回时区的时间偏移量</p>
</li>
<li><p>datetime.date.max 表示的最大的年、月、日的数值 </p>
</li>
<li><p>datetime.date.min  表示的最小的年、月、日的数值 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎如何选择</title>
    <url>/2020/02/08/mysql%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h4 id="定义以及作用"><a href="#定义以及作用" class="headerlink" title="定义以及作用"></a>定义以及作用</h4><blockquote>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。</p>
<p>利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 </p>
<p>使用数据库引擎创建用于联机(客户端与服务端能够实时通信。由客户机发起，直到服务器确认。)事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
</blockquote>
<h4 id="Mysql的存储引擎有哪些："><a href="#Mysql的存储引擎有哪些：" class="headerlink" title="Mysql的存储引擎有哪些："></a>Mysql的存储引擎有哪些：</h4><blockquote>
<p>InnoDB</p>
<blockquote>
<p>这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O。</p>
</blockquote>
</blockquote>
<blockquote>
<p>MyISAM</p>
<blockquote>
<p>该存储引擎管理非事务性表，提供高速存储和检索，支持全文搜索。</p>
</blockquote>
</blockquote>
<blockquote>
<p>MEMORY</p>
<blockquote>
<p>提供内存中的表，以前称为堆。它在RAM中处理所有数据，以便比在磁盘上存储数据更快地访问。用于快速查找引用和其他相同的数据。</p>
</blockquote>
</blockquote>
<h4 id="修改数据库引擎"><a href="#修改数据库引擎" class="headerlink" title="修改数据库引擎"></a>修改数据库引擎</h4><blockquote>
<p>方式壹：</p>
<blockquote>
<p>修改配置文件my.ini</p>
<p>将mysql.ini另存为my.ini，在[mysqld]后面添加default-storage-engine=Innodb,重启服务，数据库默认的引擎修改为Innodb</p>
</blockquote>
</blockquote>
<blockquote>
<p>方式贰：</p>
<blockquote>
<p>在建表得时候指定</p>
<p>create table table_name(你的各个字段名)type=MyISAM;</p>
</blockquote>
</blockquote>
<blockquote>
<p>方式叁：</p>
<blockquote>
<p>建表后更改</p>
<p>alert table table_name type=Innodb;</p>
</blockquote>
</blockquote>
<h4 id="如何查看是否修改成功-查看当前数据库的引擎"><a href="#如何查看是否修改成功-查看当前数据库的引擎" class="headerlink" title="如何查看是否修改成功(查看当前数据库的引擎)"></a>如何查看是否修改成功(查看当前数据库的引擎)</h4><blockquote>
<p>方式壹：</p>
<blockquote>
<p>show table status from table_name;</p>
</blockquote>
</blockquote>
<blockquote>
<p>方拾贰：</p>
<blockquote>
<p>show create table table_name;</p>
</blockquote>
</blockquote>
<blockquote>
<p>方式叁：</p>
<blockquote>
<p>使用数据库管理工具(具体自己去问度娘)<br>注意：不同版本之间有可能命令有些不同</p>
</blockquote>
</blockquote>
<h4 id="MyISAM、InnoDB和MEMORY引擎之间的区别"><a href="#MyISAM、InnoDB和MEMORY引擎之间的区别" class="headerlink" title="MyISAM、InnoDB和MEMORY引擎之间的区别:"></a>MyISAM、InnoDB和MEMORY引擎之间的区别:</h4><blockquote>
<p>InnoDB存储引擎</p>
<blockquote>
<p>InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。</p>
<p>InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。</p>
<p>InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。</p>
<p>InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。</p>
<p>InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</p>
</blockquote>
</blockquote>
<blockquote>
<p>MyISAM存储引擎</p>
<blockquote>
<p>MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。</p>
<p>MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。</p>
<p>基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。</p>
<p>MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</p>
</blockquote>
</blockquote>
<blockquote>
<p>MEMORY存储引擎</p>
<blockquote>
<p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。</p>
<p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p>
<p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p>
<p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的</p>
</blockquote>
</blockquote>
<h4 id="怎样选择合理的存储引擎"><a href="#怎样选择合理的存储引擎" class="headerlink" title="怎样选择合理的存储引擎"></a>怎样选择合理的存储引擎</h4><blockquote>
<p>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 </p>
<p>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>
<p>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/2020/02/08/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么叫持久化？"><a href="#什么叫持久化？" class="headerlink" title="什么叫持久化？"></a>什么叫持久化？</h2><p>用一句话可以将持久化概括为：将数据（如内存中的对象）保存到可永久保存的存储设备中。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。</p>
<blockquote>
<p>从应用层与系统层理解持久化</p>
</blockquote>
<p>同时，也可以从应用层和系统层这两个层面来理解持久化：</p>
<p><strong>应用层</strong>：如果关闭( <code>Close</code> )你的应用然后重新启动则先前的数据依然存在。</p>
<p><strong>系统层</strong>：如果关闭( <code>Shutdown</code> )你的系统（电脑）然后重新启动则先前的数据依然存在。</p>
<p>说白了，就是在指定的时间间隔内,将内存当中的数据快照写入磁盘,它恢复时是拷快照文件直接读到内存</p>
<p>什么意思呢?  我们都知道, 内存当中的数据, 如果我们一断电,那么数据必然会丢失,但是玩过redis的同学应该都知道,我们一关机之后再启动的时候数据是还在的,所以它必然是在redis启动的时候重新去加载了持久化的文件</p>
<p><strong>redis提供两种方式进行持久化</strong></p>
<p>一种是RDB持久化默认,</p>
<p>另一种 AOF (append only file) 持久化.</p>
<h2 id="Redis-为什么要持久化？"><a href="#Redis-为什么要持久化？" class="headerlink" title="Redis 为什么要持久化？"></a>Redis 为什么要持久化？</h2><p>Redis 中的数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis 支持各种不同方式的排序。与 Memcached 一样，为了保证效率，数据都是缓存在内存中。</p>
<p>对，数据都是缓存在内存中的，当你重启系统或者关闭系统后，缓存在内存中的数据都会消失殆尽，再也找不回来了。所以，为了让数据能够长期保存，就要将 Redis 放在缓存中的数据做持久化存储。</p>
<h2 id="redis持久化的意义，在于故障恢复"><a href="#redis持久化的意义，在于故障恢复" class="headerlink" title="redis持久化的意义，在于故障恢复"></a>redis持久化的意义，在于故障恢复</h2><p>比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据</p>
<p>如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据</p>
<p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的</p>
<h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1.RDB"></a>1.RDB</h2><p><strong>是什么？</strong></p>
<p>原理是redis会单独创建(fork函数)（复制）一个与当前进程一模一样的子进程来进行持久化,这个子线程的所有数据(变量,环境变量,程序,程序计数器等)都和原进程一模一样,会先将数据写入到一个临时文件中,待持久化结束了,再用这个临时文件替换上次持久化好的文件,整个过程中,主进程不进行任何的IO操作,（用到了fork子进程来进行持久化）这就确保了极高的性能</p>
<p><strong>1.这个持久化文件在哪里</strong></p>
<p>vi /usr/local/redis/etc/redis.conf</p>
<p>找dbfilename dump.rdb</p>
<p>默认就是dump.rdb</p>
<p>dir ./  (包括很多例如redis实例，只要是redis产生的实例都会丢到)</p>
<p>./   =====  哪里启动，哪里生成。</p>
<p>注意：</p>
<p>要么写死目录</p>
<p>要么启动的位置就在同一个地方，地方不一样可能造成数据丢失。</p>
<p><strong>2.他是什么时候fork子进程，或者什么时候触发rdb持久化机制</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>SHUTDOWN</span><br></pre></td></tr></table></figure>

<img src="//dingyifan.tech/2020/02/08/redis持久化/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20191217092426326.png" alt="image-20191217092426326" style="zoom:50%;">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf <span class="comment">## 开启redis</span></span><br></pre></td></tr></table></figure>

<p>shutdown时,如果没有开启aof,会触发</p>
<p>配置文件中默认的快照配置</p>
<img src="//dingyifan.tech/2020/02/08/redis持久化/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20191217092743078.png" alt="image-20191217092743078" style="zoom:50%;">

<p>执行命令save成者bgsave ,</p>
<p>save是只管保存,其他不管,全部阻塞  </p>
<p>redis会在后台异步进行快照操作,</p>
<p>同时可以响应客户端的请求(默认调用bgsave来进行持久化)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rm -f ./dump.rdb</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf </span><br><span class="line"><span class="comment">## 开启redis</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli  </span><br><span class="line"><span class="comment">## 连接客户端</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set k1 v1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">save     <span class="comment">## dump.rdb  是只管保存,其他不管,全部阻塞</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bgsave   <span class="comment">## dump.rdb  redis会在后台异步进行快照操作</span></span><br></pre></td></tr></table></figure>

<p>执行flushall命令但是里面是空的,无意义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FLUSHALL   <span class="comment">## 清空</span></span><br></pre></td></tr></table></figure>

<p><strong>在redis.conf中rdb持久化策略</strong></p>
<p>集群save 900 1                ##  900秒之内执行了一次增删改操作就会触发 ， 查不算</p>
<p>save 300 10             </p>
<p>save 60    10000  </p>
<p>默认配置</p>
<p>redis 性能调优</p>
<p>集群  master节点肯定会把rdb</p>
<p>实际上关不掉的在主从复制上</p>
<p>要么就是就写一个save</p>
<p>要么就注掉</p>
<h2 id="2-aof"><a href="#2-aof" class="headerlink" title="2.aof"></a>2.aof</h2><p>执行set k1 v1 </p>
<p>保存命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set k1 v1</span><br><span class="line">set k2 v1   </span><br><span class="line"><span class="comment">## 保存到文件中  保存的是命令</span></span><br></pre></td></tr></table></figure>

<p><strong>是什么？</strong></p>
<p>原理是将Reids的操作日志以追加的方式写入文件,读操作是不记录的</p>
<p><strong>1.这个持久化文件在哪里</strong></p>
<p>产生的位置还是 ./dir </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi /usr/local/redis/etc/redis.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">appendfilename <span class="string">"appendonly.aof"</span>   <span class="comment">## 文件名</span></span><br></pre></td></tr></table></figure>

<p> redis 默认关闭，开启需要手动把no改为yes</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set k1 v1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SHUTDOWN</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf </span><br><span class="line"><span class="comment">## 开启redis</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure>

<p>‘*’  开头代表下面有两组命令</p>
<p>$  字符串的长度</p>
<p>日志追加的方式保存到文件里。</p>
<p><strong>2.触发机制（根据配置文件配置项）</strong></p>
<p>AOF_FSYNC_NO:表示等操作系统进行数据缓存同步到磁盘(快,持久化没保证) —–不能配置不可控 </p>
<p>AOF_FSYNC_ALWAYS: 同步持久化,每次发生数据变更时,立即记录到磁盘(慢,安全) —-消耗性能</p>
<p>AOF_FSYNC_EVERYSEC: 表示每秒同步一次(默认值很快,但可能会丢失一秒以内的数据)–所以默认</p>
<h2 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h2><p>在了解同步策略之前，需要先来了解两个三方法flushAppendOnlyFile、write和save：</p>
<ul>
<li>redis的服务器进程是一个事件循环，文件事件负责处理客户端的命令请求，而时间事件负责执行serverCron函数这样的定时运行的函数。在处理文件事件执行写命令，使得命令被追加到aof_buf中，然后在处理时间事件执行serverCron函数会调用flushAppendOnlyFile函数进行文件的写入和同步</li>
<li>write：根据条件，将aof_buf中的缓存写入到AOF文件</li>
<li>save：根据条件，调用fsync或fdatasync函数将AOF文件保存到磁盘</li>
</ul>
<p>下面来介绍Redis支持的三种同步策略：</p>
<ul>
<li>AOF_FSYNC_NO：不保存（write和read命令都由主进程执行）</li>
<li>AOF_FSYNC_EVERYSEC：每一秒钟保存一次（write由主进程完成，save由子进程完成）</li>
<li>AOF_FSYNC_ALWAYS：每执行一个命令保存一次（write和read命令都由主进程执行）</li>
</ul>
<p><strong>AOF_FSYNC_NO</strong><br>在这种策略下，每次flushAppendOnlyFile函数被调用的时候都会执行一次write方法，但是不会执行save方法。</p>
<p>只有下面三种情况下才会执行save方法：</p>
<ul>
<li>Redis被关闭</li>
<li>AOF功能被关闭</li>
<li>系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）</li>
</ul>
<p>这三种情况下的save操作都会引起Redis主进程阻塞，并且由于长时间没有执行save命令，所以save命令执行的时候，阻塞时间会很长</p>
<p><strong>AOF_FSYNC_EVERYSEC</strong><br>在这种策略下，save操作原则上每隔一秒钟就会执行一次， 因为save操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。</p>
<p>其实根据Redis的状态，每当 flushAppendOnlyFile函数被调用时，write命令和save命令的执行又分为四种不同情况：</p>
<p><img src="https://lebron-youdao-img.oss-cn-hangzhou.aliyuncs.com/AOF%20everysec.png" alt="AOF everysec"></p>
<p>根据以上图知道，在AOF_FSYNC_EVERYSEC策略下， 如果在情况1时发生故障停机， 那么用户最多损失小于2秒内所产生的数据；而如果在情况2时发生故障停机，堆积了很多save命令，那么用户损失的数据是可以超过 2 秒的。</p>
<p>AOF_FSYNC_ALWAYS<br>在这种模式下，每次执行完一个命令之后，write和save命令都会被执行。</p>
<p>另外，因为save命令是由Redis主进程执行的，所以在save命令执行期间，主进程会被阻塞。</p>
<p>三种策略的优缺点<br>AOF_FSYNC_NO策略虽然表面上看起来提升了性能，但是会存在每次save命令执行的时候相对长时间阻塞主进程的问题。并且数据的安全性的不到保证，如果Redis服务器突然宕机，那么没有从AOF缓存中保存到硬盘中的数据都会丢失。</p>
<p>AOF_FSYNC_ALWAYS策略的安全性的到了最大的保障，理论上最多丢失最后一次写操作，但是由于每个写操作都会阻塞主进程，所以Redis主进程的响应速度受到了很大的影响。</p>
<p>AOF_FSYNC_EVERYSEC策略是比较建议的配置，也是Redis的默认配置，相对来说兼顾安全性和性能。</p>
<h2 id="AOF执行流程"><a href="#AOF执行流程" class="headerlink" title="AOF执行流程"></a>AOF执行流程</h2><ul>
<li>所有的写命令都会追加到aof_buf（缓冲区）中。</li>
<li>可以使用不同的策略将AOF缓冲区中的命令写到AOF文件中。</li>
<li>随着AOF文件的越来越大，会对AOF文件进行重写。</li>
<li>当服务器重启的时候，会加载AOF文件并执行AOF文件中的命令用于恢复数据。</li>
</ul>
<p>简单分析一下AOF执行流程中的一些问题：</p>
<ul>
<li>因为Redis为了效率，使用单线程来响应命令，如果每次写命令都追加写硬盘的操作，那么Redis的响应速度还要取决于硬盘的IO效率，显然不现实，所以Redis将写命令先写到AOF缓冲区。</li>
<li>写道缓冲区还有一个好处是可以采用不同的策略来实现缓冲区到硬盘的同步，可以让用户自行在安全性和性能方面做出权衡。</li>
</ul>
<h2 id="3-aof重写机制"><a href="#3-aof重写机制" class="headerlink" title="3.aof重写机制"></a>3.aof重写机制</h2><p>我们以日志的方式,记录我们的命令记录到文件当中</p>
<p>如果我操作的特别频繁，文件肯定会特别大。</p>
<p>我写100万数据，持久化文件也会特别大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FLUSHALL  <span class="comment">## 清空数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys *   <span class="comment">## 查看是否有数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INCR lock   <span class="comment">## 加操作</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exit    <span class="comment">## 退出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi appendonly.aof  <span class="comment">## 查看文件</span></span><br></pre></td></tr></table></figure>

<p>记录着</p>
<p>我可以直接执行一条命令set lock 11</p>
<p>重写就是将重复的剔除掉瘦身</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BGREWRITEAOF  <span class="comment">##手动调用重写命令</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exit  <span class="comment">## 退出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi dump.rdb</span><br></pre></td></tr></table></figure>

<p>是因为我这个版本是5.0的</p>
<p>当AOF文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当AOF文件大小的增长率大于该配置项时自动开启重写(这里指超过原大小的100%) .</p>
<p>auto-aof-rewrite-percentage 100</p>
<p>当AOF文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写,当AOF文件大小大于该配置项时自动开启重写</p>
<p>auto-aof-rewrite-min-size 64mb</p>
<p>incr lock </p>
<p>重写就是将重复的剔除掉瘦身</p>
<h2 id="4-redis4-0后混合持久化机制"><a href="#4-redis4-0后混合持久化机制" class="headerlink" title="4.redis4.0后混合持久化机制"></a>4.redis4.0后混合持久化机制</h2><p><strong>开启混合持久化</strong></p>
<p>4.0 版本是 像set lock 11</p>
<p>4.0版本的混合持久化默认关闭的,通过aof-use-rdb-preamble配置参数控制, yes则表示开启, no表示禁用, 5.0之后默认开启。</p>
<p>混合持久化是通过bgrewriteaof完成的,不同的是当开启混合持久化时, fork出的子进程先将共享的内存副本全量 以RDB方式写入aof文件,然后在将重写缓冲区的增量命令以AOF方式写入到文件,写入完成后通知主进程更新统计信息,并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。</p>
<p>简单的说:新的AOF文件前半段是 RDB格式的全量数据后半段是AOF格式的增量数据,</p>
<p>优点:混合持久化结合了RDB持久化和AOF持久化的优点由于绝大部分都是RDB格式,加载速度快,同时结合 AOF,增量的数据以AOF方式保存了,数据更少的丢失.</p>
<p>缺点:兼容性差,一旦开启了混合持久化,在4.0之前版本都不识别该aof文件,同时由于前部分是RDB格式,阅读性较差</p>
<p>二进制方式存储  更小</p>
<p>什么时候下会自动重写</p>
<p>看</p>
<p>auto-aof-rewrite-percentage</p>
<p>auto-aof-rewrite-min-size</p>
<h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><p><strong>1.redis提供了rdb持久化方案，为什么还要aof？</strong></p>
<p>rdb 是跟据save触发持久化，所以会照成数据的丢失</p>
<p>aof持久化是1秒执行一次</p>
<p>在数据aof</p>
<p>在性能rdb高于aof</p>
<blockquote>
<p>优化数据丢失问题，rdb会丢失最后一次快照后的数据，aof丢失不会超过2秒的数据</p>
</blockquote>
<p><strong>2.如果aof和rdb同时存在，听谁的？</strong></p>
<p>aof数据准确率更高</p>
<p><strong>3.rdb和aof优势劣势</strong></p>
<p>rdb适合大规模的数据恢复,对数据完整性和一致性不高，在一定间隔时间做一次备份,如果redis意外宕机的话,就会丢失最后一次快照后的所有操作</p>
<p>aof根据配置项而定</p>
<p>1.官方建议两种持久化机制同时开启,如果两个同时开启优先使用aof久化机制</p>
<p>在生产环境中用集群，哨兵什么的</p>
<p>主机开aof</p>
<p><strong>性能建议（这里只针对单机版redis持久化做性能建议）：</strong></p>
<p>因为RDB文件只用作后备用途,只要15分钟备份一次就够了,只保留save 900 1这条规则. 因为开启aof持久化安全。</p>
<p>如果Enalbe AOF, 好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了.</p>
<p>代价一是带来了持续的IO,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p>
<p>只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上.默认超过原大小100%大小时重写可以改到适当的数值。</p>
<p>看硬盘</p>
<img src="//dingyifan.tech/2020/02/08/redis持久化/Users\Lenovo\Desktop\20191127113644133169.png" alt="20191127113644133169" style="zoom: 50%;">



<p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p>
<p>2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p>
<p>3）加载AOF/RDB文件成功后，Redis启动成功。</p>
<p>4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</p>
<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=762237719,3005011713&fm=15&gp=0.jpg" alt="img"></p>
<p>1.从主进程中fork出子进程，并拿到fork时的AOF文件数据写到一个临时AOF文件中</p>
<p>2.在重写过程中，redis收到的命令会同时写到AOF缓冲区和重写缓冲区中，这样保证重写不丢失，重写过程中的命令</p>
<p>3.重写完成后通知主进程，主进程会将AOF缓冲区中的数据追加到子进程生成的文件中</p>
<p>4.redis会原子的将旧文件替换为新文件，并开始将数据写入到新的aof文件上</p>
<ul>
<li>执行bgrewriteaof命令的时候，如果当前有进程正在执行AOF重写，那么直接返回；如果有进程正在执行bgsave，那么等待bgsave执行完毕再执行AOF重</li>
<li>Redis主进程会fork一个子进程执行AOF重写。</li>
<li>AOF重写过程中，不影响Redis原有的AOF过程，包括写消息到AOF缓存以及同步AOF缓存中的数据到硬盘。</li>
<li>AOF重写过程中，主进程收到的写操作还会将命令写到AOF重写缓冲区，注意和AOF缓冲区分开。</li>
<li>由于AOF重写过程中原AOF文件还在陆续写入数据，所以AOF重写子进程只会拿到fork子进程时的AOF文件进行重写。</li>
<li>子进程拿到原AOF文件中的数据写道一个临时的AOF文件中。</li>
<li>子进程完成AOF重写后会发消息给主进程，主进程会把AOF重写缓冲区中的数据写道AOF缓冲区，并且用新的AOF文件替换旧的AOF文件。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</li>
<li>RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</li>
<li>Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。</li>
<li>AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。</li>
<li>Redis 针对 AOF文件大的问题，提供重写的瘦身机制。</li>
<li>若只打算用Redis 做缓存，可以关闭持久化。</li>
<li>若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。</li>
</ol>
<h4 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h4><hr>
<p>RDB的优缺点：</p>
<ul>
<li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数 据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li>
<li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li>
<li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li>
<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>
</ul>
<p>AOF的优缺点：</p>
<ul>
<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。</li>
<li>AOF 日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损。 如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据 一致性的问题。</li>
<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。 因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF以一个格式清晰、易于理解的日志文件用于记录所有的修改操作， 非常适合做灾难性的误删除的紧急恢复。 比如有人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条flushall命令给删了，然后再将该aof文件放回去，就可以通过恢复机制，自动恢复所有数据。</li>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低， 因为 AOF 一般会配置成每秒 fsync 一次日志文件。</li>
<li>类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。</li>
</ul>
<h4 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h4><hr>
<p>RDB和AOF如何选择？</p>
<ul>
<li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li>
<li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li>
<li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>多级redis主从复制</title>
    <url>/2020/02/08/%E5%A4%9A%E7%BA%A7redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Reids主从"><a href="#Reids主从" class="headerlink" title="Reids主从"></a>Reids主从</h2><p><strong>参考链接：</strong></p>
<p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考1</a></p>
<p><a href="https://www.cnblogs.com/chenhuabin/p/10048854.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考2</a></p>
<p><a href="https://www.cnblogs.com/lxx666/articles/10693844.html" target="_blank" rel="noopener">Redis主从架构和主从从架构集群搭建详细步骤</a></p>
<p><a href="https://www.cnblogs.com/wade-luffy/p/9639986.html" target="_blank" rel="noopener">Redis主从复制原理</a></p>
<p><a href="http://doc.redisfans.com/topic/replication.html" target="_blank" rel="noopener">Redis复制官方文档翻译</a></p>
<blockquote>
<p>​    主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>​    默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
</blockquote>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol>
<li><strong>数据冗余：</strong>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li><strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li><strong>高可用基石：</strong>主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<h3 id="主从拓扑结构"><a href="#主从拓扑结构" class="headerlink" title="主从拓扑结构"></a>主从拓扑结构</h3><p>​    <strong>一主一从：</strong></p>
<p><img src="//dingyifan.tech/2020/02/08/多级redis主从复制/C:%5CUsers%5Casus%5CDesktop%5C1539768-20181201112713274-1680086476.png" alt="1539768-20181201112713274-1680086476"></p>
<p>　　这一结构主要用于主节点故障从节点，当主节点的“写”命令并发高且需要持久化，可以只在从节点开启AOF（主节点不需要），这样即保证了数据的安全性，也避免持久化对主节点的影响。<br>　　<br>​    <strong>一主多从：</strong></p>
<p><img src="//dingyifan.tech/2020/02/08/多级redis主从复制/C:%5CUsers%5Casus%5CDesktop%5C1539768-20181201112740108-1961344396.png" alt="1539768-20181201112740108-1961344396"></p>
<p>　　这一结构主要针对“读”较多的场景，“读”由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定。<br>　　<br>​    <strong>树状主从:</strong></p>
<p><img src="//dingyifan.tech/2020/02/08/多级redis主从复制/C:%5CUsers%5Casus%5CDesktop%5C1539768-20181201112824130-1051891659.png" alt="1539768-20181201112824130-1051891659"></p>
<p>　　这一结构是对一主多从的补充，主节点只推送一次数据到slave1和slave2，再由从slave2推送到slave3和 slave4，减轻主节点推送的压力。</p>
<h2 id="主从复制的实现原理"><a href="#主从复制的实现原理" class="headerlink" title="主从复制的实现原理"></a>主从复制的实现原理</h2><p>主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong>；</p>
<h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><h4 id="step1：保存主节点信息"><a href="#step1：保存主节点信息" class="headerlink" title="step1：保存主节点信息"></a>step1：保存主节点信息</h4><p>​    从节点服务器内部维护了两个字段，即<strong>masterhost</strong>和<strong>masterport</strong>字段，用于存储主节点的<strong>ip</strong>和<strong>port</strong>信息。</p>
<p>​    <strong>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</strong></p>
<h4 id="step2：建立socket连接"><a href="#step2：建立socket连接" class="headerlink" title="step2：建立socket连接"></a>step2：建立socket连接</h4><p>​    <strong>从节点每秒1次调用复制定时函数replicationCron()</strong>，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p>
<p><strong>如果连接成功：</strong></p>
<p>​    <strong>从节点：</strong>为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p>
<p>​    <strong>主节点：</strong>接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p>
<h4 id="step3：发送ping命令"><a href="#step3：发送ping命令" class="headerlink" title="step3：发送ping命令"></a>step3：发送ping命令</h4><p>​    从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</strong></p>
<p><strong>从节点发送ping命令后，可能出现3种情况：</strong></p>
<ol>
<li>返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</li>
<li>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</li>
<li>返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</li>
</ol>
<h4 id="step4：身份验证"><a href="#step4：身份验证" class="headerlink" title="step4：身份验证"></a>step4：身份验证</h4><p>如果从节点中设置了<strong>masterauth</strong>选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。</p>
<p>从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p>
<p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p>
<h4 id="step5：发送从节点端口信息"><a href="#step5：发送从节点端口信息" class="headerlink" title="step5：发送从节点端口信息"></a>step5：发送从节点端口信息</h4><p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；<strong>该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</strong></p>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p>
<p>具体执行的方式是：从节点向主节点发送<strong>psync命令</strong>，开始同步。</p>
<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p>
<blockquote>
<p>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
</blockquote>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>​    数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>​    在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p>
<p><strong>PS：</strong></p>
<p>​    <strong>延迟与不一致：</strong>命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p>
<p>​    <strong>repl-disable-tcp-nodelay no：</strong>该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<h3 id="【数据同步阶段】全量复制和部分复制"><a href="#【数据同步阶段】全量复制和部分复制" class="headerlink" title="【数据同步阶段】全量复制和部分复制"></a>【数据同步阶段】全量复制和部分复制</h3><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；</p>
<p>在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p>
<ol>
<li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li>
<li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li>
</ol>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><strong>Redis通过psync命令进行全量复制的过程如下：</strong></p>
<ol>
<li>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</li>
<li>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li>
<li>主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</li>
<li>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li>
<li>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</li>
</ol>
<p><strong>通过全量复制的过程可以看出，全量复制是非常重型的操作：</strong></p>
<ol>
<li>主节点通过<strong>bgsave</strong>命令<strong>fork</strong>子进程进行<strong>RDB</strong>持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</li>
<li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗。</li>
<li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</li>
</ol>
<h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>​    由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p>
<p>​    部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID</p>
<h5 id="offset-复制偏移量"><a href="#offset-复制偏移量" class="headerlink" title="offset 复制偏移量"></a>offset 复制偏移量</h5><p>​        在主从复制的Master(主节点)和Slave(从节点)双方都会各自维持一个offset，代表的是<strong>主节点向从节点传递的字节数</strong>；Master成功发送N个字节的命令后会将Master的offset加上N，Slave在接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。</p>
<p>​        offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>  复制积压缓冲区是由<strong>Master(主节点)维护的一个固定长度的FIFO队列(先进先出)</strong>，默认大小1MB；当主节点开始有从节点时创建，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slave，还会将命令写入到复制积压缓冲区里面。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>​        除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>
<p>​        由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p><strong>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</strong></p>
<ul>
<li><strong>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</strong></li>
<li><strong>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</strong></li>
</ul>
<h5 id="runid-服务器运行ID"><a href="#runid-服务器运行ID" class="headerlink" title="runid 服务器运行ID"></a>runid 服务器运行ID</h5><p>​        每个Redis服务器(无论主从)在启动时都会自动生成一个表明自己身份的随机ID(每次启动都不一样)，由40个随机的十六进制字符组成。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC命令会使用<strong>”PSYNC ? -1”</strong> 这种形式发送给Master，表示需要全量复制。</p>
<p>​        每个Redis节点，在启动时都会自动生成一个随机ID，由40个随机的十六进制字符组成；</p>
<p>runid用来唯一识别一个Redis节点。<strong>通过info Server命令，可以查看节点的runid。</strong></p>
<p>​        主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；</p>
<p><strong>主节点根据runid判断能否进行部分复制：</strong></p>
<ul>
<li><p>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p>
</li>
<li><p>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p>
</li>
</ul>
<h3 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h3><p>  Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。</p>
<h4 id="PSYNC命令格式"><a href="#PSYNC命令格式" class="headerlink" title="PSYNC命令格式"></a>PSYNC命令格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PSYNC &lt;runid&gt; &lt;offset&gt;</span><br><span class="line"><span class="meta">#</span> runid:主服务器ID</span><br><span class="line"><span class="meta">#</span> offset:从服务器最后接收命令的偏移量</span><br></pre></td></tr></table></figure>

<p>  <strong>PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。</strong></p>
<h4 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h4><p><img src="//dingyifan.tech/2020/02/08/多级redis主从复制/C:%5CUsers%5Casus%5CDesktop%5C990532-20180913134017449-1623896661.png" alt="990532-20180913134017449-1623896661"></p>
<ol>
<li><p>首先从节点根据当前状态，决定如何调用psync命令：</p>
<ul>
<li>如果从节点之前未执行过<strong>slaveof</strong>或最近执行了<strong>slaveof no one</strong>，则从节点发送命令为<strong>psync ? -1</strong>，向主节点请求全量复制；</li>
<li>如果从节点之前执行了<strong>slaveof</strong>，则发送命令为 <strong>psync <runid> <offset> **，其中</offset></runid></strong>runid<strong>为上次复制的主节点的</strong>runid<strong>，</strong>offset**为上次复制截止时从节点保存的复制偏移量。</li>
</ul>
</li>
<li><p>主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p>
<ul>
<li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li>
<li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li>
<li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复<strong>+FULLRESYNC <runid> <offset></offset></runid></strong>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li>
</ul>
</li>
</ol>
<h3 id="【命令传播阶段】心跳机制"><a href="#【命令传播阶段】心跳机制" class="headerlink" title="【命令传播阶段】心跳机制"></a>【命令传播阶段】心跳机制</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
<h4 id="主-gt-从：PING"><a href="#主-gt-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h4><p>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。</p>
<h4 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h4><p>在命令传播阶段，<strong>从节点会向主节点发送REPLCONF ACK命令，</strong>频率是每秒1次；</p>
<p><strong>命令格式为：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK &#123;offset&#125;	# offset指从节点保存的复制偏移量。</span><br></pre></td></tr></table></figure>

<p><strong>REPLCONF ACK命令的作用包括：</strong></p>
<ol>
<li><strong>实时监测主从节点网络状态：</strong>该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</li>
<li><strong>检测命令丢失：</strong>从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。</li>
</ol>
<ul>
<li><strong>注意：offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></li>
</ul>
<ol start="3">
<li><strong>辅助保证从节点的数量和延迟：</strong>Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li>
</ol>
<p>　　</p>
<h2 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h2><p>从节点开启主从复制，有3种方式：</p>
<ul>
<li>配置文件：在从服务器的配置文件中加入：<strong>slaveof <masterip> <masterport></masterport></masterip></strong></li>
<li>启动命令：redis-server启动命令后加入： <strong>–slaveof <masterip> <masterport></masterport></masterip></strong></li>
<li>客户端命令：Redis服务器启动后，直接通过客户端执行命令：<strong>slaveof <masterip> <masterport></masterport></masterip></strong>，则该Redis实例成为从节点。</li>
</ul>
<h3 id="修改配置文件方法："><a href="#修改配置文件方法：" class="headerlink" title="修改配置文件方法："></a>修改配置文件方法：</h3><h4 id="1-配置从服务配置文件redis-conf"><a href="#1-配置从服务配置文件redis-conf" class="headerlink" title="1. 配置从服务配置文件redis.conf"></a>1. 配置从服务配置文件redis.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.1.9 6379    #添加属于某台主机的从 服务</span><br><span class="line">masterauth 123456       #从服务连接主服的密码（访问主服务器的密码）</span><br><span class="line">slave-read-only yes     #从服务只读，不可在命令行写入数据</span><br><span class="line"></span><br><span class="line">5.0.4以后：</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure>

<h4 id="2-重新启动从服务即实现主从连接"><a href="#2-重新启动从服务即实现主从连接" class="headerlink" title="2. 重新启动从服务即实现主从连接"></a>2. 重新启动从服务即实现主从连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ./bin/redis-cli	# 启动redis客户端</span><br><span class="line">2. 输入 info replication # 查看与复制相关的状态，了解主从节点的当前状态</span><br></pre></td></tr></table></figure>

<p><strong>输入info replication 后显示的内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Replication</span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure>

<h4 id="遇到的报错："><a href="#遇到的报错：" class="headerlink" title="遇到的报错："></a>遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：</p>
<p>  ​    redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip: bind 39.107.38.62</span><br><span class="line">3. bind 0.0.0.0</span><br><span class="line">2. 注释bind  # 会报下面的错↓</span><br></pre></td></tr></table></figure>

<h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：</p>
<p>   ​    处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure>

<h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：</p>
<p>​        从库只可读不可写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure>

<h2 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h2><p>​    通过<strong>slaveof <masterip> <masterport></masterport></masterip></strong>命令建立主从复制关系以后，可以通过slaveof no one断开。</p>
<p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis哨兵</title>
    <url>/2020/02/08/redis%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<p>redis哨兵集群：</p>
<p>Redis单机服务最怕的是宕机了，一旦宕机，可能会导致系统不可用或导致其他一系列的问题。后来出现了redis集群，但是redis集群没有实现自动发现故障和对主从机器进行切换。</p>
<p>​          Redis Sentinel 是官方推荐的高可用性解决方案。它不会因为节点宕机而导致服务不可用，同时，它可以作为监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务等，即使出现了故障，也能很快知道，并进行修复。</p>
<p>Sentinel哨兵：</p>
<ul>
<li>监控，监控每个节点以及哨兵运行状态</li>
<li>报警，当发现某个节点或哨兵出现问题，通知其他哨兵</li>
<li>自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点</li>
<li>配置中心，客户端初始化连接的是哨兵节点集合</li>
</ul>
<p>开始搭建：</p>
<p>mkdir redis-sentinel文件夹</p>
<p>cd到redis-sentinel文件夹，然后在建立一个sentinel来存放哨兵脚本，然后cd sentinel。</p>
<p>建立sentinel.conf配置文件：</p>
<p>sentinel monitor mymaster redis-master 6379 2</p>
<p>sentinel down-after-milliseconds mymaster 5000</p>
<p>sentinel parallel-syncs mymaster 1</p>
<p>sentinel failover-timeout mymaster 5000</p>
<p> 该配置的意思是，监控主服务器的6379端口并且起两个实例，如果哨兵5s内没有收到主节点的心跳，哨兵就认为主节点宕机了，默认是30秒，如果5秒以上连接不上主库同步，则在5秒后进行选举，对其他的从服务器进行角色转换</p>
<p>随后建立sentinel_auto.sh脚本文件：</p>
<p>#!/bin/sh</p>
<p>sed -i “s/$SENTINEL_QUORUM/$SENTINEL_QUORUM/g” /etc/redis/sentinel.conf</p>
<p>sed -i “s/$SENTINEL_DOWN_AFTER/$SENTINEL_DOWN_AFTER/g” /etc/redis/sentinel.conf</p>
<p>sed -i “s/$SENTINEL_FAILOVER/$SENTINEL_FAILOVER/g” /etc/redis/sentinel.conf</p>
<p>exec docker-entrypoint.sh redis-server /etc/redis/sentinel.conf –sentinel</p>
<p>该脚本文件会对配置文件进行同步，用来启动哨兵。</p>
<p>然后来建立Dockerfile指定基础镜像，同时拷贝配置到镜像内部：</p>
<p>FROM redis</p>
<p>EXPOSE 26379</p>
<p>ADD sentinel.conf /etc/redis/sentinel.conf</p>
<p>RUN chown redis:redis /etc/redis/sentinel.conf</p>
<p>COPY sentinel_auto.sh /usr/local/bin/</p>
<p>RUN chmod +x /usr/local/bin/sentinel_auto.sh</p>
<p>ENTRYPOINT [“sentinel_auto.sh”]</p>
<p>跟着退回到项目根目录cd..</p>
<p>建立docker-compose.yml配置文件：</p>
<p>master:</p>
<p>  image: redis</p>
<p>  ports:</p>
<p>​    - “6379:6379”</p>
<p>slave1:</p>
<p>  image: redis</p>
<p>  command: redis-server –slaveof redis-master 6379</p>
<p>  links:</p>
<p>​    - master:redis-master</p>
<p>  ports:</p>
<p>​    - “6380:6379”</p>
<p>slave2:</p>
<p>  image: redis</p>
<p>  command: redis-server –slaveof redis-master 6379</p>
<p>  links:</p>
<p>​    - master:redis-master</p>
<p>  ports:</p>
<p>​    - “6381:6379”</p>
<p>sentinel1:</p>
<p>  build: sentinel</p>
<p>  environment:</p>
<p>​    - SENTINEL_DOWN_AFTER=5000</p>
<p>​    - SENTINEL_FAILOVER=5000    </p>
<p>  links:</p>
<p>​    - master:redis-master</p>
<p>​    - slave1</p>
<p>sentinel2:</p>
<p>  build: sentinel</p>
<p>  environment:</p>
<p>​    - SENTINEL_DOWN_AFTER=5000</p>
<p>​    - SENTINEL_FAILOVER=5000    </p>
<p>  links:</p>
<p>​    - master:redis-master</p>
<p>​    - slave2</p>
<p>这里配置的意思是启动三台redis服务，分别跑在6379，6380，6381，一主两从，并且有两个哨兵来监控他们，创建完成后的目录结构是：</p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p>
<p>在项目根目录下，启动服务：</p>
<p>docker-compose up –force-recreate -d</p>
<p>-d是后台操作</p>
<p>然后我们测试一下是否成功，分别开三个redis-cli：</p>
<p>redis-cli -p 6379  redis-cli -p 6380  redis-cli -p 6381</p>
<p>在主库set a 123 然后分别在从库get a</p>
<p>可以看到这是主库的信息，可以看到他现在的角色是master：</p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="img"></p>
<p>这是其他两个从库get a 也拿到了数据，可以看到从库的角色现在是slave：</p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg" alt="img"></p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg" alt="img"></p>
<p>到这里说明我们的主从复制是没问题的，现在我们来测试一下哨兵模式是否管用，如果主库由于某种原因宕机了从库是否会自动切换角色。</p>
<p>我们可以手动停止主库容器进程，来模拟宕机的情况：</p>
<p>docker stop redis-sentinel_master_1</p>
<p>可以看到主库现在已经连不上了：</p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image009.jpg" alt="img"></p>
<p>我们进入从库使用<strong>info replication 命令查看角色：</strong></p>
<p><img src="file:///C:/Users/60952/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg" alt="img"></p>
<p>进入从库发现6380之前的角色是slave，现在已经是master了</p>
<p>注意事项：</p>
<p>用docker启动redis时，要把此时redis的进程杀死</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务和隔离级别</title>
    <url>/2020/02/08/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-1-2、事务的特性"><a href="#1-1-2、事务的特性" class="headerlink" title="1.1.2、事务的特性"></a>1.1.2、事务的特性</h3><ol>
<li><p>原子性</p>
<blockquote>
<p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全都不完成</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致</p>
</blockquote>
</li>
<li><p>隔离性</p>
<blockquote>
<p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的</p>
</blockquote>
</li>
<li><p>持久性</p>
<blockquote>
<p>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</p>
</blockquote>
</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-59ea2f0769e4e9ffbcdce938d306fae9_hd.png" alt="img"> </p>
<h3 id="1-1-3、事务隔离级别"><a href="#1-1-3、事务隔离级别" class="headerlink" title="1.1.3、事务隔离级别"></a>1.1.3、事务隔离级别</h3><ol>
<li><strong>未提交读：脏读（READ UNCOMMITTED）</strong><ol>
<li>事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据</li>
<li>所以事务2查询的数据是不正确的，因此出现了脏读的问题</li>
</ol>
</li>
</ol>
<h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><p> 该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为<strong>脏读</strong>。 </p>
<p> 两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将A的隔离级别设置为read uncommitted(未提交读)</span><br><span class="line">A：SET @@session.transaction_isolation = &apos;READ-UNCOMMITTED&apos;;</span><br><span class="line">创建一张test</span><br><span class="line">create database test;</span><br><span class="line"></span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line">create table test(id int primary key);</span><br><span class="line"></span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line">start transaction;</span><br><span class="line">update test set id = 2 where id = 1;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B:回滚事务</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">A:再次读数据，发现数据变回初始状态</span><br><span class="line">select * from test;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>提交读：不可重复读（READ COMMITTED）</strong></p>
<p>注：一个事务从开始到提交之前对数据所做的改变对其他事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。</p>
<ol>
<li>事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的</li>
<li>但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变</li>
<li>导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题</li>
</ol>
</li>
</ol>
<h3 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h3><p> 一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:将客户端A的事务隔离级别设置为read committed(已提交读)</span><br><span class="line"></span><br><span class="line">SET @@session.transaction_isolation = &apos;READ-COMMITTED&apos;;</span><br><span class="line">创建test表</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key);</span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line">start transaction;</span><br><span class="line">update test set id = 2 where id = 1;</span><br><span class="line"></span><br><span class="line">A：再次读数据，发现数据未被修改</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B：提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</span><br><span class="line">select * from test;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>可重复读：幻读（REPEATABLE READ）：这是MySQL的默认事务隔离级别</strong><ol>
<li>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其他事务执行DELETE或UPDATE操作（既该行上有排他锁）</li>
<li>这时该事务的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）</li>
<li>这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。</li>
<li>虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。</li>
<li>一个事务在执行过程中，另一个事务对已有数据行的更改，MVCC机制可保障该事务读取到的原有数据行的内容相同</li>
<li>但并不能阻止另一个事务插入新的数据行，这就会导致该事务中凭空多出数据行，像出现了幻读一样，这便是幻读问题</li>
</ol>
</li>
</ol>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><p> 该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，<code>select</code> 的结果是事务开始时时间点的状态，因此，同样的 <code>select</code> 操作读到的结果会是一致的，但是，会有<strong>幻读</strong>现象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将A的隔离级别设置为repeatable read(可重复读)</span><br><span class="line">SET @@session.transaction_isolation = &apos;REPEATABLE-READ&apos;;</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key,name varchar(20));</span><br><span class="line"></span><br><span class="line">A：登录 mysql 终端 A，开启一个事务。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; -- 无记录</span><br><span class="line"></span><br><span class="line">B：登录 mysql 终端 B，开启一个事务。</span><br><span class="line">use test;</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; -- 无记录</span><br><span class="line"></span><br><span class="line">A:切换到 mysql 终端 A，增加一条记录并提交。</span><br><span class="line">insert into test(id,name) values(1,&apos;a&apos;);</span><br><span class="line">commit;</span><br><span class="line">select * from test; --可以看到已经更改</span><br><span class="line"></span><br><span class="line">B:切换到 msyql 终端 B。</span><br><span class="line">select * from test; --此时查询还是无记录</span><br><span class="line"></span><br><span class="line">通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。</span><br><span class="line"> 可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。 </span><br><span class="line"></span><br><span class="line">B：此时接着在 mysql 终端 B 插入一条数据。</span><br><span class="line">insert into test(id,name) values(1,&apos;b&apos;); -- 此时报主键冲突的错误</span><br><span class="line">这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>可串行读（SERIALIZABLE）</strong><ol>
<li>这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就像在每个读的数据行加上共享锁来实现</li>
<li>在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用</li>
</ol>
</li>
</ol>
<h3 id="SERIALIZABLE（可串行读）"><a href="#SERIALIZABLE（可串行读）" class="headerlink" title="SERIALIZABLE（可串行读）"></a>SERIALIZABLE（可串行读）</h3><p> 在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:准备两个终端，在此命名为 mysql 终端 A 和 mysql 终端 B，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</span><br><span class="line">set session transaction isolation level serializable;</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key);</span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A:登录 mysql 终端 A，开启一个事务，并写入一条数据。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B:登录 mysql 终端 B，开启一个事务。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; </span><br><span class="line"> delete from test;</span><br><span class="line"></span><br><span class="line">A:立马切换到 mysql 终端 A,提交事务。</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">一旦事务提交，msyql 终端 B 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从不一致</title>
    <url>/2020/02/08/mysql%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h2 id="pt-table-checksum（检查主从的一致性）"><a href="#pt-table-checksum（检查主从的一致性）" class="headerlink" title="pt-table-checksum（检查主从的一致性）"></a>pt-table-checksum（检查主从的一致性）</h2><table>
<thead>
<tr>
<th>工具命令</th>
<th>工具作用</th>
<th>备注</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>pt-duplicate-key-checker</td>
<td>列出并删除重复的索引和外键</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-online-schema-change</td>
<td>在线修改表结构</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-query-advisor</td>
<td>分析查询语句，并给出建议，有bug</td>
<td>已废弃</td>
<td></td>
</tr>
<tr>
<td>pt-show-grants</td>
<td>规范化和打印权限</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-upgrade</td>
<td>在多个服务器上执行查询，并比较不同</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-index-usage</td>
<td>分析日志中索引使用情况，并出报告</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-pmp</td>
<td>为查询结果跟踪，并汇总跟踪结果</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-visual-explain</td>
<td>格式化执行计划</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-table-usage</td>
<td>分析日志中查询并分析表使用情况</td>
<td>pt 2.2新增命令</td>
<td></td>
</tr>
<tr>
<td>pt-config-diff</td>
<td>比较配置文件和参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-mysql-summary</td>
<td>对mysql配置和status进行汇总</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-variable-advisor</td>
<td>分析参数，并提出建议</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-deadlock-logger</td>
<td>提取和记录mysql死锁信息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-fk-error-logger</td>
<td>提取和记录外键信息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-mext</td>
<td>并行查看status样本信息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-query-digest</td>
<td>分析查询日志，并产生报告</td>
<td>常用命令</td>
<td></td>
</tr>
<tr>
<td>pt-trend</td>
<td>按照时间段读取slow日志信息</td>
<td>已废弃</td>
<td></td>
</tr>
<tr>
<td>pt-heartbeat</td>
<td>监控mysql复制延迟</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-slave-delay</td>
<td>设定从落后主的时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-slave-find</td>
<td>查找和打印所有mysql复制层级关系</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-slave-restart</td>
<td>监控salve错误，并尝试重启salve</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-table-checksum</td>
<td>校验主从复制一致性</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-table-sync</td>
<td>高效同步表数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-diskstats</td>
<td>查看系统磁盘状态</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-fifo-split</td>
<td>模拟切割文件并输出</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-summary</td>
<td>收集和显示系统概况</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-stalk</td>
<td>出现问题时，收集诊断数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-sift</td>
<td>浏览由pt-stalk创建的文件</td>
<td>pt 2.2新增命令</td>
<td></td>
</tr>
<tr>
<td>pt-ioprofile</td>
<td>查询进程IO并打印一个IO活动表</td>
<td>pt 2.2新增命令</td>
<td></td>
</tr>
<tr>
<td>pt-archiver</td>
<td>将表数据归档到另一个表或文件中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-find</td>
<td>查找表并执行命令</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pt-kill</td>
<td>Kill掉符合条件的sql</td>
<td>常用命令</td>
<td></td>
</tr>
<tr>
<td>pt-align</td>
<td>对齐其他工具的输出</td>
<td>pt 2.2新增命令</td>
<td></td>
</tr>
<tr>
<td>pt-fingerprint</td>
<td>将查询转成密文</td>
<td>pt 2.2新增命令</td>
<td></td>
</tr>
</tbody></table>
<p><strong>环境</strong></p>
<p>master主机（47.97.218.145）              slave主机（39.106.84.122）</p>
<p>​    3306端口，                                                    3306端口</p>
<p>binlog_format = ROW</p>
<p>（mysql复制主要有三种方式：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。对应的，binlog的格式也有三种：STATEMENT，ROW，MIXED。</p>
<p><strong>① STATEMENT模式（SBR）</strong></p>
<p>每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</p>
<p><strong>② ROW模式（RBR）</strong></p>
<p>不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。</p>
<p><strong>③ MIXED模式（MBR）</strong></p>
<p>以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。）</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>为了减少不必要的麻烦，确保你的 ptuser@’xxx’ 用户能同时登陆主库和从库；</p>
</li>
<li><p>只能指定一个host，必须为主库的IP；</p>
</li>
<li><p>在检查时会向表加S锁；</p>
</li>
<li><p>如果master和slave的binlog日志不是STATEMENT格式，要用–no-check-binlog-format选项</p>
</li>
<li><p>运行之前需要从库的同步IO和SQL进程是YES状态。</p>
</li>
<li><p>表要有主键索引或唯一键索引</p>
</li>
</ul>
<h3 id="工具安装："><a href="#工具安装：" class="headerlink" title="工具安装："></a><strong>工具安装：</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line"></span><br><span class="line">         依赖包：yum install perl perl-devel perl-Time-HiRes perl-DBI perl-DBD-MySQL</span><br><span class="line">	     yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker perl-Digest-MD5</span><br><span class="line"></span><br><span class="line">         工具包：percona-toolkit</span><br><span class="line"></span><br><span class="line">         wget http://www.percona.com/get/percona-toolkit.tar.gz</span><br><span class="line">		</span><br><span class="line">		tar zxvf percona-toolkit-2.2.13.tar.gz</span><br><span class="line">		cd percona-toolkit-2.2.13</span><br><span class="line">		perl Makefile.PL</span><br><span class="line">		make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a><strong>使用方法：</strong></h3><p>pt-table-checksum [OPTIONS] [DSN]</p>
<p><code>pt-table-checksum</code>：在主（master）上通过执行校验的查询对复制的一致性进行检查，对比主从的校验值，从而产生结</p>
<h4 id="分别在主库和从库授权："><a href="#分别在主库和从库授权：" class="headerlink" title="分别在主库和从库授权："></a>分别在主库和从库授权：</h4><p>​    <strong>在主库执行授权（一定要对主库  <em>ip</em>   授权，授权的用户名和密码可以自行定义，不过要保证这个权限能同时登陆主库和从库）</strong></p>
<figure class="highlight plain"><figcaption><span>GRANT SELECT, PROCESS, SUPER, REPLICATION SLAVE,CREATE,DELETE,INSERT,UPDATE ON *.* TO 'root'@'47.97.218.145' identified by '123456';```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>​    <strong>在从库上执行授权</strong></p>
<figure class="highlight plain"><figcaption><span>GRANT SELECT, PROCESS, SUPER, REPLICATION SLAVE ON *.* TO 'root'@'39.106.84.122' IDENTIFIED BY '123456';```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p><strong>创集表</strong>（注意：第一次运行的时候需要加上–create-replicate-table参数，生成checksums表！）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create databse pt charset=utf8;</span><br><span class="line"></span><br><span class="line">use pt;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS checksums (</span><br><span class="line">db char(64) NOT NULL,</span><br><span class="line">tbl char(64) NOT NULL,</span><br><span class="line">chunk int NOT NULL,</span><br><span class="line">chunk_time float NULL,</span><br><span class="line">chunk_index varchar(200) NULL,</span><br><span class="line">lower_boundary text NULL,</span><br><span class="line">upper_boundary text NULL,</span><br><span class="line">this_crc char(40) NOT NULL,</span><br><span class="line">this_cnt int NOT NULL,</span><br><span class="line">master_crc char(40) NULL,</span><br><span class="line">master_cnt int NULL,</span><br><span class="line">ts timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (db, tbl, chunk),</span><br><span class="line">INDEX ts_db_tbl (ts, db, tbl)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>检测数据一致性：</strong></p>
<p>​    <figure class="highlight plain"><figcaption><span>--nocheck-binlog-format --nocheck-plan --nocheck-replication-filters --replicate</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```shell</span><br><span class="line">--check</span><br><span class="line">   检查从的延迟，检查一次就退出，除非指定了--recurse会递归的检查所有的从服务器。</span><br><span class="line"></span><br><span class="line">--monitor</span><br><span class="line">   持续监控从的延迟情况。通过--interval指定的间隔时间，打印出从的延迟信息--daemonize</span><br><span class="line">   执行时，放入到后台执行</span><br><span class="line"></span><br><span class="line">--file </span><br><span class="line">   打印--monitor最新的记录到指定的文件，很好的防止满屏幕都是数据的烦恼。</span><br><span class="line"></span><br><span class="line">--frames</span><br><span class="line">   在--monitor里输出的[]里的记录段，默认是1m,5m,15m。可以指定1个，如：--frames=1s，多个用逗号隔开。可用单位有秒（s）、分钟（m）、小时（h）、天（d）。</span><br><span class="line"></span><br><span class="line">--interval</span><br><span class="line">   检查、更新的间隔时间。默认是见是1s。最小的单位是0.01s，最大精度为小数点后两位，因此0.015将调整至0.02。</span><br><span class="line"></span><br><span class="line">--log</span><br><span class="line">   开启daemonized模式的所有日志将会被打印到制定的文件中。</span><br><span class="line"></span><br><span class="line">--update</span><br><span class="line">   更新主上的心跳表。</span><br><span class="line"></span><br><span class="line">--replace</span><br><span class="line">   使用--replace代替--update模式更新心跳表里的时间字段，这样的好处是不用管表里是否有行。</span><br><span class="line"></span><br><span class="line">--stop</span><br><span class="line">  停止运行该工具（--daemonize），在/tmp/目录下创建一个“pt-heartbeat-sentinel” 文件。后面想重新开启则需要把该临时文件删除，才能开启（--daemonize）。</span><br><span class="line"></span><br><span class="line">--table</span><br><span class="line">  指定心跳表名，默认heartbeat。</span><br><span class="line"></span><br><span class="line">--create-table</span><br><span class="line">  在主上创建心跳监控的表，如果该表不存在。可以自己建立，建议存储引擎改成memory。通过更新该表知道主从延迟的差距。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">pt-table-checksum参数解释</span><br><span class="line"></span><br><span class="line">--replicate-check：</span><br><span class="line"></span><br><span class="line">    执行完 checksum 查询在percona.checksums表中，不一定马上查看结果呀 —— yes则马上比较chunk的crc32值并输出DIFFS列，否则不输出。默认yes，如果指定为--noreplicate-check，一般后续使用下面的--replicate-check-only去输出DIFF结果。</span><br><span class="line">    </span><br><span class="line">--nocheck-replication-filters ：</span><br><span class="line">	不检查复制过滤器，建议启用。后面可以用--databases来指定需要检查的数据库。</span><br><span class="line">	</span><br><span class="line">--no-check-binlog-format :</span><br><span class="line">    不检测日志格式。这个选项对于 ROW 模式的复制很重要，因为pt-table-checksum会在 Master和Slave 上设置binlog_format=STATEMENT（确保从库也会执行 checksum SQL），MySQL限制从库是无法设置的，所以假如行复制从库，再作为主库复制出新从库时（A-&gt;B-&gt;C），B的checksums数据将无法传输。（没验证）</span><br><span class="line">    </span><br><span class="line">--replicate-check-only :</span><br><span class="line">不在主从库做 checksum 查询，只在原有 percona.checksums 表中查询结果，并输出数据不一致的信息。周期性的检测一致性时可能用到。</span><br><span class="line"></span><br><span class="line">--replicate= ：</span><br><span class="line">把checksum的信息写入到指定表中，如果没有指定，默认是 percona.checksums ;建议直接写到被检查的数据库当中。</span><br><span class="line"></span><br><span class="line">--databases=,-d ：</span><br><span class="line">要检查的数据库，逗号分隔;--databases-regex 正则匹配要检测的数据库，--ignore-databases[-regex]忽略检查的库。Filter选项。</span><br><span class="line"></span><br><span class="line">--tables=，-t</span><br><span class="line">：要检查的表，逗号分隔。如果要检查的表分布在不同的db中，可以用--		tables=dbname1.table1,dbnamd2.table2的形式。同理有--tables-regex，--ignore-tables，--ignore-tables-regex。--replicate指定的checksum表始终会被过滤。</span><br><span class="line"></span><br><span class="line">--tables= ：</span><br><span class="line">指定需要被检查的表，多个用逗号隔开</span><br><span class="line"></span><br><span class="line">h=192.168.1.101 ：Master的地址</span><br><span class="line"></span><br><span class="line">u=ptuser ：用户名</span><br><span class="line"></span><br><span class="line">p=123456 ：密码</span><br><span class="line"></span><br><span class="line">P=3306 ：端口</span><br><span class="line"></span><br><span class="line">--create-replicate-table </span><br><span class="line">选项会自动创建 percona.checksums 表，但也意味着赋予额外的 CREATE TABLE权限给 percona_tk@&apos;xxx&apos; 用户。默认yes</span><br><span class="line"></span><br><span class="line">--no-check-replication-filters </span><br><span class="line">表示不需要检查 Master 配置里是否指定了 Filter。 默认会检查，如果配置了 Filter，如 replicate_do_db,replicate-wild-ignore-table,binlog_ignore_db 等，在从库checksum就与遇到表不存在而报错退出，所以官方默认是yes（--check-replication-filters）但我们实际在检测中时指定--databases=，所以就不存在这个问题，干脆不检测；</span><br><span class="line"></span><br><span class="line">--empty-replicate-table：</span><br><span class="line">每个表checksum开始前，清空它之前的检测数据（不影响其它表的checksum数据），默认yes。当然如果使用--resume启动检测数据不会清空。当启用--noempty-replicate-table即不清空时，不计算计算chunk,只计算。</span><br><span class="line"></span><br><span class="line">-recursion-method：</span><br><span class="line">发现从库的方式。pt-table-checksum 默认可以在主库的 processlist 中找到从库复制进程，从而识别出有哪些从库，但如果使用是非标准3306端口，会导致找不到从库信息。此时就会自动采用host方式，但需要提前在从库 my.cnf 里面配置report_host、report_port信息，如：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">report_host = 39.106.84.122</span><br><span class="line">report_port = 3306</span><br></pre></td></tr></table></figure></p>
<p>​        </p>
<p>如果 报错：  <strong>Diffs cannot be detected because no slaves were found.  Please read the —recursion-method documentation for information.</strong></p>
<p>​        <strong>缺少  –recursion-method参数</strong></p>
<p>上面的提示信息很清楚，因为找不到从，所以执行失败。用参数—recursion-method 可以指定模式解决，关于—recursion-method参数的设置有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">METHOD       USES</span><br><span class="line">===========  =============================================</span><br><span class="line">processlist  SHOW PROCESSLIST</span><br><span class="line">hosts        SHOW SLAVE HOSTS</span><br><span class="line">cluster      SHOW STATUS LIKE 'wsrep\_incoming\_addresses'</span><br><span class="line">dsn=DSN      DSNs from a table</span><br><span class="line">none         Do not find slaves</span><br></pre></td></tr></table></figure>

<p>默认是通过show processlist 找到host的值或show slave hosts 找到host的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show processlist\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     Id: 3</span><br><span class="line">   User: slave</span><br><span class="line">   Host: 192.168.0.20:52352</span><br><span class="line">     db: NULL</span><br><span class="line">Command: Binlog Dump</span><br><span class="line">   Time: 4164</span><br><span class="line">  State: Master has sent all binlog to slave; waiting for binlog to be updated</span><br><span class="line">   Info: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">     Id: 33</span><br><span class="line">   User: root</span><br><span class="line">   Host: localhost</span><br><span class="line">     db: NULL</span><br><span class="line">Command: Query</span><br><span class="line">   Time: 0</span><br><span class="line">  State: NULL</span><br><span class="line">   Info: show processlist</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>还有一种方法是show slave hosts；前提从库配置文件里面已经配置自己的地址和端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MySQL-02 ~]# grep 'report' /etc/my.cnf </span><br><span class="line">report_host = 192.168.0.20</span><br><span class="line">report_port = 3306</span><br><span class="line">[root@MySQL-02 ~]# </span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> show slave hosts;</span><br><span class="line">+-----------+--------------+------+-----------+</span><br><span class="line">| Server_id | Host         | Port | Master_id |</span><br><span class="line">+-----------+--------------+------+-----------+</span><br><span class="line">|         2 | 192.168.0.20 | 3306 |         1 |</span><br><span class="line">+-----------+--------------+------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>所以找不到从服务器时。在从库配置文件添加</p>
<p>report_host=39.106.84.122</p>
<p>report_port=3306</p>
<p>现在我们再来检测数据一致性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MySQL-01 ~]# pt-table-checksum --nocheck-binlog-format --nocheck-plan --nocheck-replication-filters --replicate=pt.checksums --set-vars innodb_lock_wait_timeout=120 --recursion-method=hosts --databases test -u'root' -p'123456' -h47.97.218.145 -P3306</span><br><span class="line">            TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE</span><br><span class="line">04-13T15:59:31      0      1        3       1       0   0.080 yayun.t1</span><br><span class="line"></span><br><span class="line">TS            ：完成检查的时间。</span><br><span class="line">ERRORS        ：检查时候发生错误和警告的数量。</span><br><span class="line">DIFFS         ：0表示一致，1表示不一致。当指定--no-replicate-check时，会一直为0，当指定--replicate-check-only会显示不同的信息。</span><br><span class="line">ROWS          ：表的行数。</span><br><span class="line">CHUNKS        ：被划分到表中的块的数目。</span><br><span class="line">SKIPPED       ：由于错误或警告或过大，则跳过块的数目。</span><br><span class="line">TIME          ：执行的时间。</span><br><span class="line">TABLE         ：被检查的表名。</span><br></pre></td></tr></table></figure>

<p>参数的意思：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--nocheck-replication-filters ：不检查复制过滤器，建议启用。后面可以用--databases来指定需要检查的数据库。</span><br><span class="line">--no-check-binlog-format      : 不检查复制的binlog模式，要是binlog模式是ROW，则会报错。</span><br><span class="line">--replicate-check-only :只显示不同步的信息。</span><br><span class="line">--replicate=   ：把checksum的信息写入到指定表中，建议直接写到被检查的数据库当中。 </span><br><span class="line">--databases=   ：指定需要被检查的数据库，多个则用逗号隔开。</span><br><span class="line">--tables=      ：指定需要被检查的表，多个用逗号隔开</span><br><span class="line">h=127.0.0.1    ：Master的地址</span><br><span class="line">u=root         ：用户名</span><br><span class="line">p=123456       ：密码</span><br><span class="line">P=3306         ：端口</span><br></pre></td></tr></table></figure>

<p>好了，命令以及常用参数都介绍了，一起解释下上面执行的效果：</p>
<p>通过DIFFS 是1 就可以看出主从的表数据不一致。怎么不一致呢？ 通过指定—replicate=pt.checksums 参数，就说明把检查信息都写到了checksums表中。</p>
<p>进入SLAVE相应的库中查看checksums表的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select * from checksums\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">            db: yayun</span><br><span class="line">           tbl: t1</span><br><span class="line">         chunk: 1</span><br><span class="line">    chunk_time: 0.010735</span><br><span class="line">   chunk_index: NULL</span><br><span class="line">lower_boundary: NULL</span><br><span class="line">upper_boundary: NULL</span><br><span class="line">      this_crc: babf1dc0    #slave</span><br><span class="line">      this_cnt: 5           #slave</span><br><span class="line">    master_crc: 8727436a    #master</span><br><span class="line">    master_cnt: 3           #master                 可以发现表t1中从库比主库多2条记录</span><br><span class="line">            ts: 2014-04-13 16:05:16</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>通过上面找到了这些不一致的数据表，如何同步数据呢？即如何修复MySQL主从不一致的数据，让他们保持一致性呢？利用另外一个工具 pt-table-sync。</strong></p>
<h2 id="pt-table-sync（修复MySQL主从不一致的数据）"><a href="#pt-table-sync（修复MySQL主从不一致的数据）" class="headerlink" title="pt-table-sync（修复MySQL主从不一致的数据）"></a>pt-table-sync（修复MySQL主从不一致的数据）</h2><p>使用方法：</p>
<p>pt-table-sync [OPTIONS] DSN [DSN]</p>
<p><code>pt-table-sync</code>: 高效的同步MySQL表之间的数据，他可以做单向和双向同步的表数据。他可以同步单个表，也可以同步整个库。它不同步表结构、索引、或任何其他模式对象。所以在修复一致性之前需要保证他们表存在。</p>
<p>接着上面的复制情况，主和从的t1表数据不一致，需要修复，</p>
<p>执行：</p>
<p><strong>先master的ip，用户，密码，然后是slave的ip，用户，密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MySQL-01 ~]# pt-table-sync --replicate=pt.checksums h=47.97.218.145,u=root,p=123456 h=39.106.84.122,u=root,p=123456 --print</span><br><span class="line">DELETE FROM `test`.`t` WHERE `id`='4' LIMIT 1 /*percona-toolkit src_db:test src_tbl:t src_dsn:h=47.97.218.145,p=...,u=root dst_db:test dst_tbl:t dst_dsn:h=39.106.84.122,p=...,u=root lock:1 transaction:1 changing_src:pt.checksums replicate:pt.checksums bidirectional:0 pid:21596 user:root host:izbp13ke316g8b9btrd3dnz*/;</span><br></pre></td></tr></table></figure>

<p>参数的意义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--replicate=  ：指定通过pt-table-checksum得到的表，这2个工具差不多都会一直用。</span><br><span class="line">--databases=  : 指定执行同步的数据库，多个用逗号隔开。</span><br><span class="line">--tables=     ：指定执行同步的表，多个用逗号隔开。</span><br><span class="line">--sync-to-master ：指定一个DSN，即从的IP，他会通过show processlist或show slave status 去自动的找主。</span><br><span class="line">h=127.0.0.1   ：服务器地址，命令里有2个ip，第一次出现的是Master的地址，第2次是Slave的地址。</span><br><span class="line">u=root        ：帐号。</span><br><span class="line">p=123456      ：密码。</span><br><span class="line">--print       ：打印，但不执行命令。</span><br><span class="line">--execute     ：执行命令。</span><br></pre></td></tr></table></figure>

<p>命令介绍完了，一起解释下执行的效果：通过（—print）打印出来了修复数据的sql语句，可以手动的去从行执行，让他们数据保持一致性。那能否直接执行？当然可以，通过(—execute)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MySQL-01 ~]#  pt-table-sync --replicate=pt.checksums h=47.97.218.145,u=root,p=123456 h=39.106.84.122,u=root,p=123456 --execute</span><br></pre></td></tr></table></figure>

<p>没发现任何异常，然后检查主从数据的一致性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@MySQL-01 ~]# pt-table-checksum --nocheck-binlog-format --nocheck-plan --nocheck-replication-filters --replicate=pt.checksums --set-vars innodb_lock_wait_timeout=120 --recursion-method=hosts --databases test -u'root' -p'123456' -h47.97.218.145 -P3306</span><br><span class="line">            TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE</span><br><span class="line">04-13T16:27:28      0      0        3       1       0   0.097 yayun.t1</span><br></pre></td></tr></table></figure>

<p>主库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select * from t1;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | yayun |</span><br><span class="line">|  2 | atlas |</span><br><span class="line">|  3 | mysql |</span><br><span class="line">+----+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span></span><br></pre></td></tr></table></figure>

<p>备库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select * from t1;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | yayun |</span><br><span class="line">|  2 | atlas |</span><br><span class="line">|  3 | mysql |</span><br><span class="line">+----+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，数据已经保持一致了。</p>
<p>不过建议还是用—print 打印出来的好，这样就可以知道那些数据有问题，可以人为的干预下。</p>
<p>不然直接执行了，出现问题之后更不好处理。总之还是在处理之前做好数据的备份工作。</p>
<p><strong>注意：要是表中没有唯一索引或则主键则会报错：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Can't make changes on the master because no unique index exists at /usr/local/bin/pt-table-sync line 10591.</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>工具很给力，工作中常常在使用。注意使用该工具需要授权，一般SELECT, PROCESS, SUPER, REPLICATION SLAVE等权限就已经足够了。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引类型及创建索引</title>
    <url>/2020/02/08/mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><h6 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h6><p>​        MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：</p>
<p><img src="//dingyifan.tech/2020/02/08/mysql索引/Users/60952/Desktop/1902A%E5%AD%A6%E7%94%9F%E8%AE%B2%E8%AF%BE%E8%AF%BE%E4%BB%B6(1)/1902A%E5%AD%A6%E7%94%9F%E8%AE%B2%E8%AF%BE%E8%AF%BE%E4%BB%B6/mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/B%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B树"></p>
<p>​        索引类似一本书的目录，可以提高数据检索的效率，降低数据库的IO成本。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。 </p>
<p>MySQL目前主要有以下几种索引类型：</p>
<p>1.<strong>普通索引</strong></p>
<p>2.<strong>唯一索引</strong></p>
<p>3.<strong>主键索引</strong></p>
<p>4.<strong>联合索引</strong></p>
<p>5.<strong>联合唯一索引</strong></p>
<p>6.<strong>全文索引</strong></p>
<h4 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name]</span><br><span class="line">[unique|fulltext] [index|key] [index_name] (col_name[length])[asc|desc]</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">CREATE TABLE [unique|fulltext] [index|key] [index_name] on table_name[col_name[length]] [asc|desc]</span><br></pre></td></tr></table></figure>

<h6 id="1-unique-fulltext为可选参数，分别表示唯一索引、全文索引"><a href="#1-unique-fulltext为可选参数，分别表示唯一索引、全文索引" class="headerlink" title="1.unique|fulltext为可选参数，分别表示唯一索引、全文索引"></a>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引</h6><h6 id="2-index和key为同义词，两者作用相同，用来指定创建索引"><a href="#2-index和key为同义词，两者作用相同，用来指定创建索引" class="headerlink" title="2.index和key为同义词，两者作用相同，用来指定创建索引"></a>2.index和key为同义词，两者作用相同，用来指定创建索引</h6><h6 id="3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"><a href="#3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择" class="headerlink" title="3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"></a>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</h6><h6 id="4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值"><a href="#4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值" class="headerlink" title="4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值"></a>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</h6><h6 id="5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"><a href="#5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度" class="headerlink" title="5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"></a>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</h6><h6 id="6-asc或desc指定升序或降序的索引值存储"><a href="#6-asc或desc指定升序或降序的索引值存储" class="headerlink" title="6.asc或desc指定升序或降序的索引值存储"></a>6.asc或desc指定升序或降序的索引值存储</h6><blockquote>
<h4 id="注意：create-语法不能创建主键索引-只有alter语法可以！"><a href="#注意：create-语法不能创建主键索引-只有alter语法可以！" class="headerlink" title="注意：create 语法不能创建主键索引,只有alter语法可以！"></a>注意：create 语法不能创建主键索引,只有alter语法可以！</h4></blockquote>
<h4 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h4><h6 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h6><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length))</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构的方式添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候同时创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（4）删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>

<h6 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h6><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候直接指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h6><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>设置字段为主键索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` );</span><br></pre></td></tr></table></figure>

<h6 id="4-联合索引（复合索引）"><a href="#4-联合索引（复合索引）" class="headerlink" title="4.联合索引（复合索引）"></a>4.联合索引（复合索引）</h6><blockquote>
<p>​        指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
<p>​        两个或更多个列上的索引被称作复合索引。</p>
<p>​        利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名字不知道姓，电话簿将没有任何用处。</p>
<p>​        所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure>

<h6 id="5-联合唯一索引（复合唯一索引）"><a href="#5-联合唯一索引（复合唯一索引）" class="headerlink" title="5.联合唯一索引（复合唯一索引）"></a>5.联合唯一索引（复合唯一索引）</h6><blockquote>
<p>多列惟一性索引，保证多个值的组合不重复。 </p>
</blockquote>
<p>(1) 创建联合唯一索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># create unique index 索引名字 on 表名(字段1，字段2) </span><br><span class="line">create unique index uni_index on user(phone,address);</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa,bb); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure>

<p>(2) 删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index 索引名字 on 表名;</span><br></pre></td></tr></table></figure>

<h6 id="6-全文索引"><a href="#6-全文索引" class="headerlink" title="6.全文索引"></a>6.全文索引</h6><blockquote>
<p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p>
<p>全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。 </p>
<p>在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎.在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词. </p>
</blockquote>
<p>（1）创建表的适合添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br></pre></td></tr></table></figure>

<p>（3）直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure>

<p>（4）使用全文索引</p>
<p>​    跟普通索引稍有不同</p>
<p>   使用全文索引的格式：  MATCH (columnName) AGAINST (‘string’)</p>
<p>   eg:</p>
<p>​     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</span><br></pre></td></tr></table></figure>

<p>​    当查询多列数据时：</p>
<p>​    建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`,`address`) AGAINST(&apos;聪 广东&apos;)</span><br></pre></td></tr></table></figure>

<p>（5）使用全文索引需要注意的是：(基本单位是词)</p>
<ul>
<li><p>分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符(外国人嘛)</p>
</li>
<li><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p>
<p>这两个的默认值可以使用以下命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%ft%&apos;;</span><br></pre></td></tr></table></figure>

<p>1<br>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MyISAM</span><br><span class="line">ft_min_word_len = 4;</span><br><span class="line">ft_max_word_len = 84;</span><br><span class="line"></span><br><span class="line">// InnoDB</span><br><span class="line">innodb_ft_min_token_size = 3;</span><br><span class="line">innodb_ft_max_token_size = 84;</span><br></pre></td></tr></table></figure>

<p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 aaaa 的长度大于等于 4。</p>
<p>看下图：</p>
<img src="//dingyifan.tech/2020/02/08/mysql索引/Users/60952/Desktop/1902A学生讲课课件(1)/1902A学生讲课课件/mysql索引类型及创建索引/全文索引相关变量.png" alt="全文索引配置图片" style="zoom:80%;">

</li>
</ul>
<p>​    </p>
<h4 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点"></a>四、缺点</h4><ol>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</li>
</ol>
<h4 id="五、什么时候需要创建索引"><a href="#五、什么时候需要创建索引" class="headerlink" title="五、什么时候需要创建索引"></a>五、什么时候需要创建索引</h4><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）</li>
<li>查询中统计或者分组的字段；</li>
</ol>
<h4 id="六、什么时候不需要创建索引"><a href="#六、什么时候不需要创建索引" class="headerlink" title="六、什么时候不需要创建索引"></a>六、什么时候不需要创建索引</h4><ol>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件</li>
<li>where条件里用不到的字段，不创建索引；</li>
<li>表记录太少，不需要创建索引；</li>
<li>经常增删改的表；</li>
<li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</li>
</ol>
<h4 id="七，注意事项-某些索引失效的情况"><a href="#七，注意事项-某些索引失效的情况" class="headerlink" title="七，注意事项(某些索引失效的情况)"></a>七，注意事项(某些索引失效的情况)</h4><blockquote>
<p>​        使用索引时，有以下一些技巧和注意事项：</p>
</blockquote>
<ol>
<li><strong>索引不会包含有null值的列</strong>。<br>只要列中包含有null值都将不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为null。</li>
</ol>
<ol start="2">
<li><strong>使用短索引。</strong><br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>
</ol>
<ol start="3">
<li><strong>索引列排序</strong>。<br>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li>
</ol>
<ol start="4">
<li><p><strong>like语句操作。</strong><br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用索引</span><br><span class="line">select * from user where phone like&apos;1310001%&apos;</span><br><span class="line"></span><br><span class="line"># 将不会使用索引</span><br><span class="line">select * from user where phone like&apos;%310001%&apos;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p><strong>不要在列上进行运算</strong>。</p>
<blockquote>
<p>目前，MySQL没有支持函数索引。 这意味着如果在列上使用索引，表达式YEAR(column)也不会</p>
<p>利用索引。等于说是给字段进行运算会导致索引失效</p>
</blockquote>
</li>
</ol>
<p>   这将导致索引失效而进行全表扫描，例如</p>
<p>   SELECT * FROM table_name WHERE YEAR(column_name)&lt;2019;</p>
<p>   可以改成：</p>
<pre><code>SELECT * FROM table_name WHERE  column_name &lt; &apos;2019-01-01&apos;;</code></pre><ol start="6">
<li><strong>如果条件中有or，即使其中有条件带索引也不会使用索引 ， 要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong>。 </li>
</ol>
<ol start="7">
<li><p><strong>对于多列索引，不是使用的第一部分（最左前缀），则不会使用索引。 Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</strong></p>
<p>例如索引是key index (a,b,c). 可以支持*<em>a| *</em>a,b| a,b,c,  3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
</li>
</ol>
<ol start="8">
<li><strong>如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引。</strong> </li>
</ol>
<ol start="9">
<li><strong>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</strong></li>
</ol>
<ol start="10">
<li><strong>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</strong></li>
</ol>
<ol start="11">
<li><p><strong>强制类型转换会全表扫描，</strong></p>
<p>如果phone字段是varcher类型，则下面的SQL不能命中索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select  *  fromuser where phone=13800001234;</span><br></pre></td></tr></table></figure>

<p>这样就可以命中索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select  *  fromuser where phone=&apos;13800001234&apos;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="八，查看sql语句执行时间和效率"><a href="#八，查看sql语句执行时间和效率" class="headerlink" title="八，查看sql语句执行时间和效率"></a>八，查看sql语句执行时间和效率</h4><h5 id="查看执行时间"><a href="#查看执行时间" class="headerlink" title="查看执行时间"></a>查看执行时间</h5><ol>
<li>show profiles; </li>
<li>show variables;查看profiling 是否是on状态； </li>
<li>如果是off，则 set profiling = 1； </li>
<li>执行自己的sql语句； </li>
<li>show profiles；就可以查到sql语句的执行时间；</li>
</ol>
<h5 id="查看操作了多少行"><a href="#查看操作了多少行" class="headerlink" title="查看操作了多少行"></a>查看操作了多少行</h5><p>在sql语句前面加上 explain就可以了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from event;  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| 1 | SIMPLE | event | ALL | NULL | NULL | NULL | NULL | 13 | |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="各个属性的含义"><a href="#各个属性的含义" class="headerlink" title="各个属性的含义"></a>各个属性的含义</h5><p>各个属性的含义</p>
<p><strong>id</strong></p>
<ul>
<li>​    select查询的序列号， 这个不重要,查询序号即为sql语句执行的顺序 。</li>
</ul>
<p><strong>select_type</strong></p>
<ul>
<li>​    select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</li>
</ul>
<p><strong>table</strong></p>
<ul>
<li>​    输出的行所引用的表。</li>
</ul>
<p><strong>type</strong></p>
<ul>
<li><p>​    联合查询所使用的类型。</p>
</li>
<li><p>​    type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p>
</li>
<li><p>​    system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;       index_subquery &gt; range &gt; index &gt; ALL</p>
<p>​    一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
</li>
</ul>
<p><strong>possible_keys</strong></p>
<ul>
<li>​    指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性     能，可    通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。</li>
</ul>
<p><strong>key</strong></p>
<ul>
<li>​    显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。</li>
</ul>
<p><strong>key_len</strong></p>
<ul>
<li>​    显示MySQL决定使用的键长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得    出一个多重主键里mysql实际使用了哪一部分。</li>
</ul>
<p><strong>ref</strong></p>
<ul>
<li>​    显示哪个字段或常数与key一起被使用。</li>
</ul>
<p><strong>rows</strong></p>
<ul>
<li>​    这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。</li>
</ul>
<p><strong>Extra</strong></p>
<ul>
<li><p>​    如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。</p>
</li>
<li><p>​    如果是where used，就是使用上了where限制。</p>
</li>
<li><p>​    如果是impossible where 表示用不着where，一般就是没查出来啥。</p>
</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/u014518337/article/details/88179607" target="_blank" rel="noopener">https://blog.csdn.net/u014518337/article/details/88179607</a></p>
<p>​                     <a href="https://www.jb51.net/article/158141.htm" target="_blank" rel="noopener">https://www.jb51.net/article/158141.htm</a> </p>
<p>​                    <a href="https://blog.csdn.net/qq_33451004/article/details/68976090" target="_blank" rel="noopener">https://blog.csdn.net/qq_33451004/article/details/68976090</a></p>
<p>​                     <a href="https://www.cnblogs.com/luohero/p/9139985.html" target="_blank" rel="noopener">https://www.cnblogs.com/luohero/p/9139985.html</a> </p>
<p>​                     <a href="https://www.cnblogs.com/l199616j/p/11232392.html" target="_blank" rel="noopener">https://www.cnblogs.com/l199616j/p/11232392.html</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查看mysql最大连接数</title>
    <url>/2020/02/08/%E6%9F%A5%E7%9C%8Bmysql%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h3 id="mysql最大连接数"><a href="#mysql最大连接数" class="headerlink" title="mysql最大连接数"></a>mysql最大连接数</h3><h5 id="1、查看mysql最大连接数"><a href="#1、查看mysql最大连接数" class="headerlink" title="1、查看mysql最大连接数"></a>1、查看mysql最大连接数</h5><p>​    [root@iZ2zefmvm357tixqsh3htmZ ~]# mysql -uroot -p</p>
<p>​    mysql&gt; show variables like ‘%max_connections%’;</p>
<p><img src="//dingyifan.tech/2020/02/08/查看mysql最大连接数/C:%5CUsers%5Cwzw%5CAppData%5CLocal%5CTemp%5C1576639265454.png" alt="1576639265454"></p>
<h5 id="查看服务器响应的最大连接数"><a href="#查看服务器响应的最大连接数" class="headerlink" title="查看服务器响应的最大连接数"></a>查看服务器响应的最大连接数</h5><p>​    show global status like ‘Max_used_connections’; </p>
<p>2、修改最大连接数 </p>
<p>方法一：修改配置文件。</p>
<p>​    推荐方法一 进入MySQL安装目录 打开MySQL配置文件 my.ini 或 my.cnf查找 max_connections=100 修改为 max_connections=1000 服务里重起MySQL即可. </p>
<p>方法二：命令行修改。</p>
<p>​    不推荐方法二 命令行登录MySQL后。设置新的MySQL最大连接数为200： MySQL&gt; set global max_connections=200。 这种方式有个问题，就是设置的最大连接数只在mysql当前服务进程有效，一旦mysql重启，又会恢复到初始状态。因为mysql启动后的初始化工作是从其配置文件中读取数据的，而这种方式没有对其配置文件做更改。 </p>
<h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h5><p>​    1、启动   service mysqld start </p>
<p>​    2、停止   service mysqld stop </p>
<p>​    3、重启   service mysqld restart </p>
<p>systemctl status mysqld     查看状态</p>
<p>systemctl  restart mysqld    重启</p>
<p>systemctl stop mysqld   停止</p>
<p>systemctl start mysqld  开启</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench</title>
    <url>/2020/02/08/webbench/</url>
    <content><![CDATA[<h1 id="WEBBENCH"><a href="#WEBBENCH" class="headerlink" title="WEBBENCH"></a>WEBBENCH</h1><h4 id="影响网站负载的因素"><a href="#影响网站负载的因素" class="headerlink" title="影响网站负载的因素"></a>影响网站负载的因素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">电脑速度、系统速度、网线速度、交换机速度、电话线或光纤速度（或其他上网介质）、ISP提供商速度，最后是你所进行网络行为的网络提供者的速度，</span><br></pre></td></tr></table></figure>

<p>​    服务器上的负载受两个因素影响：同时与服务器通信的连接（或虚拟用户）的数目，以及每个虚拟用户请求之间的考虑时间的长短</p>
<p>Webbench是知名的网站压力测试工具，它是由Lionbridge公司（<a href="http://www.lionbridge.com）开发。" target="_blank" rel="noopener">http://www.lionbridge.com）开发。</a></p>
<p>Webbench能测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。webbench的标准测试可以向我们展示服务器的两项内容：<strong>每秒钟相应请求数和每秒钟传输数据量。</strong>webbench不但能具有便准静态页面的测试能力，还能对动态页面（ASP,PHP,JAVA,CGI）进 行测试的能力。还有就是他支持对含有SSL的安全网站例如电子商务网站进行静态或动态的性能测试。<br><strong>Webbench最多可以模拟3万个并发连接去测试网站的负载能力。</strong><br>官方主页：<a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="noopener">http://home.tiscali.cz/~cz210552/webbench.html</a></p>
<p>官方介绍：<br><code>Web Bench is very simple tool for benchmarking WWW or proxy servers. Uses fork() for simulating multiple clients and can use HTTP/0.9-HTTP/1.1 requests. This benchmark is not very realistic, but it can test if your HTTPD can realy handle that many clients at once (try to run some CGIs) without taking your machine down. Displays pages/min and bytes/sec. Can be used in more aggressive mode with -f switch.</code></p>
<p>Web Bench是一个非常简单的工具，用于对WWW或代理服务器进行基准测试。使用fork（）模拟多个客户端，并可以使用HTTP/0.9-HTTP/1.1请求。这个基准不是很难现实，但是它可以测试你的HTTPD是否真的可以一次处理那么多客户机（试着运行一些cgi），而不会让你的机器停机。显示页/分和字节/秒。可用于更积极的模式与-f开关。</p>
<p>###1、WebBench安装：</p>
<p><code>wget http://www.ha97.com/code/webbench-1.5.tar.gz</code></p>
<p><code>tar zxvf webbench-1.5.tar.gzcd webbench-1.5</code></p>
<p><code>make</code></p>
<p><code>make install</code></p>
<h5 id="在安装编译webbench的时候，出现如下错误信息"><a href="#在安装编译webbench的时候，出现如下错误信息" class="headerlink" title="在安装编译webbench的时候，出现如下错误信息"></a>在安装编译webbench的时候，出现如下错误信息</h5><p>​    ctags <em>.c *</em>/bin/sh: ctags: command not found** make: [tags] Error 127 (ignored) </p>
<p>​    解决办法：yum install ctags  </p>
<p>###2、WebBench使用：</p>
<p>​    1、只支持get请求 </p>
<p><code>webbench -c 1000 -t 60 http://192.168.80.157/phpinfo.php</code><br>webbench -c 并发数 -t 运行测试时间 URL</p>
<p>#####Apache测试实例结果：</p>
<p>当并发300时，<br><code>root [ ~ ]# webbench -c 300 -t 60 http://192.168.80.157/phpinfo.phpWebbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmarking: GET http://192.168.80.157/phpinfo.php</span><br><span class="line">300 clients, running 60 sec.</span><br></pre></td></tr></table></figure>

<p><code>Speed=24525 pages/min, 20794612 bytes/sec.</code></p>
<p><code>Requests: 24525 susceed, 0 failed.</code><br>每秒钟响应请求数：24525 pages/min，每秒钟传输数据量（字节）20794612 bytes/sec.</p>
<p>当并发1000时，已经显示有87个连接failed了，说明超负荷了。</p>
<p><img src="//dingyifan.tech/2020/02/08/webbench/C:%5CUsers%5Cwzw%5CAppData%5CLocal%5CTemp%5C1576649588257.png" alt="1576649588257"></p>
<h3 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h3><p>​    1、django.db.utils.OperationalError: (1040, ‘Too many connections’)</p>
<p>​        django.db.utils.operational错误：（1040，“连接太多”）</p>
<h6 id="数据库连接数太多–"><a href="#数据库连接数太多–" class="headerlink" title="[数据库连接数太多–]"></a>[数据库连接数太多–]</h6><p>​    2、killed</p>
<p>​        网速，电脑太垃圾了，承受不了这儿大的访问量，自己把自己杀了。</p>
<p>#Webbench实现的核心原理是：</p>
<h5 id="父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。"><a href="#父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。" class="headerlink" title="父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。"></a>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</h5><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h1><p><strong>1、压力测试工作应该放到产品上线之前，而不是上线以后；2、测试时并发应当由小逐渐加大，比如并发100时观察一下网站负载是多少、打开页面是否流畅，并发200时又是多少、网站打开缓慢时并发是多少、网站打不开时并发又是多少；3、更详细的进行某个页面测试，如电商网站可以着重测试购物车、推广页面等，因为这些页面占整个网站访问量比重较大。</strong> </p>
<h1 id="web优化"><a href="#web优化" class="headerlink" title="web优化"></a>web优化</h1><p><a href="https://blog.csdn.net/baidu_30668495/article/details/83055911" target="_blank" rel="noopener">https://blog.csdn.net/baidu_30668495/article/details/83055911</a> </p>
<p>#网站测试工具：</p>
<p><a href="https://gtmetrix.com/" target="_blank" rel="noopener">https://gtmetrix.com/</a> </p>
<p><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a> </p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>qps-tps</title>
    <url>/2020/02/08/qps-tps/</url>
    <content><![CDATA[<p><strong>QPS</strong></p>
<p>QPS即每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p><strong>每秒查询率</strong></p>
<p>因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。</p>
<p>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p>
<p>计算关系：</p>
<p>QPS = 并发量 / 平均响应时间</p>
<p>并发量 = QPS * 平均响应时间</p>
<p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。</p>
<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。</p>
<p>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 。</p>
<p><strong>TPS (transaction per second**</strong>)代表每秒执行的事务数量**，可基于测试周期内完成的事务数量计算得出。 </p>
<p><strong>事实上TPS是事务在w.r.t时间的速率，所以也被称为吞吐量(throughput)。</strong></p>
<p>所以利特尔法则在负载模型中解释为：系统内平均用户数 = 平均响应时间 * 吞吐量</p>
<p>N = ( R + Z ) * X</p>
<p>N, 用户数</p>
<p>R, 平均响应时间(也可能是速率)</p>
<p>Z, 思考时间</p>
<p>X, 吞吐量(如TPS)</p>
<p>(<strong><em>利特尔法则</em></strong>  (Little’s law)：</p>
<p>该法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授John Little﹐于1961年所提出与证明。它是一个有关提前期与在制品关系的简单数学公式，这一法则为精益生产的改善方向指明了道路。</p>
<p><strong><em>利特尔法则的公式描述为</em></strong>：Lead Time(产出时间)= 存货数量×生产节拍     或     TH(生产效率)= WIP(存货数量)/ CT(周期时间))</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlslap使用总结</title>
    <url>/2020/02/08/mysqlslap%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="mysqlslap-使用总结"><a href="#mysqlslap-使用总结" class="headerlink" title="mysqlslap 使用总结"></a>mysqlslap 使用总结</h2><p>mysqlslap 可以用于模拟服务器的负载，并输出计时信息。其被包含在 MySQL 5.1 的发行包中。测试时，可以指定并发连接数，可以指定 SQL 语句。如果没有指定 SQL 语句，mysqlslap 会自动生成查询 schema 的 SELECT 语句。 </p>
<ol>
<li>查看帮助信息。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty libmysql]# mysqlslap --help</span><br><span class="line">mysqlslap  Ver 1.0 Distrib 5.6.10, for Linux (x86_64)</span><br><span class="line">Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Run a query multiple times against the server.</span><br><span class="line"></span><br><span class="line">Usage: mysqlslap [OPTIONS]</span><br><span class="line"></span><br><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf </span><br><span class="line">The following groups are read: mysqlslap client</span><br><span class="line">The following options may be given as the first argument:</span><br><span class="line">--print-defaults        Print the program argument list and exit.</span><br><span class="line">--no-defaults           Don&apos;t read default options from any option file,</span><br><span class="line">                        except for login file.</span><br><span class="line">--defaults-file=#       Only read default options from the given file #.</span><br><span class="line">--defaults-extra-file=# Read this file after the global files are read.</span><br><span class="line">--defaults-group-suffix=#</span><br><span class="line">                        Also read groups with concat(group, suffix)</span><br><span class="line">--login-path=#          Read this path from the login file.</span><br><span class="line">  -?, --help          Display this help and exit.</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  -a, --auto-generate-sql 自动生成测试表和数据</span><br><span class="line">                      Generate SQL where not supplied by file or command line.</span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">  --auto-generate-sql-add-autoincrement 增加auto_increment一列</span><br><span class="line">                      Add an AUTO_INCREMENT column to auto-generated tables.</span><br><span class="line">  --auto-generate-sql-execute-number=# 自动生成的查询的个数</span><br><span class="line">                      Set this number to generate a set number of queries to</span><br><span class="line">                      run.</span><br><span class="line">  --auto-generate-sql-guid-primary 增加基于GUID的主键</span><br><span class="line">                      Add GUID based primary keys to auto-generated tables.</span><br><span class="line">  --auto-generate-sql-load-type=name 测试语句的类型。取值包括：read，key，write，update和mixed(默认)</span><br><span class="line">                      read:查询 write:插入 key:读主键 update:更新主键 mixed:一半插入一半查询</span><br><span class="line">                      Specify test load type: mixed, update, write, key, or</span><br><span class="line">                      read; default is mixed.</span><br><span class="line">  --auto-generate-sql-secondary-indexes=# 增加二级索引的个数，默认是0</span><br><span class="line">                      Number of secondary indexes to add to auto-generated</span><br><span class="line">                      tables.</span><br><span class="line">  --auto-generate-sql-unique-query-number=# 不同查询的数量，默认值是10</span><br><span class="line">                      Number of unique queries to generate for automatic tests.</span><br><span class="line">  --auto-generate-sql-unique-write-number=# 不同插入的数量，默认是100</span><br><span class="line">                      Number of unique queries to generate for</span><br><span class="line">                      auto-generate-sql-write-number.</span><br><span class="line">  --auto-generate-sql-write-number=# </span><br><span class="line">                      Number of row inserts to perform for each thread (default</span><br><span class="line">                      is 100).</span><br><span class="line">  --commit=#          多少条DML后提交一次</span><br><span class="line">                      Commit records every X number of statements.</span><br><span class="line">  -C, --compress      如果服务器和客户端支持都压缩，则压缩信息传递</span><br><span class="line">                      Use compression in server/client protocol.</span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">  -c, --concurrency=name 模拟N个客户端并发执行select。可指定多个值，以逗号或者 --delimiter 参数指定的值做为分隔符</span><br><span class="line">                      Number of clients to simulate for query to run.</span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">  --create=name       指定用于创建表的.sql文件或者字串</span><br><span class="line">                      File or string to use create tables.</span><br><span class="line">  --create-schema=name 指定待测试的数据库名，MySQL中schema也就是database，默认是mysqlslap</span><br><span class="line">                      Schema to run tests in.</span><br><span class="line">  --csv[=name]        Generate CSV output to named file or to stdout if no file</span><br><span class="line">                      is named.</span><br><span class="line">  -#, --debug[=#]     This is a non-debug version. Catch this and exit.</span><br><span class="line">  --debug-check       Check memory and open file usage at exit.</span><br><span class="line">  -T, --debug-info    打印内存和CPU的信息</span><br><span class="line">                      Print some debug info at exit.</span><br><span class="line">  --default-auth=name Default authentication client-side plugin to use.</span><br><span class="line">  -F, --delimiter=name 文件中的SQL语句使用分割符号</span><br><span class="line">                      Delimiter to use in SQL statements supplied in file or</span><br><span class="line">                      command line.</span><br><span class="line">  --detach=#          每执行完N个语句，先断开再重新打开连接</span><br><span class="line">                      Detach (close and reopen) connections after X number of</span><br><span class="line">                      requests.</span><br><span class="line">  --enable-cleartext-plugin </span><br><span class="line">                      Enable/disable the clear text authentication plugin.</span><br><span class="line">  -e, --engine=name   创建测试表所使用的存储引擎，可指定多个</span><br><span class="line">                      Storage engine to use for creating the table.</span><br><span class="line">  -h, --host=name     Connect to host.</span><br><span class="line">  -i, --iterations=#  迭代执行的次数</span><br><span class="line">                      Number of times to run the tests.</span><br><span class="line">  --no-drop           Do not drop the schema after the test.</span><br><span class="line">  -x, --number-char-cols=name 自动生成的测试表中包含多少个字符类型的列，默认1</span><br><span class="line">                      Number of VARCHAR columns to create in table if</span><br><span class="line">                      specifying --auto-generate-sql.</span><br><span class="line">  -y, --number-int-cols=name 自动生成的测试表中包含多少个数字类型的列，默认1</span><br><span class="line">                      Number of INT columns to create in table if specifying</span><br><span class="line">                      --auto-generate-sql.</span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">  --number-of-queries=# 总的测试查询次数(并发客户数×每客户查询次数)</span><br><span class="line">                      Limit each client to this number of queries (this is not</span><br><span class="line">                      exact).</span><br><span class="line">                      </span><br><span class="line">                      </span><br><span class="line">  --only-print        只输出模拟执行的结果，不实际执行</span><br><span class="line">                      Do not connect to the databases, but instead print out</span><br><span class="line">                      what would have been done.</span><br><span class="line">  -p, --password[=name] </span><br><span class="line">                      Password to use when connecting to server. If password is</span><br><span class="line">                      not given it&apos;s asked from the tty.</span><br><span class="line">  --plugin-dir=name   Directory for client-side plugins.</span><br><span class="line">  -P, --port=#        Port number to use for connection.</span><br><span class="line">  --post-query=name   测试完成以后执行的SQL语句的文件或者字符串 这个过程不影响时间计算</span><br><span class="line">                      Query to run or file containing query to execute after</span><br><span class="line">                      tests have completed.</span><br><span class="line">  --post-system=name  测试完成以后执行的系统语句 这个过程不影响时间计算</span><br><span class="line">                      system() string to execute after tests have completed.</span><br><span class="line">  --pre-query=name    测试执行之前执行的SQL语句的文件或者字符串 这个过程不影响时间计算</span><br><span class="line">                      Query to run or file containing query to execute before</span><br><span class="line">                      running tests.</span><br><span class="line">  --pre-system=name   测试执行之前执行的系统语句 这个过程不影响时间计算</span><br><span class="line">                      system() string to execute before running tests.</span><br><span class="line">  --protocol=name     The protocol to use for connection (tcp, socket, pipe,</span><br><span class="line">                      memory).</span><br><span class="line">  -q, --query=name    指定自定义.sql脚本执行测试。例如可以调用自定义的一个存储过程或者sql语句来执行测试</span><br><span class="line">                      Query to run or file containing query to run.</span><br><span class="line">  -s, --silent        不输出</span><br><span class="line">                      Run program in silent mode - no output.</span><br><span class="line">  -S, --socket=name   The socket file to use for connection.</span><br><span class="line">  --ssl               Enable SSL for connection (automatically enabled with</span><br><span class="line">                      other flags).</span><br><span class="line">  --ssl-ca=name       CA file in PEM format (check OpenSSL docs, implies</span><br><span class="line">                      --ssl).</span><br><span class="line">  --ssl-capath=name   CA directory (check OpenSSL docs, implies --ssl).</span><br><span class="line">  --ssl-cert=name     X509 cert in PEM format (implies --ssl).</span><br><span class="line">  --ssl-cipher=name   SSL cipher to use (implies --ssl).</span><br><span class="line">  --ssl-key=name      X509 key in PEM format (implies --ssl).</span><br><span class="line">  --ssl-crl=name      Certificate revocation list (implies --ssl).</span><br><span class="line">  --ssl-crlpath=name  Certificate revocation list path (implies --ssl).</span><br><span class="line">  --ssl-verify-server-cert </span><br><span class="line">                      Verify server&apos;s &quot;Common Name&quot; in its cert against</span><br><span class="line">                      hostname used when connecting. This option is disabled by</span><br><span class="line">                      default.</span><br><span class="line">  -u, --user=name     User for login if not current user.</span><br><span class="line">  -v, --verbose       输出更多的信息</span><br><span class="line">                      More verbose output; you can use this multiple times to</span><br><span class="line">                      get even more verbose output.</span><br><span class="line">  -V, --version       Output version information and exit.</span><br><span class="line">[root@Betty libmysql]#</span><br></pre></td></tr></table></figure>



<p><strong>常用参数</strong> </p>
<p>#####–concurrency：代表并发数量，多个用逗号隔开，concurrency=10,50,100, 并发连接线程数分别是10、50、100个并发</p>
<p>–engines：代表要测试的引擎，可以有多个，用分隔符隔开<br>–iterations：代表要运行这些测试多少次<br>–commit=N：执行N条DML后提交一次<br>–auto-generate-sql：代表用系统自己生成的SQL脚本来测试<br>–auto-generate-sql-load-type：代表要测试的是读还是写还是两者混合的（read,write,update,mixed）</p>
<p>#####–number-of-queries：代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算</p>
<p>–debug-info：代表要额外输出CPU以及内存的相关信息<br>–number-int-cols ：创建测试表的 int 型字段数量<br>–auto-generate-sql-add-autoincrement ：代表对生成的表自动添加auto_increment列，从5.1.18版本开始<br>–number-char-cols：创建测试表的 char 型字段数量<br>–create-schema：测试的schema，MySQL中schema也就是database<br>–query：使用自定义脚本执行测试，例如可以调用自定义的一个存储过程或者sql语句来执行测试<br>–only-print：如果只想打印看看SQL语句是什么，可以用这个选项</p>
<ol start="2">
<li>以自动生成测试表和数据的形式，分别模拟 50 和 100 个客户端并发连接处理 1000 个 query（查询） 的情况。</li>
</ol>
<p>1.linux查看修改线程默认栈空间大小 ulimit -s</p>
<p>a、通过命令 ulimit -s 查看linux的默认栈空间大小，默认情况下 为10240 即10M</p>
<p>b、通过命令 ulimit -s 设置大小值 临时改变栈空间大小：ulimit -s 102400， 即修改为100M</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty libmysql]# mysqlslap -a --concurrency=50,100 --number-of-queries=1000             </span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.148 seconds</span><br><span class="line">        	运行所有查询的平均秒数</span><br><span class="line">        Minimum number of seconds to run all queries: 0.148 seconds</span><br><span class="line">        	运行所有查询的最小秒数</span><br><span class="line">        Maximum number of seconds to run all queries: 0.148 seconds</span><br><span class="line">        	运行所有查询的最大秒数</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        	运行查询的客户端数</span><br><span class="line">        Average number of queries per client: 20</span><br><span class="line">        	每个客户端的平均查询数</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.246 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.246 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.246 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 10</span><br><span class="line"></span><br><span class="line">[root@Betty libmysql]#</span><br></pre></td></tr></table></figure>



<ol start="3">
<li></li>
</ol>
<p>增加 –debug-info 选项，可以输出内存和CPU信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty libmysql]# mysqlslap -a --concurrency=50,100 --number-of-queries=1000 --debug-info</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.202 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.202 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.202 seconds</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        Average number of queries per client: 20</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.193 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.193 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.193 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User time 0.09, System time 0.05</span><br><span class="line">Maximum resident set size 7848, Integral resident set size 0</span><br><span class="line">Non-physical pagefaults 4221, Physical pagefaults 0, Swaps 0</span><br><span class="line">Blocks in 0 out 0, Messages in 0 out 0, Signals 0</span><br><span class="line">Voluntary context switches 7314, Involuntary context switches 1400</span><br></pre></td></tr></table></figure>



<p>\4. 增加 –iterations 选项，可以</p>
<p>重复执行 5 次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty libmysql]# </span><br><span class="line">[root@Betty libmysql]# mysqlslap -a --concurrency=50,100 --number-of-queries=1000 --iterations=5 --debug-info</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.168 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.147 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.217 seconds</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        Average number of queries per client: 20</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 0.209 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.156 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.280 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User time 0.47, System time 0.25</span><br><span class="line">Maximum resident set size 9848, Integral resident set size 0</span><br><span class="line">Non-physical pagefaults 16880, Physical pagefaults 0, Swaps 0</span><br><span class="line">Blocks in 0 out 0, Messages in 0 out 0, Signals 0</span><br><span class="line">Voluntary context switches 35954, Involuntary context switches 6583</span><br><span class="line">[root@Betty libmysql]#</span><br></pre></td></tr></table></figure>



<p>\5. 可以</p>
<p>针对远程主机上的 mysql 进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty Shell]# mysqlslap -a --concurrency=50,100 --number-of-queries=1000 -h 172.16.81.99 -P 3306 -p</span><br><span class="line">Enter password: </span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 2.009 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 2.009 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 2.009 seconds</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        Average number of queries per client: 20</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 4.519 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 4.519 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 4.519 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 10</span><br><span class="line"></span><br><span class="line">[root@Betty Shell]#</span><br></pre></td></tr></table></figure>



<p>\6. 使用 –only-print 选项，可以查看 mysqlslap 在测试过程中如何执行的 sql 语句。在这种方式下，仅会对数据库进行模拟操作。如下显示的自动产生测试表和数据的情况下，mysqlslap 的执行过程：</p>
<p>创建一个临时的库 mysqlslap ，并在测试结束是会将其删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty libmysql]# mysqlslap -a --only-print                                              </span><br><span class="line">DROP SCHEMA IF EXISTS `mysqlslap`;</span><br><span class="line">	删除架构（如果存在）</span><br><span class="line">CREATE SCHEMA `mysqlslap`;</span><br><span class="line">	创建架构</span><br><span class="line">use mysqlslap;</span><br><span class="line">CREATE TABLE `t1` (intcol1 INT(32) ,charcol1 VARCHAR(128));</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1348361729,&apos;i8X2EnycNH7sDHMltxcILtQE0ZPoPq9zyg24J0hiAgQNpg8jedtrWK5WtXIALR9B03FJ4ou6TCTAtWtN7fETzBzkiAmvTv6LrEZn2RtNfMaOkJfjytCp54ZfEJbb7Z&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1804289383,&apos;mxvtvmC9127qJNm06sGB8R92q2j7vTiiITRDGXM9ZLzkdekbWtmXKwZ2qG1llkRw5m9DHOFilEREk3q7oce8O3BEJC0woJsm6uzFAEynLH2xCsw1KQ1lT4zg9rdxBL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (822890675,&apos;97RGHZ65mNzkSrYT3zWoSbg9cNePQr1bzSk81qDgE4Oanw3rnPfGsBHSbnu1evTdFDe83ro9w4jjteQg4yoo9xHck3WNqzs54W5zEm92ikdRF48B2oz3m8gMBAl11W&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1308044878,&apos;50w46i58Giekxik0cYzfA8BZBLADEg3JhzGfZDoqvQQk0Akcic7lcJInYSsf9wqin6LDC1vzJLkJXKn5onqOy04MTw1WksCYqPl2Jg2eteqOqTLfGCvE4zTZwWvgMz&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (964445884,&apos;DPh7kD1E6f4MMQk1ioopsoIIcoD83DD8Wu7689K6oHTAjD3Hts6lYGv8x9G0EL0k87q8G2ExJjz2o3KhnIJBbEJYFROTpO5pNvxgyBT9nSCbNO9AiKL9QYhi0x3hL9&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1586903190,&apos;lwRHuWm4HE8leYmg66uGYIp6AnAr0BDd7YmuvYqCfqp9EbhKZRSymA4wx6gpHlJHI53DetH9j7Ixar90Jey5outd1ZIAJdJTjMaD7rMiqYXHFhHaB7Xr1HKuqe51GG&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (962033002,&apos;rfw4egILWisfxPwOc3nJx4frnAwgI539kr5EXFbupSZelM2MHqZEmD6ZNuEZzHib8fqYuHQbdrDND8lXqIdcNbAeWOBLZlpZOX5AoNlQFzpK7QjxcLP0wbWIriYGJL&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (1910858270,&apos;ksnug3YyANnWWDEJiRkiFC4a3e6KyJ2i3hSjksiuFLHlRXw9yhjDtnfoQd0OouyrcIbCB9zQWG4pf0yTZhaIT67nj7BY21FWJqaWrZxEh13Kt2hRbGl4MsrxsuLmvd&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (63299708,&apos;FJid3GaHpRC2L6jgirPm5AW3uGGgCloJ5Ww0eNHSiLWvS5bAxto23AxxR6TXr9qofeoAtxWcJsXnxzxmsdhvoekFc5mSES8tyxvsuPK5Hjs7ihtaJaLz5xEh2s1GCA&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (737703662,&apos;2zxutF6rOqjXYHHzSrKRwAhWCPXTdhNXYKQIRO9sEkFf1YeTGqw40Ta5u6QNfpvC1DWTTXDkFSFHtte9bbDSwgZjmryHglLhqjAKEF4MkJfT49eXcjzZNOG1F6BnsY&apos;);</span><br><span class="line">INSERT INTO t1 VALUES (100669,&apos;qnMdipW5KkXdTjGCh2PNzLoeR0527frpQDQ8uw67Ydk1K06uuNHtkxYBxT5w8plb2BbpzhwYBgPNYX9RmICWGkZD6fAESvhMzH3yqzMtXoH4BQNylbK1CmEIPGYlC6&apos;);</span><br><span class="line">SELECT intcol1,charcol1 FROM t1;</span><br><span class="line">INSERT INTO t1 VALUES (73673339,&apos;BN3152Gza4GW7atxJKACYwJqDbFynLxqc0kh30YTwgz3FktQ43XTrqJ4PQ25frn7kXhfXD8RuzN1j8Rf3y8ugKy6es3IbqPJM6ylCyD6xS7YcQCfHKZxYNvB7yTahm&apos;);</span><br><span class="line">SELECT intcol1,charcol1 FROM t1;</span><br><span class="line">INSERT INTO t1 VALUES (1759592334,&apos;3lkoxjtvgLu5xKHSTTtJuGE5F5QqmCcppCTmvFZScRZQgim93gSxwb24gKmIPEzEQStMjQiCu7WapGbkw4ilXch3xRLMhKSzgLDOovSi2qGj6rKvnuYAWDDJgaZDu2&apos;);</span><br><span class="line">SELECT intcol1,charcol1 FROM t1;</span><br><span class="line">INSERT INTO t1 VALUES (95275444,&apos;bNIrBDBl81tjzdvuOpQRCXgX37xGtzLKEXBIcE3k7xK7aFtqxC99jqYnpTviK83bf6lGDgsKd4R3KLmHPnI8TqnIKj1gjw7N2sXFZNS2Svyg8cpZN7atxL39w4igsp&apos;);</span><br><span class="line">SELECT intcol1,charcol1 FROM t1;</span><br><span class="line">INSERT INTO t1 VALUES (866596855,&apos;naQuzhMt1IrZIJMkbLAKBNNKKK2sCknzI5uHeGAgQuDd5SLgpN0smODyc7qorTo1QaI5qLl97qmCIzl0Mds81x7TxpIoJyqlY0iEDRNKA1PS0AKEn5NhuMAr3KgEIM&apos;);</span><br><span class="line">SELECT intcol1,charcol1 FROM t1;</span><br><span class="line">INSERT INTO t1 VALUES (364531492,&apos;qMa5SuKo4M5OM7ldvisSc6WK9rsG9E8sSixocHdgfa5uiiNTGFxkDJ4EAwWC2e4NL1BpAgWiFRcp1zIH6F1BayPdmwphatwnmzdwgzWnQ6SRxmcvtd6JRYwEKdvuWr&apos;);</span><br><span class="line">DROP SCHEMA IF EXISTS `mysqlslap`;</span><br><span class="line">[root@Betty libmysql]#</span><br></pre></td></tr></table></figure>



<p>\7. 实际测试中的复杂情况。</p>
<p>使用 –defaults-file 选项，指定从配置文件中读取选项配置。</p>
<p>使用 –number-int-cols 选项，指定表中会包含 4 个 int 型的列。</p>
<p>使用 –number-char-cols 选项，指定表中会包含 35 个 char 型的列。</p>
<p>使用 –engine 选项，指定针对何种存储引擎进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@Betty ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=50,100,200 --iterations=1 --number-int-cols=4 --number-char-cols=35 --auto-generate-sql --auto-generate-sql-add-autoincrement --auto-generate-sql-load-type=mixed --engine=myisam,innodb --number-of-queries=200 --debug-info -S /tmp/mysql.sock</span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine myisam</span><br><span class="line">        Average number of seconds to run all queries: 0.015 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.015 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.015 seconds</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        Average number of queries per client: 4</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine myisam</span><br><span class="line">        Average number of seconds to run all queries: 0.024 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.024 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.024 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 2</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine myisam</span><br><span class="line">        Average number of seconds to run all queries: 0.028 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.028 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.028 seconds</span><br><span class="line">        Number of clients running queries: 200</span><br><span class="line">        Average number of queries per client: 1</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine innodb</span><br><span class="line">        Average number of seconds to run all queries: 0.112 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.112 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.112 seconds</span><br><span class="line">        Number of clients running queries: 50</span><br><span class="line">        Average number of queries per client: 4</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine innodb</span><br><span class="line">        Average number of seconds to run all queries: 0.042 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.042 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.042 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 2</span><br><span class="line"></span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine innodb</span><br><span class="line">        Average number of seconds to run all queries: 0.105 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 0.105 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 0.105 seconds</span><br><span class="line">        Number of clients running queries: 200</span><br><span class="line">        Average number of queries per client: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User time 0.05, System time 0.06</span><br><span class="line">Maximum resident set size 8332, Integral resident set size 0</span><br><span class="line">Non-physical pagefaults 5388, Physical pagefaults 0, Swaps 0</span><br><span class="line">Blocks in 0 out 0, Messages in 0 out 0, Signals 0</span><br><span class="line">Voluntary context switches 7484, Involuntary context switches 2839</span><br><span class="line">[root@Betty ~]#</span><br></pre></td></tr></table></figure>



<p>\8. 使用存储过程进行测试。</p>
<p>略</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlslap压力测试</title>
    <url>/2020/02/08/mysqlslap%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="【压力测试】使用mysqlslap进行mysql基准测试"><a href="#【压力测试】使用mysqlslap进行mysql基准测试" class="headerlink" title="【压力测试】使用mysqlslap进行mysql基准测试"></a>【压力测试】使用mysqlslap进行mysql基准测试</h1><h1 id="为什么要进行压力测试？"><a href="#为什么要进行压力测试？" class="headerlink" title="为什么要进行压力测试？"></a>为什么要进行压力测试？</h1><p><strong>PS：在运维工作中，压力测试是一项很重要的工作。比如在一个网站上线之前，能承受多大访问量、在大访问量情况下性能怎样，这些数据指标好坏将会直接影响用户体验。但是，在压力测试中存在一个共性，那就是压力测试的结果与实际负载结果不会完全相同，就算压力测试工作做的再好，也不能保证100%和线上性能指标相同。面对这些问题，我们只能尽量去想方设法去模拟。所以，压力测试非常有必要，有了这些数据，我们就能对自己做维护的平台做到心中有数。</strong></p>
<p>压力测试考察当前软硬件环境下系统所能承受的最大负荷并帮助找出系统瓶颈所在。压测都是为了系统在线上的处理能力和稳定性维持在一个标准范围内，做到心中有数。 </p>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>1、对新的或调整后的数据库服务器进行测试，验证或比较配置结果；<br>2、建立Mysql服务器的性能基准线，即得到健康环境下的指标，协助后续实际使用中的监控、优化；<br>3、模拟多用户并发访问MySQL来进行压力测试，找出系统的扩张瓶颈，增加数据库的并发，观察QPS、TPS变化，确定并发量与性能最优的关系；<br>4、对比多个存储引擎（MyISAM，InnoDB等）在相同环境下的相同并发压力下的性能差别。</p>
<h2 id="二、测试计划"><a href="#二、测试计划" class="headerlink" title="二、测试计划"></a>二、测试计划</h2><p>1、确定测试工具，根据测试目标和业务制定测试计划、测试场景、测试命令；<br>2、使用生产环境的数据库备份，根据测试用例进行测试；<br>3、分析测试结果。</p>
<h2 id="三、简介mysqlslap"><a href="#三、简介mysqlslap" class="headerlink" title="三、简介mysqlslap"></a>三、简介mysqlslap</h2><p>mysqlslap是版本高于5.1的mysql自带的工具。</p>
<p>【参数说明】<br>-a<br>//若命令中没通过语句或文件提供SQL表和数据，则将自动创建SQL表和数据</p>
<p>–auto-generate-sql-add-autoincrement<br>//给自动创建的表添加一个auto_increment列</p>
<p>–auto-generate-sql-execute-number=N<br>//对每个模拟用户的自动生成N次查询</p>
<p>–auto-generate-sql-guid-primary<br>//给自动创建的表添加基于GUID的主键</p>
<p>–auto-generate-sql-load-type=name<br>//指定测试语句类型：mixed（查询与插入对半）,update（更新主键）,write（插入）,key（读主键）或read（查询），默认为mixed</p>
<p>–auto-generate-sql-secondary-indexes=N<br>//给自动创建的表增加N个二级索引，默认为0</p>
<p>–auto-generate-sql-unique-query-number=N<br>//指定自动创建的表中不同查询的数量</p>
<p>–auto-generate-sql-unique-write-number=N<br>//指定自动创建的表中不同插入的数量</p>
<p>–auto-generate-sql-write-number=N<br>//自动创建的表中，对每个线程插入N行数据（默认N为100）</p>
<p>–commit=N<br>//每N条DML提交一次（即一次事务）</p>
<p>-C，–compress<br>//若server和client的协议都支持压缩，则压缩信息后传送</p>
<p>-c N,–concurrency-name<br>/模拟N个用户并发执行查询</p>
<p>–create=”字符串或.sql文件路径”<br>//指定用来创建表的字符串或 .sql文件</p>
<p>–create-schema=”数据库名”<br>指定测试用的数据库（mysql中的database就是schema）</p>
<p>-#，–debug<br>–debug-check<br>-T,–debug-info //输出CPU以及内存的相关信息<br>【遇到 [Error]mysqlslap：option ‘…’ used,but is disabled，暂时无法解决】</p>
<p>-F,–delimiter=name<br>此参数指定的值作为sql语句中使用的分隔符</p>
<p>–detach=N<br>每执行完N条请求，就断开重连一次</p>
<p>-e,–engine=name<br>指定测试表使用的存储引擎</p>
<p>-h,–host=name<br>连接指定host</p>
<p>-i,–iterations=N<br>指定测试迭代次数</p>
<p>-x,–number-char-cols=N<br>指定自动创建的表中含N个char类型的字段，默认值为1</p>
<p>-y,–number-int-cols=N<br>指定自动创建的表中含N个int类型的字段，默认值为1</p>
<p>–number-of-queries=N<br>生成N次总查询（平均每个用户查询次数=总查询次数/并发数）</p>
<p>–only-print<br>不实际执行，打印模拟执行的过程</p>
<p>-u,–user=name<br>连接server用的用户名</p>
<p>-p,–password[=name]<br>连接server用的密码，参数与值之间没有空格，如-p123</p>
<p>-P，–port=端口号<br>指定连接server的端口</p>
<p>–post（/pre）-query=name<br>指定测试完成后（/前）执行的含sql语句的字符串或.sql文件</p>
<p>–post（/pre）-system=name<br>指定测试完成后（/前）执行的系统语句</p>
<p>–protocol=name<br>指定用来连接的协议：tcp,socket,pipe,memory</p>
<p>-q “查询语句或包含查询语句的sql文件”,–query=”查询语句或包含查询语句的sql文件”<br>自定义要运行的查询语句</p>
<p>–defaults-file=”配置文件路径”<br>指定.cnf配置文件</p>
<p>【注意】<br>不用-a自动生成数据表或自定义指定，就会报1049 error；<br>命令行中，参数–number-of-queries=N（N为总查询次数）和–auto-generate-sql-execute-number=N（N为每个并发的查询次数）只能存在1个。</p>
<p><strong>常用参数</strong> </p>
<p>-a  若命令中没通过语句或文件提供SQL表和数据，则将自动创建SQL表和数据</p>
<h5 id="–concurrency：代表并发数量，多个用逗号隔开，concurrency-10-50-100-并发连接线程数分别是10、50、100个并发"><a href="#–concurrency：代表并发数量，多个用逗号隔开，concurrency-10-50-100-并发连接线程数分别是10、50、100个并发" class="headerlink" title="–concurrency：代表并发数量，多个用逗号隔开，concurrency=10,50,100, 并发连接线程数分别是10、50、100个并发"></a>–concurrency：代表并发数量，多个用逗号隔开，concurrency=10,50,100, 并发连接线程数分别是10、50、100个并发</h5><p>–engines：代表要测试的引擎，可以有多个，用分隔符隔开<br>–iterations：代表要运行这些测试多少次<br>–commit=N：执行N条DML后提交一次<br>–auto-generate-sql：代表用系统自己生成的SQL脚本来测试<br>–auto-generate-sql-load-type：代表要测试的是读还是写还是两者混合的（read,write,update,mixed）</p>
<h5 id="–number-of-queries：代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数-并发数来计算"><a href="#–number-of-queries：代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数-并发数来计算" class="headerlink" title="–number-of-queries：代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算"></a>–number-of-queries：代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算</h5><p>–debug-info：代表要额外输出CPU以及内存的相关信息<br>–number-int-cols ：创建测试表的 int 型字段数量<br>–auto-generate-sql-add-autoincrement ：代表对生成的表自动添加auto_increment列，从5.1.18版本开始<br>–number-char-cols：创建测试表的 char 型字段数量<br>–create-schema：测试的schema，MySQL中schema也就是database<br>–query：使用自定义脚本执行测试，例如可以调用自定义的一个存储过程或者sql语句来执行测试<br>–only-print：如果只想打印看看SQL语句是什么，可以用这个选项</p>
<h2 id="四、测试执行：一些栗子"><a href="#四、测试执行：一些栗子" class="headerlink" title="四、测试执行：一些栗子"></a>四、测试执行：一些栗子</h2><p>1）指定数据库‘test’，自定义sql语句，模拟50个并发用户进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlslap -uroot -p000000 -c 50  --create-schema=wzw -q &quot;select * from wzwapp_user;&quot;</span><br></pre></td></tr></table></figure>

<p>2) 自动设置默认查询语句</p>
<p><code>mysqlslap -uroot -p -a --concurrency=200 --number-of-queries=10000</code> </p>
<p>当我加大查询量的时候出现下面的错误 mysqlslap: Error when connecting to server: 1040 Too many connections</p>
<p><strong>参考</strong><a href="https://www.cnblogs.com/phpper/p/9570792.html" target="_blank" rel="noopener">https://www.cnblogs.com/phpper/p/9570792.html</a> </p>
<p> 解决步骤： 可能是如下两种情况 </p>
<p>一.查看系统最大限制# ulimit -n 系统的/etc/security/limits.conf 这里面的限制，把限制增大就可以了，前提不能超过系统的最大限制cat /proc/sys/fs/file-max</p>
<p> 二。mysql&gt; show variables like ‘%connections%’; 临时修改变量（重启mysql后失效，永久的话请修改my.cnf增加max_connections = 100000） mysql&gt; set global max_connections=100000; </p>
<h1 id="五，mysql优化技巧"><a href="#五，mysql优化技巧" class="headerlink" title="五，mysql优化技巧"></a>五，mysql优化技巧</h1><p>查看mysql存储引擎：show variables like ‘%storage_engine%’; </p>
<p>​        <a href="https://www.cnblogs.com/sharpest/p/10390035.html" target="_blank" rel="noopener">https://www.cnblogs.com/sharpest/p/10390035.html</a> </p>
<p>​        <a href="https://blog.csdn.net/skiwnc/article/details/87351038" target="_blank" rel="noopener">https://blog.csdn.net/skiwnc/article/details/87351038</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql慢查询</title>
    <url>/2020/02/08/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p>
<p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p>
<p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p>
<p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p>
<p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<p>慢查询日志支持将日志记录写入文件和数据库表。</p>
<p>官方文档，关于慢查询的日志介绍如下（部分资料，具体参考官方相关链接）：</p>
<h2 id="一-设置方法"><a href="#一-设置方法" class="headerlink" title="一. 设置方法"></a>一. 设置方法</h2><p>使用慢查询日志里捕获</p>
<p>启用之前需要先进行一些设置</p>
<p> 开启通用日志查询： set global general_log=on;</p>
<p>关闭通用日志查询： set global general_log=off;</p>
<p>设置通用日志输出为表方式： set global log_output=’TABLE’;</p>
<p>设置通用日志输出为文件方式： set global log_output=’FILE’;</p>
<p>设置通用日志输出为表和文件方式：set global log_output=’FILE,TABLE’;</p>
<h3 id="方法一：全局变量设置"><a href="#方法一：全局变量设置" class="headerlink" title="方法一：全局变量设置"></a>方法一：全局变量设置</h3><h4 id="设置慢查询日志的日志文件位置"><a href="#设置慢查询日志的日志文件位置" class="headerlink" title="设置慢查询日志的日志文件位置"></a>设置慢查询日志的日志文件位置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log_file = &quot;D:/slow_log/slow_log.log&quot; ;</span><br></pre></td></tr></table></figure>



<h4 id="设置是否对未使用索引的SQL进行记录"><a href="#设置是否对未使用索引的SQL进行记录" class="headerlink" title="设置是否对未使用索引的SQL进行记录"></a>设置是否对未使用索引的SQL进行记录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global log_queries_not_using_indexes = on;</span><br></pre></td></tr></table></figure>



<h4 id="设置只要SQL执行时间超过n秒的就记录"><a href="#设置只要SQL执行时间超过n秒的就记录" class="headerlink" title="设置只要SQL执行时间超过n秒的就记录"></a>设置只要SQL执行时间超过n秒的就记录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global long_query_time = 0.001 ;</span><br></pre></td></tr></table></figure>

<p>此处设置的0.001秒，便于测试，一般情况比这个大</p>
<h4 id="启用mysql慢查询日志"><a href="#启用mysql慢查询日志" class="headerlink" title="启用mysql慢查询日志"></a>启用mysql慢查询日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = on;</span><br></pre></td></tr></table></figure>



<h3 id="方法二：配置文件设置"><a href="#方法二：配置文件设置" class="headerlink" title="方法二：配置文件设置"></a>方法二：配置文件设置</h3><p>修改配置文件my.cnf，在[mysqld]下的下方加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">log_queries_not_using_indexes = ON;</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure>



<h3 id="查看设置后的参数"><a href="#查看设置后的参数" class="headerlink" title="查看设置后的参数"></a>查看设置后的参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;slow_query%&apos;;</span><br><span class="line">show variables like &apos;long_query__time&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="二-慢查询日志记录的内容"><a href="#二-慢查询日志记录的内容" class="headerlink" title="二. 慢查询日志记录的内容"></a>二. 慢查询日志记录的内容</h2><p><strong>more  /var/lib/mysql/izbp12xu0u9ja736dkjgcsz-slow.log</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 2019-01-08T04:12:09.269315Z </span><br><span class="line"># User@Host: h5_test[h5_test] @ localhost [::1]  Id:    12  </span><br><span class="line"># Query_time: 0.000831  Lock_time: 0.000198 Rows_sent: 1  Rows_examined: 3  </span><br><span class="line">use mc_productdb;</span><br><span class="line">SET timestamp=1546920729;</span><br><span class="line">SELECT t.customer_id,t.title,t.content </span><br><span class="line">FROM (</span><br><span class="line">SELECT customer_id  FROM product_comment WHERE  product_id =199726 AND audit_status = 1 LIMIT 0,15</span><br><span class="line">)a JOIN product_comment t </span><br><span class="line">ON a.customer_id = t.comment_id;</span><br></pre></td></tr></table></figure>

<p>Time：执行查询的日期时间<br>User@Host：执行查询的用户和客户端IP<br>Id：是执行查询的线程Id<br>Query_time：SQL执行所消耗的时间<br>Lock_time：执行查询对记录锁定的时间<br>Rows_sent：查询返回的行数<br>Rows_examined：为了返回查询的数据所读取的行数</p>
<p>4 mysqldumpslow工具<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活。</p>
<p>MySQL提供了日志分析工具mysqldumpslow</p>
<p>查看mysqldumpslow的帮助信息：</p>
<p>[root@DB-Server ~]# mysqldumpslow –help<br> Usage: mysqldumpslow [ OPTS… ][ LOGS… ]</p>
<p>Parse and summarize the MySQL slow query log. Options are</p>
<p>  –verbose    verbose<br>  –debug      debug<br>  –help       write this text to standard output</p>
<p>  -v           verbose<br>  -d           debug<br>  -s ORDER     what to sort by (al, at, ar, c, l, r, t), ‘at’ is default（排序方式）<br>                 al: average lock time（平均锁定时间）<br>                 ar: average rows sent（平均返回记录数）<br>                 at: average query time（平均查询时间）<br>                  c: count（访问计数）<br>                  l: lock time（锁定时间）<br>                  r: rows sent（返回记录）<br>                  t: query time（查询时间）<br>   -r           reverse the sort order (largest last instead of first)<br>   -t NUM       just show the top n queries（返回前面n条数据）<br>   -a           don’t abstract all numbers to N and strings to ‘S’<br>   -n NUM       abstract numbers with at least n digits within names<br>   -g PATTERN   grep: only consider stmts that include this string（正则匹配模式，大小写不敏感）<br>   -h HOSTNAME  hostname of db server for <em>-slow.log filename (can be wildcard),<br>                default is ‘</em>‘, i.e. match all<br>   -i NAME      name of server instance (if using mysql.server startup script)<br>   -l           don’t subtract lock time from total time</p>
<p>比如，得到返回记录集最多的10个SQL。</p>
<p>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log<br>得到访问次数最多的10个SQL</p>
<p>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log<br>得到按照时间排序的前10条里面含有左连接的查询语句。</p>
<p>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log<br>另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</p>
<p>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的常用命令</title>
    <url>/2020/02/08/mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="MYSQL常用命令"><a href="#MYSQL常用命令" class="headerlink" title="MYSQL常用命令"></a>MYSQL常用命令</h1><h6 id="1-导出整个数据库"><a href="#1-导出整个数据库" class="headerlink" title="1.导出整个数据库"></a>1.导出整个数据库</h6><p>​    mysqldump -u 用户名 -p –default-character-set=latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1)  </p>
<p>​    mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql  </p>
<h6 id="2-导出一个表"><a href="#2-导出一个表" class="headerlink" title="2.导出一个表"></a>2.导出一个表</h6><p>​    mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名  </p>
<p>​    mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql  </p>
<h6 id="3-导出一个数据库结构"><a href="#3-导出一个数据库结构" class="headerlink" title="3.导出一个数据库结构"></a>3.导出一个数据库结构</h6><p>​    mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql  </p>
<p>​    -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table  </p>
<h6 id="4-导入数据库"><a href="#4-导入数据库" class="headerlink" title="4.导入数据库"></a>4.导入数据库</h6><p>​    A:常用source 命令  </p>
<p>​        进入mysql数据库控制台，  </p>
<p>​        如mysql -u root -p  </p>
<p>​        mysql&gt;use 数据库  </p>
<p>​        然后使用source命令，后面参数为脚本文件(如这里用到的.sql)  </p>
<p>​        mysql&gt;source wcnc_db.sql  </p>
<p>​    B:使用mysqldump命令  </p>
<p>​        mysqldump -u username -p dbname &lt; filename.sql  </p>
<p>​    C:使用mysql命令  </p>
<p>​        mysql -u username -p -D dbname &lt; filename.sql  </p>
<h3 id="一、启动与退出"><a href="#一、启动与退出" class="headerlink" title="一、启动与退出"></a>一、启动与退出</h3><p>​    1、进入MySQL：启动MySQL Command Line Client（MySQL的DOS界面），直接输入安装时的密码即可。此时的提示符是：mysql&gt;  </p>
<p>​    2、退出MySQL：quit或exit  </p>
<h3 id="二、库操作"><a href="#二、库操作" class="headerlink" title="二、库操作"></a>二、库操作</h3><h6 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h6><p>命令：create database &lt;数据库名&gt;  </p>
<p>​    例如：建立一个名为xhkdb的数据库  </p>
<p>​        mysql&gt; create database xhkdb;  </p>
<h6 id="2、显示所有数据库"><a href="#2、显示所有数据库" class="headerlink" title="2、显示所有数据库"></a>2、显示所有数据库</h6><p>命令：show databases （注意：最后有个s）  </p>
<p>​    mysql&gt; show databases;  </p>
<h6 id="3、删除数据库"><a href="#3、删除数据库" class="headerlink" title="3、删除数据库"></a>3、删除数据库</h6><p>命令：drop database &lt;数据库名&gt;  </p>
<p>​    例如：删除名为 xhkdb的数据库  </p>
<p>​        mysql&gt; drop database xhkdb;  </p>
<h6 id="4、连接数据库"><a href="#4、连接数据库" class="headerlink" title="4、连接数据库"></a>4、连接数据库</h6><p>命令：use &lt;数据库名&gt;  </p>
<p>​    例如：如果xhkdb数据库存在，尝试存取它：  </p>
<p>​        mysql&gt; use xhkdb;  </p>
<p>​        屏幕提示：Database changed  </p>
<h6 id="5、查看当前使用的数据库"><a href="#5、查看当前使用的数据库" class="headerlink" title="5、查看当前使用的数据库"></a>5、查看当前使用的数据库</h6><p>​    mysql&gt; select database();  </p>
<h6 id="6、当前数据库包含的表信息："><a href="#6、当前数据库包含的表信息：" class="headerlink" title="6、当前数据库包含的表信息："></a>6、当前数据库包含的表信息：</h6><p>​    mysql&gt; show tables; （注意：最后有个s）  </p>
<h3 id="三、表操作，操作之前应连接某个数据库"><a href="#三、表操作，操作之前应连接某个数据库" class="headerlink" title="三、表操作，操作之前应连接某个数据库"></a>三、表操作，操作之前应连接某个数据库</h3><h6 id="1、建表"><a href="#1、建表" class="headerlink" title="1、建表"></a>1、建表</h6><p>​    命令：create table &lt;表名&gt; ( &lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]);  </p>
<p>​        mysql&gt; create table MyClass(  </p>
<p>​            &gt; id int(4) not null primary key auto_increment,  </p>
<p>​            &gt; name char(20) not null,  </p>
<p>​            &gt; sex int(4) not null default ’′,  </p>
<p>​            &gt; degree double(16,2));  </p>
<h6 id="2、获取表结构"><a href="#2、获取表结构" class="headerlink" title="2、获取表结构"></a>2、获取表结构</h6><p>​    命令：desc 表名，或者show columns from 表名  </p>
<p>​        mysql&gt;DESCRIBE MyClass  </p>
<p>​            mysql&gt; desc MyClass;  </p>
<p>​            mysql&gt; show columns from MyClass;  </p>
<h6 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h6><p>​    命令：drop table &lt;表名&gt;  </p>
<p>​        例如：删除表名为 MyClass 的表  </p>
<p>​            mysql&gt; drop table MyClass;  </p>
<h6 id="4、插入数据"><a href="#4、插入数据" class="headerlink" title="4、插入数据"></a>4、插入数据</h6><p>​    命令：insert into &lt;表名&gt; [( &lt;字段名&gt;[,..&lt;字段名n &gt; ])] values ( 值 )[, ( 值n )]  </p>
<p>​        例如，往表 MyClass中插入二条记录, 这二条记录表示：编号为的名为Tom的成绩                                 为.45, 编    号为 的名为Joan 的成绩为.99，编号为 的名为Wang 的成绩为.5.  </p>
<p>​            mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’,             96.59);  </p>
<h6 id="5、查询表中的数据"><a href="#5、查询表中的数据" class="headerlink" title="5、查询表中的数据"></a>5、查询表中的数据</h6><p>​    1)、查询所有行  </p>
<p>​        命令：select &lt;字段，字段，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;  </p>
<p>​        例如：查看表 MyClass 中所有数据  </p>
<p>​            mysql&gt; select  from MyClass;  </p>
<p>​    2）、查询前几行数据  </p>
<p>​        例如：查看表 MyClass 中前行数据  </p>
<p>​            mysql&gt; select  from MyClass order by id limit 0,2;  </p>
<p>​        或者：  </p>
<p>​            mysql&gt; select  from MyClass limit 0,2;  </p>
<h6 id="6、删除表中数据"><a href="#6、删除表中数据" class="headerlink" title="6、删除表中数据"></a>6、删除表中数据</h6><p>​        命令：delete from 表名 where 表达式  </p>
<p>​            例如：删除表 MyClass中编号为 的记录  </p>
<p>​                mysql&gt; delete from MyClass where id=1;  </p>
<h6 id="7、修改表中数据：update-表名-set-字段-新值-…where-条件"><a href="#7、修改表中数据：update-表名-set-字段-新值-…where-条件" class="headerlink" title="7、修改表中数据：update 表名 set 字段=新值,…where 条件"></a>7、修改表中数据：update 表名 set 字段=新值,…where 条件</h6><p>​        mysql&gt; update MyClass set name=’Mary’where id=1;  </p>
<h6 id="8、在表中增加字段："><a href="#8、在表中增加字段：" class="headerlink" title="8、在表中增加字段："></a>8、在表中增加字段：</h6><p>​        命令：alter table 表名 add字段 类型 其他;  </p>
<p>​            例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为  </p>
<p>​                mysql&gt; alter table MyClass add passtest int(4) default ’′  </p>
<h6 id="9、更改表名："><a href="#9、更改表名：" class="headerlink" title="9、更改表名："></a>9、更改表名：</h6><p>​        命令：rename table 原表名 to 新表名;  </p>
<p>​            例如：在表MyClass名字更改为YouClass  </p>
<p>​                mysql&gt; rename table MyClass to YouClass;  </p>
<p>​            更新字段内容  </p>
<p>​                update 表名 set 字段名 = 新内容  </p>
<p>​                update 表名 set 字段名 = replace(字段名,’旧内容’,’新内容’)  </p>
<p>​                update article set content=concat(‘　　’,content); </p>
<h1 id="MYSQL查看正在运行的SQL"><a href="#MYSQL查看正在运行的SQL" class="headerlink" title="MYSQL查看正在运行的SQL"></a>MYSQL查看正在运行的SQL</h1><p>有2个方法：</p>
<h6 id="1、使用processlist"><a href="#1、使用processlist" class="headerlink" title="1、使用processlist"></a>1、使用processlist</h6><p>​    但是有个弊端，就是只能查看正在执行的sql语句，对应历史记录，查看不到。好处是不用设置，不会保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- use information_schema;</span><br><span class="line">-- show processlist;</span><br><span class="line">或者：</span><br><span class="line">-- select * from information_schema.`PROCESSLIST` where info is not null;</span><br></pre></td></tr></table></figure>

<h6 id="2、开启日志模式"><a href="#2、开启日志模式" class="headerlink" title="2、开启日志模式"></a>2、开启日志模式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、设置</span><br><span class="line">-- SET GLOBAL log_output = &apos;TABLE&apos;;  SET GLOBAL general_log = &apos;ON&apos;;</span><br><span class="line">-- SET GLOBAL log_output = &apos;TABLE&apos;;  SET GLOBAL general_log = &apos;OFF&apos;;</span><br><span class="line"></span><br><span class="line">-- 2、查询</span><br><span class="line">SELECT * from mysql.general_log ORDER BY    event_time DESC</span><br><span class="line"></span><br><span class="line">-- 3、清空表（delete对于这个表，不允许使用，只能用truncate）</span><br><span class="line">-- truncate table mysql.general_log;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>reids发布者订阅者键空间事件</title>
    <url>/2020/02/08/reids%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="发布者与订阅者（pub-sub）"><a href="#发布者与订阅者（pub-sub）" class="headerlink" title="发布者与订阅者（pub/sub）"></a>发布者与订阅者（pub/sub）</h2><p>发布和订阅<code>pub/sub</code>，订阅者负责订阅频道，发送者负责像频道发送二进制字符串消息，每当有消息发布到订阅的这个频道，那么所有的订阅者都可以收到这个消息，发布订阅也是像是我们生活中的电台，订阅者可以订阅收听多个电台，而发送者可以再任何电台发送消息</p>
<h3 id="发布，订阅常用命令"><a href="#发布，订阅常用命令" class="headerlink" title="发布，订阅常用命令"></a>发布，订阅常用命令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE CHANNLE</td>
<td>订阅给定的一个或多个频道</td>
</tr>
<tr>
<td>UNSUBSCRIBE CHANNLE</td>
<td>退订一个或多个频道，如果没有指定具体退订的频道，那么是全部退订</td>
</tr>
<tr>
<td>PSUBSCRIBE PATTERN</td>
<td>订阅与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>PUNSUBSCRIBE PATTERN</td>
<td>退订给定的模式相匹配的频道，未指定，则退订所有</td>
</tr>
<tr>
<td>PUBLISH CHANNLE MESSAGE</td>
<td>向给定频道发送消息</td>
</tr>
</tbody></table>
<h2 id="键空间事件"><a href="#键空间事件" class="headerlink" title="键空间事件"></a>键空间事件</h2><h3 id="键空间事件通知"><a href="#键空间事件通知" class="headerlink" title="键空间事件通知"></a>键空间事件通知</h3><p>在<code>Redis</code>里面有一些事件，比如键<strong>到期</strong>、键被<strong>删除</strong>等。可以通过打开<code>redis</code>键空间事件通知来让 Redis 一旦触发这些事件的时候就往特定的<code>Channel</code>推一条消息</p>
<h3 id="键事件通知配置"><a href="#键事件通知配置" class="headerlink" title="键事件通知配置"></a>键事件通知配置</h3><ul>
<li>默认在<code>redis</code>中，键事件通知是不打开的，需要我们手动配置，具体的选项如下，默认他是个空字符串，代表关闭状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>K</td>
<td>键空间通知，所有通知以<code>__keyspace@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td>E</td>
<td>键事件通知，所有通知以<code>__keyevent@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td>g</td>
<td><code>DEL</code>、<code>EXPIRE</code>、<code>RENAME</code>等类型无关的通用命令的通知</td>
</tr>
<tr>
<td>$</td>
<td>字符串命令的通知</td>
</tr>
<tr>
<td>l</td>
<td>列表命令的通知</td>
</tr>
<tr>
<td>s</td>
<td>集合命令的通知</td>
</tr>
<tr>
<td>h</td>
<td>哈希命令的通知</td>
</tr>
<tr>
<td>z</td>
<td>有序集合命令的通知</td>
</tr>
<tr>
<td>x</td>
<td>过期事件：每当有过期键被删除时发送</td>
</tr>
<tr>
<td>e</td>
<td>驱逐<code>(evict)</code>事件：每当有键因为<code>maxmemory</code>政策而被删除时发送</td>
</tr>
<tr>
<td>A</td>
<td>参数<code>g$lshzxe</code>的别名</td>
</tr>
</tbody></table>
<p>注意，该选项的值中至少需要包含K或者E，否则不会发布任何事件。比如，如果需要开启针对列表的keyspace事件通知，则该选项需要配置为“Kl”； </p>
<h3 id="键空间和键事件"><a href="#键空间和键事件" class="headerlink" title="键空间和键事件"></a>键空间和键事件</h3><blockquote>
<p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件</p>
<p>比如说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL</code>命令时， 系统将分发两条消息， 相当于执行以下两个<code>PUBLISH</code>命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__keyspace@0__:mykey</code>：接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件</li>
<li><code>__keyevent@0__:del</code>：接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</li>
</ul>
<blockquote>
<p><code>keyspace</code>为前缀的频道被称为键空间通知<code>key-space notification</code></p>
</blockquote>
<blockquote>
<p><code>keyevent</code>为前缀的频道则被称为键事件通知<code>key-event notification</code></p>
</blockquote>
<ul>
<li>订阅<strong>键空间频道</strong>，监控被执行事件的键，如监控<code>mykey</code>；那么此时将接收到该键所对应的事件：<code>del</code></li>
<li>订阅<strong>键事件频道</strong>，监控某个事件，如<code>del</code>；那么<code>del</code>事件触发时，订阅者收到：<code>mykey</code></li>
</ul>
<h3 id="过期的键事件通知"><a href="#过期的键事件通知" class="headerlink" title="过期的键事件通知"></a>过期的键事件通知</h3><ul>
<li>过期的键事件通知常用在订单过期通知等场景下，此时只需要订阅对应<strong>过期事件</strong>的频道，当某键触发过期事件时，即可接受到对应<strong>过期键</strong>的消息</li>
<li><code>redis</code>配置如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;Ex&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Python</code>代码的简单示范，订阅过期频道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">import time</span><br><span class="line">redis = redis.Redis(host=&apos;123.57.61.168&apos;, port=6379)</span><br><span class="line">pubsub = redis.pubsub()</span><br><span class="line">pubsub.psubscribe(&apos;__keyevent@0__:expired&apos;) # 订阅过期事件频道</span><br><span class="line">print(&apos;Starting message loop&apos;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        message = pubsub.get_message()</span><br><span class="line">        if message:</span><br><span class="line">            print(message)</span><br><span class="line">        else:</span><br><span class="line">            time.sleep(0.01)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        # CTRL + C</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<ul>
<li>那么当此时执行此段代码，另起<code>redis</code>客户端，设置一个可以过期的<code>key</code>值，来看一下效果</li>
</ul>
<p><img src="https://lienze.tech/blog/images/%E9%94%AE%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5.gif" alt="键过期事件通知"></p>
<h3 id="不同命令产生的事件通知"><a href="#不同命令产生的事件通知" class="headerlink" title="不同命令产生的事件通知"></a>不同命令产生的事件通知</h3><p>​            DEL 命令为每个被删除的键产生一个 del 事件；</p>
<pre><code>RENAME 产生两个事件：为源键产生一个 rename_from 事件，并为目标键产生一个 rename_to 事件；

EXPIRE命令，在设置键的过期时间时产生一个 expire事件；当键因过期而被删除时，产生一个 expired事件；

SORT命令，在带有 STORE 参数时产生一个 sortstore事件。如果 STORE 指示的用于保存排序结果的键已经存在，则原键会被删除，因此还会产生一个 del 事件；

SET 以及它的所有变种(SETEX、SETNX和GETSET)都产生set事件。另外，SETEX命令还会产生expire 事件；

MSET 命令，为每个键产生一个 set 事件；

SETRANGE 产生一个 setrange 事件；

INCR 、DECR、INCRBY和DECRBY都产生 incrby 事件；

INCRBYFLOAT产生incrbyfloat事件；

APPEND产生append事件；

LPUSH和LPUSHX都产生单个 lpush 事件，即使有多个输入元素时，也是如此；

RPUSH 和 RPUSHX 都产生单个rpush事件，即使有多个输入元素时，也是如此；

RPOP 产生 rpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；

LPOP 产生 lpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；

LINSERT 产生一个 linsert 事件；

LSET 产生一个 lset 事件；

LREM产生一个lrem事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；

LTRIM 产生一个ltrim事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；

RPOPLPUSH 和 BRPOPLPUSH 产生一个 rpop 事件，以及一个 lpush 事件。两个命令都保证rpop事件在 lpush 事件之前发出。如果弹出元素之后，列表键被清空，则还会产生一个 del 事件；

HSET 、 HSETNX 和 HMSET 都只产生一个 hset 事件；

HINCRBY 产生一个 hincrby 事件；

HINCRBYFLOAT 产生一个 hincrbyfloat 事件；

HDEL 产生一个 hdel 通知。如果执行该命令之后，哈希键被清空，则还会产生一个del事件；

SADD 产生一个 sadd 事件，即使有多个输入元素时，也是如此；

SREM 产生一个 srem 事件，如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；

SMOVE 为源键产生一个 srem 事件，并为目标键产生一个sadd 事件；

SPOP 产生一个 spop 事件。如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；

SINTERSTORE、SUNIONSTORE和SDIFFSTORE分别产生 sinterstore、sunionostore和sdiffstore 三种事件。如果用于保存结果的键已经存在，则还会产生一个 del 事件；

ZINCR产生一个 zincr 事件；

ZADD 产生一个 zadd事件，即使有多个输入元素时，也是如此；

ZREM 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM 之后，有序集合键被清空，则还会产生一个 del 事件；

ZREMEBYSCORE 产生一个 zrembyscore事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。

ZREMBYRANK 产生一个 zrembyrank事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。

ZINTERSTORE 和 ZUNIONSTORE 分别产生 zinterstore 和 zunionstore 两种事件。如果用于保存结果的键已经存在，那么还会产生一个 del 事件。

每当一个键因为过期而被删除时，产生一个 expired 事件。

每当一个键因为 maxmemory策略而被删除并回收内存时，产生一个 evicted 事件。



注意：所有命令都只在键真的被改动了之后，才会产生事件通知。比如，当srem命令试图删除不存在于集合的元素时，删除操作执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</code></pre><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1：Redis发布所有通知，客户端A订阅所有消息：</p>
<p>127.0.0.1:6379&gt; config set notify-keyspace-events KEA<br>OK<br>127.0.0.1:6379&gt; psubscribe <strong>key*@0</strong>:*<br>Reading messages… (press Ctrl-C to quit)<br>1) “psubscribe”<br>2) “<strong>key*@0</strong>:*”<br>3) (integer) 1<br>         然后，在客户端B上执行set和del命令：</p>
<p>127.0.0.1:6379&gt; set msg “hello”<br>OK<br>127.0.0.1:6379&gt; del msg<br>(integer) 1<br>127.0.0.1:6379&gt; del msg<br>(integer) 0<br>         然后客户端A的打印如下：</p>
<p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “set”<br>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyevent@0</strong>:set”<br>4) “msg”</p>
<p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “del”<br>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyevent@0</strong>:del”<br>4) “msg”<br>         可见，针对每一个操作，客户端A都收到了两种消息，分别是keyspace和keyevent消息。</p>
<p>2：使Redis仅发布keyspace通知，而客户端A订阅所有消息类型：</p>
<p>127.0.0.1:6379&gt; config set notify-keyspace-events KA<br>OK<br>127.0.0.1:6379&gt; psubscribe <strong>key*@0</strong>:*<br>Reading messages… (press Ctrl-C to quit)<br>1) “psubscribe”<br>2) “<strong>key*@0</strong>:*”<br>3) (integer) 1<br>         在客户端B上执行，与上面同样的步骤。此时，客户端A上的打印：</p>
<p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “set”</p>
<p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “del”<br>         可见，尽管客户端A订阅了所有消息，但是Redis仅发布了keyspace事件。而且，在客户端B上执行了两次del操作，而只有第一个del成功执行了，从而产生了一个事件。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>聚集索引和非聚集索引</title>
    <url>/2020/02/08/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="MySQL聚集索引和非聚集索引"><a href="#MySQL聚集索引和非聚集索引" class="headerlink" title="MySQL聚集索引和非聚集索引"></a>MySQL聚集索引和非聚集索引</h3><p><strong>正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引；</strong></p>
<p>Innodb存储引擎中行记录就是按照<strong>聚集索引维度顺序</strong>存储的，Innodb的表也称为<strong>索引表</strong>；因为行记录只能按照一个维度进行排序，所以一张表只能有一个聚集索引。</p>
<p><strong>非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的；</strong></p>
<p>举个例子说明下：</p>
<p>create table student (</p>
<p><code>id</code> INT UNSIGNED AUTO_INCREMENT,</p>
<p><code>name</code> VARCHAR(255),</p>
<p>PRIMARY KEY(<code>id</code>),</p>
<p>KEY(<code>name</code>)</p>
<p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p><strong>该表中主键id是该表的聚集索引、name为非聚集索引；</strong>表中的每行数据都是按照<strong>聚集索引id排序存储的</strong>；比如要查找name=’Arla’和name=’Arle’的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远。<strong>name索引表节点按照name排序，检索的是每一行数据的主键。聚集索引表按照主键id排序，检索的是每一行数据的真实内容。</strong></p>
<p>也就是说查询name=’Arle’的记录时，首相通过name索引表查找到Arle的主键id（可能有多个主键id，因为有重名的同学），再根据主键id的聚集索引找到相应的行记录；</p>
<p><strong>聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。</strong></p>
<p>每张表只有<strong>一个聚集索引</strong>，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）。</p>
<p>从宏观上分析下聚集索引和普通索引的性能差异，还是针对上述student表：</p>
<p>（1）select * from student where id &gt;5000 and id &lt;20000;</p>
<p>（2）select * from student where name &gt; ‘Alie’ and name &lt; ‘John’;</p>
<p>第一条SQL语句根据id进行范围查询，因为(5000, 20000)范围内的记录在磁盘上按顺序存储，顺序读取磁盘很快就能读到这批数据。</p>
<p>第二条SQL语句查询（’Alie’, ‘John’）范围内的记录，主键id分布可能是离散的1，100，20001，5000…..；增加了随机读取数据页几率；所以普通索引的范围查询效率被聚集索引甩开几条街都不止；非聚集索引的精确查询效率还是可以的，比聚集索引查询只增加了一次IO开销。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL底层的B树B+树</title>
    <url>/2020/02/08/MySQL%E5%BA%95%E5%B1%82%E7%9A%84B%E6%A0%91B-%E6%A0%91/</url>
    <content><![CDATA[<h3 id="MySQL底层的B树和B-数"><a href="#MySQL底层的B树和B-数" class="headerlink" title="MySQL底层的B树和B+数"></a>MySQL底层的B树和B+数</h3><h2 id="01-B树"><a href="#01-B树" class="headerlink" title="01 B树"></a>01 B树</h2><h3 id="1-1-B树概念"><a href="#1-1-B树概念" class="headerlink" title="1.1 B树概念"></a>1.1 B树概念</h3><p>B树也称B-树,它是一颗<strong>多路平衡查找树</strong>。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的，并没有什么神秘的地方，下面我们来看看B树的定义。</p>
<ul>
<li>每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li>
<li>根节点最少可以只有1个<strong>关键字</strong>。</li>
<li>非根节点至少有m/2个<strong>关键字</strong>。</li>
<li>每个节点中的关键字都按照<strong>从小到大</strong>的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>
<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li>
<li>每个节点都存有索引和数据，也就是对应的key和value。</li>
</ul>
<p>所以，根节点的<strong>关键字</strong>数量范围：<code>1 &lt;= k &lt;= m-1</code>，非根节点的<strong>关键字</strong>数量范围：<code>m/2 &lt;= k &lt;= m-1</code>。<br>另外，我们需要注意一个概念，描述一颗B树时<strong>需要指定它的阶数</strong>，阶数表示了<strong>一个节点最多有多少个孩子节点</strong>，一般用字母m表示阶数。<br>我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 &lt;= k &lt;= 4，非根节点数量范围：2 &lt;= k &lt;= 4。<br>下面，我们通过一个插入的例子，讲解一下B树的插入过程，接着，再讲解一下删除关键字的过程。</p>
<h3 id="1-2-B树插入"><a href="#1-2-B树插入" class="headerlink" title="1.2 B树插入"></a>1.2 B树插入</h3><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p>
<p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p>
<ul>
<li>插入18，70，50,40</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b4f5dc1d1bf60ec3d2b431a08ecb5cbc_hd.jpg" alt="img"></p>
<ul>
<li>插入22</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-c75ce532b1a0de70a46addcbeb3eaad8_hd.jpg" alt="img"></p>
<p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p>
<p><img src="https://pic2.zhimg.com/80/v2-af9426b0bea00785aca8233750acf059_hd.jpg" alt="img"></p>
<ul>
<li>接着插入23，25，39</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-e2dce90ee182b4a9a2dfc50baf4c4b75_hd.jpg" alt="img"></p>
<p>分裂，得到下面的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a4d98275d5295fe4b20f74af61edeb64_hd.jpg" alt="img"></p>
<h3 id="1-3-B树的删除操作"><a href="#1-3-B树的删除操作" class="headerlink" title="1.3 B树的删除操作"></a>1.3 B树的删除操作</h3><p>B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。</p>
<ul>
<li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-d667e9bfbb439ed3aa02c6c58aa9c3cc_hd.jpg" alt="img"></p>
<ul>
<li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-ec6a9d20c73edccdc7399a94be2b990d_hd.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9ca16f6b7de12a09300d68425c53ecd8_hd.jpg" alt="img"></p>
<ul>
<li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b42631e43d99ca679dacae61e5f6d12c_hd.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-772635b378f840d16f0583995139a4bd_hd.jpg" alt="img"></p>
<p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p>
<p>我们看看操作过程就更加明白了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-14d47bbc49f7241ba96c24403075072d_hd.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-231ddbb155462cd674c37b00370f233f_hd.jpg" alt="img"></p>
<p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p>
<h2 id="02-B-树"><a href="#02-B-树" class="headerlink" title="02 B+树"></a>02 B+树</h2><h3 id="2-1-B-树概述"><a href="#2-1-B-树概述" class="headerlink" title="2.1 B+树概述"></a>2.1 B+树概述</h3><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点：</strong></p>
<ul>
<li>根节点至少一个元素</li>
<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>B+树有两种类型的节点：<strong>内部结点</strong>（也称<strong>索引结点</strong>）和<strong>叶子结点</strong>。内部节点就是非叶子节点，内部节点不存储数据，<strong>只存储索引</strong>，<strong>数据</strong>都存储在叶子节点。</li>
<li>内部结点中的key都按照<strong>从小到大的顺序排列</strong>，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li>
<li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身<strong>依关键字的大小自小而大顺序链接</strong>。</li>
<li>父节点存有右孩子的第一个元素的索引。</li>
</ul>
<p>下面我们看一个B+树的例子，感受感受它吧！</p>
<p><img src="https://pic2.zhimg.com/80/v2-4d76b42872b98964a33930f00307ef75_hd.jpg" alt="img"></p>
<h3 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h3><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p>
<p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p>
<ul>
<li>插入5，10，15，20</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-cc558b9acd550ddf81417dba5ad9f618_hd.jpg" alt="img"></p>
<ul>
<li>插入25，此时元素数量大于4个了，分裂</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b450f0e6300f84ac626874d476677e87_hd.jpg" alt="img"></p>
<ul>
<li>接着插入26，30，继续分裂</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-59220cf7096626c8e62a2715bb919ded_hd.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8b1e35e12cdeb3b29af8b5f1ea8e2015_hd.jpg" alt="img"></p>
<p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p>
<h3 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h3><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p>
<ul>
<li>初始状态</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ce2b8eff8c1b35cb01eb43891e1ac97e_hd.jpg" alt="img"></p>
<ul>
<li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-c795a94ed5c7123dcadfe228b015f1a4_hd.jpg" alt="img"></p>
<ul>
<li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ab509486fc34208bdce4eef6fc9d365e_hd.jpg" alt="img"></p>
<ul>
<li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-0338708bbaccb594a48e731d0dacdb46_hd.jpg" alt="img"></p>
<p>这样，B+树的删除操作也就完成了</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化云计算</title>
    <url>/2020/02/08/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h3 id="虚拟化、云计算概念："><a href="#虚拟化、云计算概念：" class="headerlink" title="虚拟化、云计算概念："></a>虚拟化、云计算概念：</h3><p>美国环境保护署（EPA）报告的一组有趣的统计数据。</p>
<p>EPA研究服务器和数据中心的能源效率时发现，实际上服务器只有5%的时间在工作。在其他时间，服务器都处于 “休眠” 状态。就是说只有5%的消耗属于服务性能的消耗，其他都属于自己的无用消耗。</p>
<p>####什么是虚拟化：</p>
<p>虚拟化是指通过虚拟化技术奖一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间运行而互不影响，从而显著提高计算机的工作效率。</p>
<p>虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的鼎泰分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。</p>
<h4 id="虚拟化技术的应用价值："><a href="#虚拟化技术的应用价值：" class="headerlink" title="虚拟化技术的应用价值："></a>虚拟化技术的应用价值：</h4><p><strong>虚拟化前</strong></p>
<p><img src="//dingyifan.tech/2020/02/08/虚拟化云计算/C:%5CUsers%5Clenovo%5CDesktop%5C1576409487(1).png" alt="1576409487(1)"></p>
<ul>
<li><p><strong>资源浪费</strong></p>
<p>系统资源的利用率不高，</p>
<p>有的服务器长期空闲，</p>
<p>有的服务器超负荷为运转</p>
</li>
<li><p><strong>管理难度大</strong>（设备多）</p>
<p>服务器、路由、防火墙等设备数量众多，管理难度大。</p>
</li>
<li><p><strong>重复劳动</strong></p>
<p>经常性的重装、重做系统，调试网络设备等</p>
</li>
<li><p><strong>参数配置繁琐</strong></p>
<p>调整单台服务器CPU内存、硬盘大小等流程繁琐</p>
</li>
<li><p><strong>安全性差</strong></p>
<p>每台主机一个独立的操作系统，当安装一个完整的LAMP环境时，apache和mysql的资源是共享的，会造成安全性的问题。当Apache爆发漏洞时，可能会导致mysql的数据泄露。</p>
</li>
</ul>
<p><strong>虚拟化后：</strong></p>
<ul>
<li><p><strong>高利用率</strong></p>
<p>将分散、独立的服务器资源整合成虚拟资源池后，资源利用率大大提高</p>
</li>
<li><p><strong>自由配置</strong></p>
<p>在资源池范围内，可以自行添加虚拟机，更改虚拟机内存、存储空间等参数</p>
</li>
<li><p><strong>统一管理</strong></p>
<p>通过虚拟化平台能够清晰的查看服务器运行情况、硬件健康状况等信息</p>
</li>
<li><p><strong>更稳定</strong></p>
<p>虚拟化本身就是一个安全技术，通过虚拟化技术手段，提高系统稳定性，保证数据安全</p>
</li>
</ul>
<h4 id="虚拟化过程："><a href="#虚拟化过程：" class="headerlink" title="虚拟化过程："></a>虚拟化过程：</h4><p>给每个服务器上装一个(VMware)虚拟卡，通过虚拟化软件把孤立的、分散的服务器资源连接在一起，形成一个虚拟化资源池，将资源集中起来，然后相对的虚拟出多台服务器，通过虚拟化软件将虚拟化任务自动的分配在多台服务器上</p>
<p><img src="//dingyifan.tech/2020/02/08/虚拟化云计算/C:%5CUsers%5Clenovo%5CDesktop%5C1576411355(1).png" alt="1576411355(1)"></p>
<h4 id="虚拟化技术的分类："><a href="#虚拟化技术的分类：" class="headerlink" title="虚拟化技术的分类："></a>虚拟化技术的分类：</h4><ul>
<li><p>全虚拟化技术</p>
<p>完全虚拟化技术又叫硬件辅助虚拟化技术，最初所使用的的虚拟化技术就是全虚拟化技术，它在虚拟机（VM）和硬件之间加了一个软件层——Hyperyisor，或者叫做虚拟机监控器（VMM）</p>
<ul>
<li>hypervisor（虚拟机软件层/虚拟机监控机）</li>
</ul>
<p><img src="//dingyifan.tech/2020/02/08/虚拟化云计算/C:%5CUsers%5Clenovo%5CDesktop%5C1576467239(1).png" alt="1576467239(1)"></p>
</li>
<li><p>半虚拟化技术/准虚拟化技术（使用比较少）</p>
<p>半虚拟化技术，也叫准虚拟化技术。它就是在全虚拟化的基础上，把客户操作系统进行了修改，增加了一个专门的API，这个API可以将客户操作系统发出的指令进行最优化，即不需要Hypervisor耗费一定的资源进行翻译操作，因此Hypervisor的工作负担变得非常的小，因此整体的性能也有很大的提高。</p>
</li>
</ul>
<p><img src="//dingyifan.tech/2020/02/08/虚拟化云计算/C:%5CUsers%5Clenovo%5CDesktop%5C1576467741(1).png" alt="1576467741(1)"></p>
<h4 id="openstack云计算概念："><a href="#openstack云计算概念：" class="headerlink" title="openstack云计算概念："></a>openstack云计算概念：</h4><p><strong>云计算</strong>就是通过网络访问服务的一种模式。</p>
<p><strong>“云计算”</strong>可以理解为：通过互联网可以使用足够强大的计算机为用户提供的服务，这种服务的使用像可以统一的单位来描述。</p>
<h4 id="虚拟化和云计算比较"><a href="#虚拟化和云计算比较" class="headerlink" title="虚拟化和云计算比较"></a>虚拟化和云计算比较</h4><p><strong>虚拟化：</strong> 是一种技术存在，从1个物理硬件系统创建多个模拟环境</p>
<p><strong>云计算：</strong> 是一种服务模式存在，汇聚并自动化分配虚拟资源以供按需使用</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>使用xtrabackup备份</title>
    <url>/2020/02/08/%E4%BD%BF%E7%94%A8xtrabackup%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="使用xtrabackup备份mysql"><a href="#使用xtrabackup备份mysql" class="headerlink" title="使用xtrabackup备份mysql"></a>使用xtrabackup备份mysql</h1><h2 id="简介（Percona-XtraBackup-）简称PXB"><a href="#简介（Percona-XtraBackup-）简称PXB" class="headerlink" title="简介（Percona XtraBackup ）简称PXB"></a>简介（<a href="https://www.percona.com/software/mysql-database/percona-xtrabackup" target="_blank" rel="noopener">Percona XtraBackup</a> ）简称PXB</h2><blockquote>
<p>Xtrabackup是由percona开源的免费数据库热备份软件，它能对Innodb数据库和Xtradb存储引擎的数据库非阻塞地备份。（对于Myisam的备份同样需要加表锁），mysqldump备份方式是采用的逻辑备份，其最大的缺陷是备份和恢复速度较慢，如果数据库大于50G，mysqldump备份就不太适合。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>备份速度快，物理备份可靠</li>
<li>备份过程不会打断正在执行的事务（无需锁表）</li>
<li>能够基于压缩等功能节约磁盘空间和流量</li>
<li>自动备份校验</li>
<li>还原速度快</li>
<li>可以流传将备份传输到另一台机器上</li>
<li>在不增加服务器负载的情况下备份数据</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>​    备份开始的时候，首先会开启一个后台检测进程，实时检测mysql redo到的变化，一旦发现有新的日志写入，立刻将日志记入后台日志文件xtrabackup_log中，之后赋值innodb的数据文件，系统表空间文件ibdatax，复制后，将上锁（读锁），flush tables with read lock，让后复制.frm MYI MYD等文件，最后执行 unlock tables（释放锁），最终停止xtrabackup_log。</p>
</blockquote>
<p>​        <img src="http://mysql.taobao.org/monthly/pic/2016-03-07/PXB-backup-procedure.png" alt="image "></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote>
<p>​    在innodb内部会维护一个redo日志文件，我们也可以叫做事务日志文    件，事务日志会存储每一个Innodb表数据的记录修改。当Innodb启动时，Innodb会检查数据文件和事务日志。并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</p>
<p>​    xtrabackup在启动时会记住log    sequence number（LSN），并且复制所有数据文件，复制过程需要一些时间，所以这期间如果数据文件有改动，那么将会使数据库处于一个不同的时间点。这时，Xtrabackup会运行一个后台进程，用于监测事务日志，并从事务日志复制最新的修改。xtrabackup必须持续的做这个操作，因为事务日志是会轮转重复的写入，并且事务日志可以被重用。所以xtrabackup自启动开始，就不停的将事务日志中每个数据文件的修改都记录下来。这就是xtrabackup的备份过程。</p>
<p>​    接下来是准备（prepare）过程。在这个过程中，xtrabackup使用之前复制的事务日志。对各个数据文件执行灾难恢复（就像mysql刚启动时要做的一样）。当这个过程结束后，数据库就可以做恢复还原了。</p>
<p>​    整个过程就是-备份-》准备。先将文件全部复制过来，在根据事务日志对部分操作进行回滚。</p>
<p>​    程序innobbackupex可以允许我们备份Myisam表和文件从而增加了便捷和功能。</p>
<p>​    innobbackupex会启动xtrabackup，直到xtrabackup复制数据文件后，然后执行FLUSH TABLES WITH READ LOCK 来阻止新的写入刷新到磁盘上。之后复制Myisam数据文件。最后UNLOCK TABLES （释放锁）。</p>
<p>​    备份Myisam和Innodb表最终会处于一致，在准备（prepare）过程结束后，Innodb表数据已经前滚到整个备份结束点，而不是回滚到xtrabackup感刚开始的点。这个时间点与执行FLUSH TABLES WITH READ LOCK的时间点相同，所以Myisam表数据与Innodb表数据是同步的。</p>
</blockquote>
<h2 id="xtrabackup增量备份"><a href="#xtrabackup增量备份" class="headerlink" title="xtrabackup增量备份"></a>xtrabackup增量备份</h2><ul>
<li><p>原理</p>
<blockquote>
<p>​    首先是建立在完全备份的基础上，记录下此时的检查点LSN</p>
<p>​    在进行增量备份时，比较表空间中每个页的LSN是否大于上次备份的LSN，若是则备份该页并记录当前检查点的LSN。</p>
</blockquote>
</li>
<li><p>优点：</p>
<ul>
<li>数据库太大没有足够的空间全量备份，增量备份能有效节省空间，并且效率高</li>
<li>支持热备份，备份过程不锁表（针对Innodb而言），不阻塞数据库读写。</li>
<li>每日备份只产生少量数据，也可采用远程备份，节省本地空间</li>
<li>备份恢复基于文件操作，降低直接对数据库操作风险</li>
<li>备份效率更高，恢复效率更高。</li>
</ul>
</li>
</ul>
<h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>软件包安装完后一共有4个可执行文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usr</span><br><span class="line">├── bin</span><br><span class="line">│   ├── innobackupex</span><br><span class="line">│   ├── xbcrypt  #用来加密或解密备份的数据</span><br><span class="line">│   ├── xbstream  #用来解压或压缩xbstream格式的文件</span><br><span class="line">│   └── xtrabackup</span><br></pre></td></tr></table></figure>

<p>其中最主要的是 <code>innobackupex</code> 和 <code>xtrabackup</code>，前者是一个 perl 脚本，后者是 C/C++ 编译的二进制。</p>
<p><code>xtrabackup</code> 是用来备份 InnoDB 表的，不能备份非 InnoDB 表，和 mysqld server 没有交互；<code>innobackupex</code> 脚本用来备份非 InnoDB 表，同时会调用 <code>xtrabackup</code> 命令来备份 InnoDB 表，还会和 mysqld server 发送命令进行交互，如加读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。简单来说，<code>innobackupex</code> 在 <code>xtrabackup</code> 之上做了一层封装。</p>
<p>一般情况下，我们是希望能备份 MyISAM 表的，虽然我们可能自己不用 MyISAM 表，但是 mysql 库下的系统表是 MyISAM 的，因此备份基本都通过 <code>innobackupex</code> 命令进行；另外一个原因是我们可能需要保存位点信息。</p>
<p>另外2个工具相对小众些，<code>xbcrypt</code> 是加解密用的；<code>xbstream</code> 类似于tar，是 Percona 自己实现的一种支持并发写的流文件格式。两都在备份和解压时都会用到（如果备份用了加密和并发）。</p>
<p>本文的介绍的主角是 <code>innobackupex</code> 和 <code>xtrabackup</code>。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><p>安装percona仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装xtrabackup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install percona-xtrabackup -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建备份用户及设置权限（也可以直接使用root用户）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER ‘用户名’@'localhost' IDENTIFIED BY '密码';#创建</span><br><span class="line">GRANT RELOAD,LOCK TABLES,PROCESS,REPLICATION CLIENT ON *.* TO '用户名'@'localhost';#设置权限</span><br><span class="line">FLUSH PRIVILEGES;#刷新权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xtrabackup（可配置也可以已参数的形式写入）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/.my.cnf</span><br><span class="line"></span><br><span class="line">[xtrabackup]</span><br><span class="line"></span><br><span class="line">user=创建的用户名</span><br><span class="line"></span><br><span class="line">password=密码</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建备份使用的文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/backup/mysql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="基于xtrabackup的备份和恢复"><a href="#基于xtrabackup的备份和恢复" class="headerlink" title="基于xtrabackup的备份和恢复"></a>基于xtrabackup的备份和恢复</h2><ul>
<li><p><em>xtrabackup</em> 只支持innodb引擎和xtradb引擎</p>
</li>
<li><p>语法：</p>
<ul>
<li>–backup 表示该操作代表备份操作</li>
<li>–target-dir 指定备份文件的路径</li>
<li>–user 备份的用户 （设定配置文件后，无需指定）</li>
<li>–password  用户密码（同上）</li>
<li>–socket 指定socket启动文件路径（不添加使用默认路径）</li>
<li>–incremental-basedir  表示在某个全量备份的基础上进行增备</li>
</ul>
</li>
<li><p>全量备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# xtrabackup --backup --target-dir=/data/backup/mysql</span><br><span class="line"><span class="meta">#</span>以下是返回的结果</span><br><span class="line">191221 13:49:02  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 13:49:02  version_check Connected to MySQL server</span><br><span class="line">191221 13:49:02  version_check Executing a version check against the server...</span><br><span class="line">191221 13:49:02  version_check Done.</span><br><span class="line">191221 13:49:02 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">xtrabackup: uses posix_fadvise().</span><br><span class="line">xtrabackup: cd to /var/lib/mysql</span><br><span class="line">xtrabackup: open files limit requested 0, set to 65535</span><br><span class="line">xtrabackup: using the following InnoDB configuration:</span><br><span class="line"><span class="meta">#</span>省略.....</span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 13:49:03 [00] Writing backup-my.cnf</span><br><span class="line">191221 13:49:03 [00]        ...done</span><br><span class="line">191221 13:49:03 [00] Writing xtrabackup_info</span><br><span class="line">191221 13:49:03 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 13:49:04 completed OK!#代表成功全量备份</span><br></pre></td></tr></table></figure>
</li>
<li><p>在全量备份的基础上进行增量备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>xtrabackup --backup --target-dir=/data/mysql/增量备份文件夹的名字（自定义）--incremental-basedir=/全量备份文件路径</span><br><span class="line">[root@ax mysql]# xtrabackup --backup --target-dir=/data/backup/mysql/mysql_increment1 --incremental-basedir=/data/backup/mysql</span><br><span class="line">191221 14:00:43  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 14:00:43  version_check Connected to MySQL server</span><br><span class="line">191221 14:00:43  version_check Executing a version check against the server...</span><br><span class="line">191221 14:00:43  version_check Done.</span><br><span class="line">191221 14:00:43 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">incremental backup from 8622624 is enabled.</span><br><span class="line">xtrabackup: uses posix_fadvise().</span><br><span class="line">xtrabackup: cd to /var/lib/mysql</span><br><span class="line">xtrabackup: open files limit requested 0, set to 65535</span><br><span class="line"><span class="meta">#</span>省略....</span><br><span class="line">xtrabackup: Stopping log copying thread.</span><br><span class="line">.191221 14:00:45 &gt;&gt; log scanned up to (8622624)</span><br><span class="line"></span><br><span class="line">191221 14:00:45 Executing UNLOCK TABLES</span><br><span class="line">191221 14:00:45 All tables unlocked</span><br><span class="line">191221 14:00:45 Backup created in directory '/data/backup/mysql/mysql_increment1/'</span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 14:00:45 [00] Writing backup-my.cnf</span><br><span class="line">191221 14:00:45 [00]        ...done</span><br><span class="line">191221 14:00:45 [00] Writing xtrabackup_info</span><br><span class="line">191221 14:00:45 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 14:00:45 completed OK!#代表增量备份成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>在增量备份的基础上继续增量备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在第一次增量备份后，以后的每一次增量备份都是以上一次增量备份为基准</span><br><span class="line"><span class="meta">#</span>xtrabackup --backup --target-dir=增量备份文件路径 --incremental-basedir=上次增量备份的文件位置</span><br><span class="line">[root@ax ~]# xtrabackup --backup --target-dir=/data/backup/mysql_increment2 --incremental-basedir=/data/backup/mysql/mysql_increment1</span><br><span class="line">191221 18:39:28  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 18:39:28  version_check Connected to MySQL server</span><br><span class="line">191221 18:39:28  version_check Executing a version check against the server...</span><br><span class="line">191221 18:39:28  version_check Done.</span><br><span class="line">191221 18:39:28 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 </span><br><span class="line"><span class="meta">#</span>省略...</span><br><span class="line">191221 18:39:32 Executing UNLOCK TABLES</span><br><span class="line">191221 18:39:32 All tables unlocked</span><br><span class="line">191221 18:39:32 Backup created in directory '/data/backup/mysql_increment2/'</span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 18:39:32 [00] Writing backup-my.cnf</span><br><span class="line">191221 18:39:32 [00]        ...done</span><br><span class="line">191221 18:39:32 [00] Writing xtrabackup_info</span><br><span class="line">191221 18:39:32 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 18:39:32 completed OK!#代表成功</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用xtrabackup恢复"><a href="#使用xtrabackup恢复" class="headerlink" title="使用xtrabackup恢复"></a>使用xtrabackup恢复</h2><ul>
<li><p>语法：</p>
<ul>
<li><p>xtrabackup –prepare –apply-log-only –target-dir=全量备份文件路径</p>
<ul>
<li>–prepare  表示还原</li>
<li>–apply-log-only 表示不回滚事务，因为后面有基于全备的增量备份，所以不需要回滚，如果没有增量备份则可以不添加。</li>
</ul>
</li>
<li><p>将第一次增量备份加载至全备中（增量备份多每次都要以上一次加载的备份文件为基准，命令相同，只需修改增量备份文件的路径即可。）</p>
</li>
<li><p>在加载最后一次的增量备份文件时，不需要添加–apply-log-only，因为增量备份都加载完成了，所以需要事务回滚。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>xtrabackup --prepare --apply-log-only --target-dir=全量备份文件路径 --incremental-dir=增量备份文件路径</span><br><span class="line">[root@ax ~]# xtrabackup --prepare --apply-log-only --target-dir=/data/backup/mysql --incremental-dir=/data/backup/mysql_increment1</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">incremental backup from 8622624 is enabled.</span><br><span class="line">xtrabackup: cd to /data/backup/mysql/</span><br><span class="line">xtrabackup: This target seems to be already </span><br><span class="line"><span class="meta">#</span>省略...</span><br><span class="line">191221 18:56:43 [01]        ...done</span><br><span class="line">191221 18:56:43 [01] Copying /data/backup/mysql_increment1/mysql/db.MYD to ./mysql/db.MYD</span><br><span class="line">191221 18:56:43 [01]        ...done</span><br><span class="line">191221 18:56:43 [00] Copying /data/backup/mysql_increment1//xtrabackup_binlog_info to ./xtrabackup_binlog_info</span><br><span class="line">191221 18:56:43 [00]        ...done</span><br><span class="line">191221 18:56:43 [00] Copying /data/backup/mysql_increment1//xtrabackup_info to ./xtrabackup_info</span><br><span class="line">191221 18:56:43 [00]        ...done</span><br><span class="line">191221 18:56:43 completed OK!#代表成功</span><br><span class="line"><span class="meta">#</span>最后一加载增量备份到全量备份</span><br><span class="line">[root@ax ~]# xtrabackup --prepare --target-dir=/data/backup/mysql --incremental-dir=/data/backup/mysql_increment2</span><br><span class="line"><span class="meta">#</span>返回也上面最后一行的结果代表成功</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>恢复</p>
<ul>
<li><p>停止mysql服务</p>
</li>
<li><p>清空mysql的数据目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like &apos;datadir&apos;; #查询数据目录</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">#cd到指定目录 rm -rf ./*  这是模拟数据库损坏</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复 <code>xtrabackup --copy-back --target-dir=/data/backup/mysql</code>  –copy-back 将备份的数据目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ax ~]# xtrabackup --copy-back --target-dir=/data/backup/mysql</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">191221 19:23:55 [01] Copying ib_logfile0 to /var/lib/mysql/ib_logfile0</span><br><span class="line">191221 19:23:55 [01]        ...done</span><br><span class="line">191221 19:23:55 [01] Copying ib_logfile1 to /var/lib/mysql/ib_logfile1</span><br><span class="line">191221 19:23:55 [01]        ...done</span><br><span class="line">191221 19:23:55 [01] Copying ibdata1 to /var/</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复后的数据目录下的文件及文件夹，用户数属于root的,mysql用户是没有权限使用的，所以需要重新赋予权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# ll</span><br><span class="line">total 36896</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 exam</span><br><span class="line">-rw-r----- 1 root root 27262976 Dec 21 19:23 ibdata1</span><br><span class="line">-rw-r----- 1 root root  5242880 Dec 21 19:23 ib_logfile0</span><br><span class="line">-rw-r----- 1 root root  5242880 Dec 21 19:23 ib_logfile1</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 mysql</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 nextcloud</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 performance_schema</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 siyouyun</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 text</span><br><span class="line">-rw-r----- 1 root root       23 Dec 21 19:23 xtrabackup_binlog_pos_innodb</span><br><span class="line">-rw-r----- 1 root root      548 Dec 21 19:23 xtrabackup_info</span><br><span class="line"><span class="meta">#</span>重新赋予权限，所属者和所属组改为mysql</span><br><span class="line">[root@ax mysql]# chown -R mysql:mysql ../mysql</span><br><span class="line">[root@ax mysql]# ll</span><br><span class="line">total 36896</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 exam</span><br><span class="line">-rw-r----- 1 mysql mysql 27262976 Dec 21 19:23 ibdata1</span><br><span class="line">-rw-r----- 1 mysql mysql  5242880 Dec 21 19:23 ib_logfile0</span><br><span class="line">-rw-r----- 1 mysql mysql  5242880 Dec 21 19:23 ib_logfile1</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 mysql</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 nextcloud</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 performance_schema</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 siyouyun</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 text</span><br><span class="line">-rw-r----- 1 mysql mysql       23 Dec 21 19:23 xtrabackup_binlog_pos_innodb</span><br><span class="line">-rw-r----- 1 mysql mysql      548 Dec 21 19:23 xtrabackup_info</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动mysql服务查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# systemctl restart mariadb</span><br><span class="line">[root@ax mysql]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 2</span><br><span class="line">Server version: 5.5.64-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| exam               |</span><br><span class="line">| mysql              |</span><br><span class="line">| nextcloud          |</span><br><span class="line">| performance_schema |</span><br><span class="line">| siyouyun           |</span><br><span class="line">| text               |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; </span><br><span class="line"><span class="meta">#</span>恢复成功</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单表/单库备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">单表：xtrabackup --backup --datadir=数据目录路径 --tables='库名.表名' --target-dir=备份文件路径</span><br><span class="line"></span><br><span class="line">--tables:单引号中填写databases.tables</span><br><span class="line"></span><br><span class="line">单库：trabackup --backup  --databases=数据库名 --target-dir=备份文件路径 </span><br><span class="line">--databases:库名（database）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax ~]# xtrabackup --backup --datadir=/var/lib/mysql --target-dir=/data/backup/mysql --tables='exam.a1';</span><br><span class="line"><span class="meta">#</span>还原也需要进行事务回滚</span><br><span class="line">[root@ax exam]# xtrabackup --prepare --target-dir=单表或单库备份文件</span><br><span class="line"><span class="meta">#</span>停止数据库</span><br><span class="line"><span class="meta">#</span>数据目录中的原表删除，复制备份文件中单表或单库文件到数据目录</span><br><span class="line"><span class="meta">#</span>重置所属用户和组到mysql</span><br><span class="line"><span class="meta">#</span>重启数据库</span><br><span class="line"><span class="meta">#</span>成功</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##使用innobackupex的备份与恢复</p>
<ul>
<li><p>innobackupex封装了xtrabackup，支持Myisam的数据表</p>
</li>
<li><p>innobackupex完整备份后生成的几个重要文件：</p>
<ul>
<li>记录当前最新的Log position</li>
<li>xtrabackup_binlog_pos_innodb:innodb log position</li>
<li>xtrabackup_checkpoints:存放备份的起始LSN（beginlsn），和结束的位置LSN（endlsn）</li>
<li>增量备份需要上次备份的endlsn</li>
</ul>
</li>
<li><p>innobackupex命令相当于冷备份，复制数据目录的索引，数据结构文件，为保证数据一致，需要短暂的锁表（时间的长短依赖于Myisam表的大小。）</p>
</li>
<li><p>参数解释（同样适用于xtrabackup）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--defaults-file：指定my.cnf参数文件的位置[此配置文件里必须指定datadir]</span></span><br><span class="line"><span class="comment">#--apply-log：同xtrabackup的--prepare参数,一般情况下,在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据 文件仍处理不一致状态。--apply-log的作用是通过回滚未提交的事务及同步已经提交的事务至数据文件使数据文件处于一致性状态。</span></span><br><span class="line"><span class="comment">#--copy-back：做数据恢复时将备份数据文件拷贝到MySQL服务器的datadir</span></span><br><span class="line"><span class="comment">#--remote-host=HOSTNAME： 通过ssh将备份数据存储到进程服务器上</span></span><br><span class="line"><span class="comment">#--stream=[tar]：备份文件输出格式, 该文件可在XtarBackup binary文件中获得. 在使用参数stream=tar备份的时候,你的xtrabackup_logfile可能会临时放在/tmp目录下,如果你备份的时候并发写入较大的话,xtrabackup_logfile可能会很大(5G+),很可能会撑满你的/tmp目录,可以通过参数--tmpdir指定目录来解决这个问题.</span></span><br><span class="line"><span class="comment">#--tmpdir=DIRECTORY：当有指定--remote-host or --stream时, 事务日志临时存储的目录, 默认采用MySQL配置文件中所指定的临时目录tmpdir</span></span><br><span class="line"><span class="comment">#--redo-only --apply-log：强制备份日志时只redo,跳过rollback,这在做增量备份时非常必要</span></span><br><span class="line"><span class="comment">#--use-memory=*：该参数在prepare的时候使用,控制prepare时innodb实例使用的内存</span></span><br><span class="line"><span class="comment">#--databases=LIST：列出需要备份的databases,如果没有指定该参数,所有包含MyISAM和InnoDB表的database都会被备份</span></span><br><span class="line"><span class="comment">#--slave-info：备份从库, 加上--slave-info备份目录下会多生成一个xtrabackup_slave_info 文件, 这里会保存主日志文件以及偏移, 文件内容类似于:CHANGE MASTER TO MASTER_LOG_FILE='', MASTER_LOG_POS=0</span></span><br><span class="line"><span class="comment">#--socket=SOCKET：指定mysql.sock所在位置，以便备份进程登录mysql.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全量备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax backup]# innobackupex --user=备份账户 --password=密码 备份文件存储路径</span><br><span class="line">191223 10:08:18 innobackupex: Starting the backup operation</span><br><span class="line"></span><br><span class="line">IMPORTANT: Please check that the backup run completes successfully.</span><br><span class="line">           At the end of a successful backup run innobackupex</span><br><span class="line">           prints "completed OK!".</span><br><span class="line"><span class="meta">#</span>省略...</span><br><span class="line">191223 10:08:20 completed OK!#代表成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>全量恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>执行innobackupex --apply-log --use-memory=size（可加可不加） 备份文件路径    这一步是准备操作。apply-only在上面介绍过。</span><br><span class="line">[root@ax backup]# innobackupex --apply-only --use-memory=4G /data/backup/2019-12-23_10-08-18</span><br><span class="line">191223 10:16:02 innobackupex: Starting the backup operation</span><br><span class="line"></span><br><span class="line">IMPORTANT: Please check that the backup run completes successfully.</span><br><span class="line">           At the end of a successful backup run innobackupex</span><br><span class="line">           prints "completed OK!".</span><br><span class="line"><span class="meta">#</span>省略...</span><br><span class="line">191223 10:16:04 completed OK!#代表成功</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>接下来是恢复</span><br><span class="line"><span class="meta">#</span>关闭mysql服务,模拟数据库损坏，清空数据目录（不清空会报错）</span><br><span class="line"><span class="meta">#</span>执行 innobackupex --copy-back 备份文件路径</span><br><span class="line"><span class="meta">#</span>给予mysql数据目录下所有文件的操作权限</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>增量备份（所有的增量备份都是在全量备份的基础上进行的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>执行 innobackupex --incremental 指定增量文件存储路径 --incremental-basedir=第一次是全量备份的文件路径/在增量的备份的基础上继续增量这里就需要填写上次增量备份文件的路径</span><br><span class="line">[root@ax backup]# innobackupex --incremental /data/backup/ --incremental-basedir=/data/backup/2019-12-23_11-25-13/</span><br><span class="line">xtrabackup: Transaction log of lsn (8626208) to (8626208) was copied.</span><br><span class="line">191223 11:34:20 completed OK!#代表成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复：（将各个增量备份的数据文件合并到全量备份的目录下，最终是从全量备份的这个目录上进行恢复的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>准备工作</span><br><span class="line"><span class="meta">#</span>innobackupex --apply-log --redo-only 全被文件路径</span><br><span class="line"><span class="meta">#</span>innobackupex --apply-log --redo-only 全备路径 --incremental-dir=第一次增备路径</span><br><span class="line"><span class="meta">#</span>innobackupex --apply-log --redo-only 全备文件路径 --incremental-dir=第二次增备路径 #多次增备执行多次</span><br><span class="line"><span class="meta">#</span>innobackupex --apply-log 全备路径 --incremental-dir=最后一次增备路径 最后一次不需要填加--redo-only参数</span><br><span class="line"><span class="meta">#</span>恢复</span><br><span class="line"><span class="meta">#</span>关闭mysql服务,模拟数据库损坏，清空数据目录（不清空会报错）</span><br><span class="line"><span class="meta">#</span>innobackupex --copy-back 全量备份路径 </span><br><span class="line"><span class="meta">#</span>给予mysql数据目录下所有文件的操作权限</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql定时备份任务</title>
    <url>/2020/02/08/mysql%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="MYSQL定时备份任务shell脚本"><a href="#MYSQL定时备份任务shell脚本" class="headerlink" title="MYSQL定时备份任务shell脚本"></a>MYSQL定时备份任务shell脚本</h1><h2 id="备份的必要性"><a href="#备份的必要性" class="headerlink" title="备份的必要性"></a>备份的必要性</h2><ul>
<li>每个公司的业务都是基于数据进行的，数据的存储基本都是数据库</li>
<li>保证了数据的安全，稳定，也就可以做到防范于未然。</li>
</ul>
<p>##冷备和热备</p>
<ul>
<li>冷备份：<ul>
<li>冷备份，off，快，时间点上恢复</li>
<li>冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库，冷备份是将关键性文件拷贝的另外位置的一种说法，对于备份数据库信息而言，冷备份是最快和最安全的方法。</li>
<li>冷备份的优点：<ul>
<li>低度维护，安全</li>
<li>容易归档，拷贝文件</li>
<li>速度快</li>
<li>恢复简单</li>
</ul>
</li>
<li>冷备份的缺点：<ul>
<li>不能按表或按用户恢复</li>
<li>若磁盘空间有限，只能拷贝到磁带等其他外部存储设备上，速度会很慢。</li>
<li>恢复限制，在备份期间，数据库不能做读写写操作。</li>
</ul>
</li>
</ul>
</li>
<li>热备份：<ul>
<li>在数据库运行时，直接进行备份，对运行的数据库没有影响。</li>
<li>热备份的优点：<ul>
<li>可在表空间或数据文件级备份，备份时间段。</li>
<li>灵活，备份时不影响数据库的使用。</li>
<li>秒级恢复，能够恢复到某一时间点上。</li>
</ul>
</li>
<li>热备份的缺点：<ul>
<li>严谨性，尽量不要出错，否则后果很严重。</li>
<li>维护困难</li>
</ul>
</li>
</ul>
</li>
<li>温备：（只能读，不可写）<ul>
<li>上锁（考虑持锁的长久）</li>
</ul>
</li>
</ul>
<h2 id="MYSQL备份数据的几种方式"><a href="#MYSQL备份数据的几种方式" class="headerlink" title="MYSQL备份数据的几种方式"></a>MYSQL备份数据的几种方式</h2><p>###into outfile###</p>
<ul>
<li><p>利用<code>select into outfile +指定的路径</code> 实现指定表数据的备份 备份完的文件是文本文件</p>
</li>
<li><p>在使用<code>select into outfile</code> 使用默认的用户是mysql在操作，使用<code>show variables like &#39;datadir&#39;</code>会显示所属mysql用户的文件件具有一切权限</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MariaDB [exam]&gt; show variables like 'datadir';</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定路径可以直接放在mysql所属的文件夹下</p>
</li>
<li><p>如果指定文件备份位置，会报错<code>ERROR 1 (HY000): Can&#39;t create/write to file &#39;/data/test.txt&#39; (Errcode: 13)</code> 这是代表mysql没有文件目录的操作权限。</p>
<ul>
<li>解决办法 <ul>
<li>直接更改文件目录的所属用户为mysql让mysql拥有一切权限，<code>clown mysql:mysql +指定文件夹的路径</code></li>
<li>修改文件夹其它用户可以有写的权限。(不建议)</li>
<li>先备份至mysql所属文件夹内 进行mv</li>
</ul>
</li>
</ul>
</li>
<li><p>可以使用<code>load data infile +备份完数据的路径 into table +表名</code> 进行恢复。</p>
</li>
</ul>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><ul>
<li><p>mysqldump 常用来做温备 （所以需要先对备份的数据施加锁，只能读不能写）本质上就是将指定数据库中的数据已sql语句的方式输出 使用重定向到指定的文件</p>
</li>
<li><p>施加读锁的方式：</p>
<ul>
<li>flush tables with read lock 施加锁，表示把位于内存上的表统统都同步到磁盘上，然后去施加读锁。</li>
<li>unlock tables 释放锁。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li>-A  –alldatabases 备份所有数据库，含create database</li>
<li>-B  –databases db_name  指定备份的数据库，包含create database语句</li>
<li>-E –events  备份相关的所有event scheduler（<a href="https://blog.csdn.net/kelvin_yin/article/details/79128981" target="_blank" rel="noopener">事件调度器</a>)</li>
<li>-R  –routines  备份所有存储过程和自定义函数</li>
<li>–tirggers  备份表相关触发器，默认启用，用–skip-triggers，不备份触发器（<a href="https://www.jb51.net/article/164675.htm" target="_blank" rel="noopener">触发器</a>）默认开启</li>
<li>–default-character-set=utf8(默认)</li>
<li>–single-transaction 通过在一个事务中导出所有表从而创建一个一致性的快照，（只支持innodb，myisam不支持事务），从而有效的保证了dump文件，即正确的表内容和二进制日志位置。</li>
<li>–master-data=2 选项开启式默认会打开lock-all-tables 一个是加锁，一个是获取log信息 =1和=2的在于log信息前者不注释，后者注释。</li>
<li>lock-all-tables 在dump执行的时候会在表上加上读锁，保证数据一致性，innodb不需加上此参数，而使用 –single-tansaction</li>
<li>–all-databases  导出所有的数据库 也可以指定表名</li>
<li>-F –flush-logs  备份前滚动日志</li>
<li>|gzip  对压缩的文件进行压缩（有效的节省磁盘空间）</li>
<li>gzip -d 对压缩文件解压</li>
</ul>
</li>
<li><p>全量备份</p>
<ul>
<li><p>使用mysqldump工具进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# mysqldump -uroot -p  --master-data=2 --databases 表名|gzip &gt;/data/mysql/a1_`date +%F`.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# mysql -uroot -p &lt; 备份文件路径/备份文件名</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>增量备份</p>
<ul>
<li><p>使用mysqlbinlog工具进行，本质上就是指定备份文件的log开始偏移量和结束日志的偏移量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# mysqlbinlog --start-position=3210 /var/lib/mysql/mysql-bin.000009 &gt; /data/mysql/a1_2019-12-19_17.sql</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–start-position=开始的偏移量</p>
</li>
<li><p>–stop-position=结束的偏移量</p>
</li>
<li><p>可以先使用<code>show master status</code> 来查看日志版本</p>
</li>
<li><p>通过find / -name 日志版本名来查找到路径</p>
</li>
<li><p>使用<code>mysqlbinlog --start-position=上次同步的结束位置 查询到的路径</code> 来查看需要同步的结束偏移量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# mysqlbinlog --start-position=0 /var/lib/mysql/mysql-bin.000010</span><br><span class="line">SET TIMESTAMP=1576755138/*!*/;</span><br><span class="line">insert into a1 values (4,'赵六'),(5,'冯七')</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta">#</span> at 423</span><br><span class="line"><span class="meta">#</span>191219 19:32:18 server id 1  end_log_pos 450 	Xid = 919</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"><span class="meta">#</span> at 450</span><br><span class="line"><span class="meta">#</span>191219 19:32:32 server id 1  end_log_pos 531 	Query	thread_id=334	exec_time=0	error_code=0</span><br><span class="line">SET TIMESTAMP=1576755152/*!*/;</span><br><span class="line">drop database exam</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta">#</span> at 531</span><br><span class="line"><span class="meta">#</span>191219 19:50:53 server id 1  end_log_pos 574 	Rotate to mysql-bin.000011  pos: 4</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="meta">#</span> End of log file</span><br><span class="line">ROLLBACK /* added by mysqlbinlog */;</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中end_log_pos就是结束的偏移量</p>
</li>
<li><p>或者直接使用<code>show master status</code> 中查询出来的偏移量，备份到操作该库的最后一次位置</p>
</li>
</ul>
</li>
<li><p>恢复，和全量恢复是相同的  </p>
<ul>
<li>[root@ax mysql]# mysql -uroot -p &lt; 备份文件路径/增量备份名备份文件名</li>
<li>恢复前先关闭二进制日志 <code>set sql_log_bin=0</code></li>
<li>滚动日志 <code>flush logs</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>###利用lvm快照备份和恢复##</p>
<ul>
<li>LVM（Logical Volume Manager）是一个应用于Linux的内核的逻辑卷管理器，是Linux环境下对磁盘进行分区管理的一种机制。相关名词：<ul>
<li>PV（物理卷）可以是一个磁盘，一个分区。由PE（物理盘区）组成，多个PV可以组成一个VG（卷组）<ul>
<li>VG（卷组）多个物理卷组成的一个组，卷组不可以直接使用，需要在上面创建LV（逻辑卷）才可以使用。VG上可以创建多个LV。</li>
<li>PE（物理盘区），默认是4MB,像磁盘的block块</li>
<li>LV（逻辑卷）是建立在卷组之上的一个可用空间，有物理边界和逻辑边界两种边界。</li>
</ul>
</li>
</ul>
</li>
<li>LVM扩展<ul>
<li><a href="https://www.jb51.net/LINUXjishu/105937.html" target="_blank" rel="noopener">连接</a></li>
<li>LVM是一种将一个或多个硬盘的分区在逻辑上的集合，相当于一个大硬盘来使用，当空间不够使用时，可以继续将其它硬盘的分区加入其中，这样可以实现一种磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性，使用普通的磁盘分区，当一个磁盘的分区空间不够使用的时候，可能就会带来很大的麻烦，使用LVM在一定程度就可以解决普通磁盘分区带来的问题。LVM通常用于装备大量磁盘的系统，但他它同样适于仅有一，两块硬盘的小系统。</li>
</ul>
</li>
</ul>
<h3 id="Mysql定时备份shell脚本"><a href="#Mysql定时备份shell脚本" class="headerlink" title="Mysql定时备份shell脚本"></a>Mysql定时备份shell脚本</h3><ul>
<li><p>利用的都是mysqldump，利用Crontab设置定时任务，来自动执行备份命令。直接上代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以下配置信息请自己修改</span><br><span class="line">mysql_user="root" #MySQL备份用户</span><br><span class="line">mysql_password="password" #MySQL备份用户的密码</span><br><span class="line">mysql_host="localhost"</span><br><span class="line">mysql_port="3306"</span><br><span class="line">mysql_charset="utf8" #MySQL编码</span><br><span class="line">backup_db_arr=("db1" "db2") #要备份的数据库名称，多个用空格分开隔开 如("db1" "db2" "db3")</span><br><span class="line">backup_location=/data/mysql #备份数据存放位置，末尾请不要带"/",此项可以保持默认，程序会自动创建文件夹</span><br><span class="line">expire_backup_delete="ON" #是否开启过期备份删除 ON为开启 OFF为关闭</span><br><span class="line">expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 本行开始以下不需要修改</span><br><span class="line">backup_time=`date +%F:%T` #定义备份详细时间</span><br><span class="line">backup_Ymd=`date +%Y-%m-%d` #定义备份目录中的年月日时间</span><br><span class="line">backup_3ago=`date -d '3 days ago' +%Y-%m-%d` #3天之前的日期</span><br><span class="line">backup_dir=$backup_location/$backup_Ymd #备份文件夹全路径</span><br><span class="line">welcome_msg="Welcome to use MySQL backup tools!" #欢迎语</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断MYSQL是否启动,mysql没有启动则备份退出</span><br><span class="line">mysql_ps=`ps -ef |grep mysql |wc -l`</span><br><span class="line">mysql_listen=`netstat -an |grep LISTEN |grep $mysql_port|wc -l`</span><br><span class="line">if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then</span><br><span class="line">echo "`date +%F:%T` --ERROR:MySQL is not running! backup stop!"</span><br><span class="line">exit</span><br><span class="line">else</span><br><span class="line">echo "备份时间-- `date +%F:%T`"</span><br><span class="line">echo `date +%F:%T` -- $welcome_msg</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 连接到mysql数据库，无法连接则备份退出</span><br><span class="line">mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end</span><br><span class="line">use mysql;</span><br><span class="line">select host,user from user where user='root' and host='localhost';</span><br><span class="line">exit</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">flag=`echo $?`</span><br><span class="line">if [ $flag != "0" ]; then</span><br><span class="line">echo "`date +%F:%T` --ERROR:Can't connect mysql server! backup stop!"</span><br><span class="line">exit</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --MySQL connect ok! Please wait......"</span><br><span class="line"><span class="meta">#</span> 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份</span><br><span class="line">if [ "$backup_db_arr" != "" ];then</span><br><span class="line"><span class="meta">#</span>dbnames=$(cut -d ',' -f1-5 $backup_database)</span><br><span class="line"><span class="meta">#</span>echo "arr is ($&#123;backup_db_arr[@]&#125;)"</span><br><span class="line">for dbname in $&#123;backup_db_arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo "`date +%F:%T` --database $dbname backup start..."</span><br><span class="line">`mkdir -p $backup_dir`</span><br><span class="line">`mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz`</span><br><span class="line">flag=`echo $?`</span><br><span class="line">if [ $flag == "0" ];then</span><br><span class="line">echo "`date +%F:%T` --database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz"</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --database $dbname backup fail!"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --ERROR:No database to backup! backup stop"</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span> 如果开启了删除过期备份，则进行删除操作</span><br><span class="line">if [ "$expire_backup_delete" == "ON" -a "$backup_location" != "" ];then</span><br><span class="line"><span class="meta">#</span>`find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \;`</span><br><span class="line">`find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`</span><br><span class="line">echo "`date +%F:%T` --Expired backup data delete complete!"</span><br><span class="line">fi</span><br><span class="line">echo "`date +%F:%T` --All database backup success! Thank you!"</span><br><span class="line">echo ""</span><br><span class="line">exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在非linux界面下操作，sh脚本中每行都会多个\r，导致linux无法执行脚本。解决办法，使用vim编辑shell脚本文件，执行::set ff=unix。文件即使unix文件了。可以使用::set ff? 查看文件的类型。dos就是在ATOM操作后保存的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fileformat=unix </span><br><span class="line">fileformat=dos</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的创建默认UGO权限为 -rw-r–r– 代表的这个文件没有执行权限，所以需要给文件增加权限。</p>
<ul>
<li><p>文件创建者拥有所有权限，用户组和其他组只有执行权限</p>
<p><code>chmod 711 备份文件</code></p>
</li>
<li><p>r=4 w=2 x=1 </p>
</li>
</ul>
</li>
<li><p>拥有了执行权限后，该shell脚本就可以执行了，可以执行一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ax auto_backup]# ./Backup.sh </span><br><span class="line">备份时间-- 2019-12-20:17:09:40</span><br><span class="line">2019-12-20:17:09:40 -- Welcome to use MySQL backup tools!</span><br><span class="line">host	user</span><br><span class="line">localhost	root</span><br><span class="line">2019-12-20:17:09:40 --MySQL connect ok! Please wait......</span><br><span class="line">2019-12-20:17:09:40 --database exam backup start...</span><br><span class="line">2019-12-20:17:09:40 --database exam success backup to /data/mysql/2019-12-20/exam-2019-12-20:17:09:40.sql.gz</span><br><span class="line">2019-12-20:17:09:40 --database shiyouyun backup start...</span><br><span class="line">mysqldump: Got error: 1049: "Unknown database 'shiyouyun'" when selecting the database</span><br><span class="line">2019-12-20:17:09:40 --database shiyouyun success backup to /data/mysql/2019-12-20/shiyouyun-2019-12-20:17:09:40.sql.gz</span><br><span class="line">2019-12-20:17:09:40 --Expired backup data delete complete!</span><br><span class="line">2019-12-20:17:09:40 --All database backup success! Thank you!</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行成功说明shell没有问题，只剩下写入定时任务了</p>
</li>
</ul>
<h4 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h4><ul>
<li><p>linux下使用crontab命令来提交和管理用户需要定时、周期性的执行任务。</p>
</li>
<li><p>linux下默认会安装此服务工具，并且会自动启动crond进程，crond进程会每分钟定期检查是否有要执行的任务。如果有要执行的任务，则自动执行该任务。</p>
</li>
<li><p>命令语法：</p>
<ul>
<li>crontab（选项） （参数）</li>
<li>选项：<ul>
<li>-e  编辑该用户的计时设置</li>
<li>-l   列出该用户的计时器设置</li>
<li>-r   删除该用户的计时器设置</li>
<li>-u   用户名称   指定要设定计时器的用户名称</li>
</ul>
</li>
<li>参数：<ul>
<li>crontab文件   指定包含待执行任务的crontab文件</li>
</ul>
</li>
</ul>
</li>
<li><p>直接在/etc/crontab文件中添加shell脚本任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 3 * * * root /data/auto_backup/Backup.sh &gt;&gt; /data/mysql/backup.log</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代表每天在凌晨3点运行Backup.sh脚本 并将输出重定向追加到backup.log文件中。</li>
<li>从左往右依次代表<ul>
<li>分 可取0-59的整数 加/数字 代表每分钟执行多少次</li>
<li>时 可取0-23的整数  </li>
<li>天  可取1-31的整数 ，必须是指定月份的有效日期</li>
<li>月 可取1-12的整数，也可写英文简写</li>
<li>周几 可取1-7的整数，描述周几</li>
<li>执行的用户  指定用户</li>
<li>shell脚本的路径</li>
<li>log日志的路径</li>
</ul>
</li>
</ul>
</li>
<li><p>添加完后保存，重启crond服务。一切ok</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ax mysql]# ls</span><br><span class="line">2019-12-20  backup.log</span><br><span class="line">[root@ax mysql]# cd 2019-12-20/</span><br><span class="line">[root@ax 2019-12-20]# ls</span><br><span class="line">exam-201912201600.sql.gz  exam-201912201613.sql.gz         exam-2019-12-20:16:31:01.sql.gz  shiyouyun-201912201608.sql.gz  shiyouyun-2019-12-20:16:21:01.sql.gz</span><br><span class="line">exam-201912201601.sql.gz  exam-201912201614.sql.gz         exam-2019-12-20:16:32:01.sql.gz  shiyouyun-201912201609.sql.gz  shiyouyun-2019-12-20:16:22:01.sql.gz</span><br><span class="line">[root@ax mysql]# cat backup.log </span><br><span class="line">备份时间-- 2019-12-20:16:30:01</span><br><span class="line">2019-12-20:16:30:01 -- Welcome to use MySQL backup tools!</span><br><span class="line">host	user</span><br><span class="line">localhost	root</span><br><span class="line">2019-12-20:16:30:01 --MySQL connect ok! Please wait......</span><br><span class="line">2019-12-20:16:30:01 --database exam backup start...</span><br><span class="line">2019-12-20:16:30:01 --database exam success backup to /data/mysql/2019-12-20/exam-2019-12-20:16:30:01.sql.gz</span><br><span class="line">2019-12-20:16:30:01 --database shiyouyun backup start...</span><br><span class="line">2019-12-20:16:30:01 --database shiyouyun success backup to /data/mysql/2019-12-20/shiyouyun-2019-12-20:16:30:01.sql.gz</span><br><span class="line">2019-12-20:16:30:01 --Expired backup data delete complete!</span><br><span class="line">2019-12-20:16:30:01 --All database backup success! Thank you!</span><br><span class="line"></span><br><span class="line">备份时间-- 2019-12-20:16:31:01</span><br><span class="line">2019-12-20:16:31:01 -- Welcome to use MySQL backup tools!</span><br><span class="line">host	user</span><br><span class="line">localhost	root</span><br><span class="line">2019-12-20:16:31:01 --MySQL connect ok! Please wait......</span><br><span class="line">2019-12-20:16:31:01 --database exam backup start...</span><br><span class="line">2019-12-20:16:31:01 --database exam success backup to /data/mysql/2019-12-20/exam-2019-12-20:16:31:01.sql.gz</span><br><span class="line">2019-12-20:16:31:01 --database shiyouyun backup start...</span><br><span class="line">2019-12-20:16:31:01 --database shiyouyun success backup to /data/mysql/2019-12-20/shiyouyun-2019-12-20:16:31:01.sql.gz</span><br><span class="line">2019-12-20:16:31:01 --Expired backup data delete complete!</span><br><span class="line">2019-12-20:16:31:01 --All database backup success! Thank you!</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内存淘汰策略</title>
    <url>/2020/02/08/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h2><p>Redis作为当前最常用的开源内存数据库，性能十分高，Redis读的速度是110000次/s,写的速度是81000次/s 。而且Redis支持数据持久化，众多数据结构存储，master-slave模式数据备份等多种功能。</p>
<h3>为何使用淘汰策略</h3>
如果长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，内存数据就会与磁盘产生频繁交换，使Redis性能急剧下降。此时就需要淘汰无用数据释放空间。对此，Redis在生产环境中，采用配置参数    的方式来限制内存大小。当实际存储内存超出maxmemory 参数值时，开发者可以通过这几种方法——Redis内存淘汰策略，来决定如何腾出新空间继续支持读写工作。\# maxmemory <bytes>



<p>Redis采用定期删除+惰性删除策略：</p>
<p>定期删除：redis每过一段时间（默认100ms）进行随机抽取检查，有过期key则删除；</p>
<p>惰性删除：任过期键不管，在每次获取键时检查是否过期，过期则删除。</p>
<p> <strong>采用定期删除+惰性删除策略其实也会出现其他问题</strong></p>
<p>如果定期删除没删除掉key，也没有及时去获取key（及惰性删除也没生效），那么该策略就不灵了。</p>
<p><strong>补救措施是采用淘汰机制：</strong></p>
<p>redis.conf中有一个配置 #maxmemory-policy allkeys-random</p>
<p>划线位置就是<strong>内存淘汰策略</strong>，有如下配置：</p>
<p>我们可以通过配置redis.conf中的maxmemory这个值来开启内存淘汰功能</p>
<p>驱逐过程可以这样理解：<br>1、客户端执行一个命令，导致Redis中的数据增加，占用更多的内存。<br>2、Redis检查内存使用量，如果超出maxmemory限制，根据策略清除部分key.<br>3、继续执行下一条命令，以此类推。</p>
<p>maxmemory为0的时候表示我们对Redis的内存使用没有限制。</p>
<p>Redis提供了下面几种汰策略供用户选择，其中默认的策略为noeviction策略：</p>
<p>·         noeviction：当内存不足以容纳新写入数据时，新写入操作报错。</p>
<p>noevition: 不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息，此时，Redis只响应读操作。</p>
<p>·         allkeys-lru：在主键空间中，优先移除最近未使用的key。</p>
<p>·         volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。</p>
<p>·         allkeys-random：在主键空间中，随机移除某个key。</p>
<p>·         volatile-random：在设置了过期时间的键空间中，随机移除某个key。</p>
<p>·         volatile-ttl：在设置了过期时间的键空间中，时间快过期的key优先移除。</p>
<p>将Redis用做缓存时，如果内存空间用满，就会自动驱逐老的数据。<br>LRU是Redis唯一支持的回收算法，本文详细介绍用于限制最大内存使用量的</p>
<p>LRU是什么？</p>
<p>*<em>最近使用的数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用  *</em></p>
<p><strong>基于这个思想,会存在一种缓存淘汰机制，每次从内存中找到最久未使用的数据然后置换出来，从而存入新的数据！</strong></p>
</bytes>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis雪崩</title>
    <url>/2020/02/08/redis%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><blockquote>
<p>缓存雪崩通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。</p>
<p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-avalanche.png" alt="redis-caching-avalanche"></p>
</blockquote>
<ul>
<li>解决方法：<ul>
<li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li>
<li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li>
<li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-avalanche-solution.png" alt="redis-caching-avalanche-solution"></p>
<h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul>
<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>
<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>
<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li>
</ul>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><blockquote>
<p>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果从<strong>数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。</p>
</blockquote>
<p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-penetration.png" alt="redis-caching-penetration"></p>
<p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。</p>
<p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p>
<p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p>
<p>解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><blockquote>
<p>​     缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
</blockquote>
<ul>
<li>解决方法：<ul>
<li>可以将热点数据设置为永远不过期；或者基于redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其他请求才能通过该key访问数据。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker存储原理</title>
    <url>/2020/02/08/Docker%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>#Docker 存储</p>
<h3 id="Docek-镜像层的镜像分层结构"><a href="#Docek-镜像层的镜像分层结构" class="headerlink" title="Docek 镜像层的镜像分层结构"></a>Docek 镜像层的镜像分层结构</h3><ul>
<li>docker的镜像分层结构，如下所示：</li>
</ul>
<p><img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="基于Ubuntu映像的容器层"></p>
<ul>
<li><p>docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层</p>
</li>
<li><p>容器读写层的工作原理</p>
<blockquote>
<p>我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。</p>
<p>我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。</p>
<blockquote>
<p>知识点： 容器=镜像+读写层</p>
</blockquote>
<p>而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="容器共享相同的图像"></p>
<ul>
<li><p>容器由最上面一个可写的容器层和若干个只读的镜像层组成，容器的数据就存在这些层中。这种分层结构最大的特点是Copy-on-Write。</p>
<ol>
<li><p>新数据会直接存放在最上面的容器层</p>
</li>
<li><p>修改现有数据会从镜像层复制文件到容器中，再在容器层修改并保存，镜像层的数据不会发生改变</p>
</li>
<li><p>若多个层中有命名相同的文件，用户只能看到最上面一层的文件</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docerk stoage driver。<strong>正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图</strong>。</li>
</ul>
<hr>
<h3 id="Docker-为容器提供了两种存放数据的资源："><a href="#Docker-为容器提供了两种存放数据的资源：" class="headerlink" title="Docker 为容器提供了两种存放数据的资源："></a>Docker 为容器提供了两种存放数据的资源：</h3><ul>
<li>由storage driver（存储驱动） 管理的镜像层和容器层<ul>
<li>用来放一些无状态的数据<ul>
<li><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></li>
</ul>
</li>
</ul>
</li>
<li>Data Volume。（数据卷）<ul>
<li>用来放一些有状态的数据，例如数据库<ul>
<li><strong>本质上是</strong> Docker Host （主机）<strong>文件系统中的目录或文件，能够直接被 ** mount （挂载）</strong>到容器的文件系统中**。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于docker镜像的三问"><a href="#关于docker镜像的三问" class="headerlink" title="关于docker镜像的三问"></a>关于docker镜像的三问</h4><ul>
<li>基于镜像A创建镜像B时是否会拷贝A镜像中的所有文件：<code>是不会的</code></li>
<li>基于镜像创建容器时是否会拷贝镜像中的所有文件至文件层：<code>不会的</code></li>
<li>容器与镜像在结构上有什么区别：<code>没有区别容器会比镜像多了一个</code> <code>merged</code>文件</li>
</ul>
<blockquote>
<p>在讲原理前，先讲下写时复制和写时分配</p>
</blockquote>
<h4 id="写时复制（CoW）"><a href="#写时复制（CoW）" class="headerlink" title="写时复制（CoW）"></a>写时复制（CoW）</h4><blockquote>
<p>所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论多少个容器共享同一个image，所作的写操作都是从image中复制到自己的文件系统中的复制本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离的，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p>
</blockquote>
<h4 id="用时分配（allocate-on-demand）"><a href="#用时分配（allocate-on-demand）" class="headerlink" title="用时分配（allocate-on-demand）"></a>用时分配（allocate-on-demand）</h4><blockquote>
<p>而用时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p>
</blockquote>
<h4 id="Docker存储驱动的作用"><a href="#Docker存储驱动的作用" class="headerlink" title="Docker存储驱动的作用"></a>Docker存储驱动的作用</h4><blockquote>
<p>将这些分层的镜像文件堆叠起来，并且提供统一的视图.使container的文件系统看上去和我们普通的文件系统没什么区别。<br>当创建一个新的容器的时候,实际上是在镜像的分层上新添加了一层container layer（容器层）.之后所有对容器产生的修改,实际都只影响这一层。</p>
<p>注意</p>
<p>容器层：读写层(可写层)<br>镜像层：只读层</p>
</blockquote>
<blockquote>
<p>Docker 支持多种 storage driver，有 AUFS 、Device Mapper 、Btrfs 、OverlayFS 、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为：</p>
</blockquote>
<p>​            没有哪个driver 能够适应所有的场景。</p>
<p>​            driver 本身在快速发展和迭代。</p>
<blockquote>
<p>优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。</p>
</blockquote>
<blockquote>
<p>运行<code>docker info</code>可以查看可查看当前系统使用的<code>Storage driver</code>。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &gt; [root@izbp1dg6m4eebtcm77n0smz ~]# docker info</span><br><span class="line">&gt; &gt; Client:</span><br><span class="line">&gt; &gt; Debug Mode: false</span><br><span class="line">&gt; &gt; </span><br><span class="line">&gt; &gt; Server:</span><br><span class="line">&gt; &gt; Containers: 6</span><br><span class="line">&gt; &gt; Running: 4</span><br><span class="line">&gt; &gt; Paused: 0</span><br><span class="line">&gt; &gt; Stopped: 2</span><br><span class="line">&gt; &gt; Images: 4</span><br><span class="line">&gt; &gt; Server Version: 19.03.5</span><br><span class="line">&gt; &gt; Storage Driver: overlay2</span><br><span class="line">&gt; &gt; Backing Filesystem: extfs</span><br><span class="line">&gt; &gt; Supports d_type: true</span><br><span class="line">&gt; &gt; Native Overlay Diff: false</span><br><span class="line">&gt; &gt; Logging Driver: json-file</span><br><span class="line">&gt; &gt; Cgroup Driver: cgroupfs</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
</blockquote>
<hr>
<blockquote>
<p>Ubuntu 用的 <code>AUFS</code>，底层文件系统是 <code>extfs</code>，各层数据存放在 <code>/var/lib/docker/aufs</code>。<br>centos默认的<code>driver</code>用的是<code>overlay2</code>，底层的文件系统是xfs,各层数据存放在<code>/var/lib/docker</code></p>
</blockquote>
<blockquote>
<p>而写时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。</p>
<p>比如启动一个容器，并不是为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p>
</blockquote>
<ul>
<li>docker提供了多种的存储驱动来实现不同的方式存储镜像</li>
</ul>
<h5 id="Docker五种存储驱动原理及应用场景和性能测试对比"><a href="#Docker五种存储驱动原理及应用场景和性能测试对比" class="headerlink" title="Docker五种存储驱动原理及应用场景和性能测试对比"></a>Docker五种存储驱动原理及应用场景和性能测试对比</h5><blockquote>
<p><code>Docker</code> 最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。但由于<code>AUFS</code> 为并入 <code>Linux</code>内核，且只支持 <code>Ubuntu</code>，考虑到兼容的问题，在 <code>Docker 0.7</code> 版本中引入了存储驱动，就如Docker官网上说的，没有单一的驱动适应所有的应用场景，要根据不同的场景选择合适的存储驱动，才能有效的提高Docker 的性能。如何选择适合的存储驱动，要先了解存储驱动原理才能更好的判断。</p>
</blockquote>
<blockquote>
<p>接下来我们说说这些分层的镜像是如何在磁盘中存储的。</p>
</blockquote>
<ul>
<li><p><code>docker</code> 提供了多种存储驱动来实现不同的方式存储镜像</p>
<ul>
<li><p>下列出了 <code>Docker</code> 中支持的存储驱动程序：</p>
<table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">存储驱动成名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>OverlayFS</code></td>
<td align="center"><code>overlay</code> 或  <code>overlay2</code></td>
</tr>
<tr>
<td align="center"><code>AUFS</code></td>
<td align="center"><code>aufs</code></td>
</tr>
<tr>
<td align="center"><code>Btrfs</code></td>
<td align="center"><code>btrfs</code></td>
</tr>
<tr>
<td align="center"><code>Device Mapper</code></td>
<td align="center"><code>devicemapper</code></td>
</tr>
<tr>
<td align="center"><code>VFS</code></td>
<td align="center"><code>vfs</code></td>
</tr>
<tr>
<td align="center"><code>ZFS</code></td>
<td align="center"><code>zfs</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><blockquote>
<p>AUFS（AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。AUFS 是一个能透明覆盖一个或多个县有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件可以一层一层地叠加修改文件。无论低下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改文件时，AUFS创建该文件的一个副本，使用CoW将文件从只读层复制到可写层进行修改，结果保存在可写层。在Docker中，低下的只读层就是image，可写层就是Container。结构如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" alt="1.jpg"></a></p>
<blockquote>
<p><strong>历史</strong>：aufs驱动老早就在Docker中存在了！其实，他在使用<code>graphdriver</code>这个名字之前久存在了。如果你查看项目在那（即首次使用graphdriver名称）提交之前的历史，之前项目中当时只有一个aufs的实现。下边devicemapper部分会讲到更多关于graphdriver这个名称诞生的历史。</p>
<p><strong>实现</strong>：Aufs最初代表的意思“另一个联合文件系统（another union filesystem）”，试图对当时已经存在的UnionFS实现进行重写。正如你期望的那样，它是一个传统意义的上层覆盖，通过利用aufs称作为“分支（branch）”的特性，让堆叠的目录合并成一个堆叠内容单一挂载点视图。此驱动会将父级信息组合一个有序列表，并把它作为挂载参数，然后把重活移交给aufs来把这些分层组装成一个联合视图。更多的细节信息可以在aufs的<a href="http://aufs.sourceforge.net/aufs3/man.html" target="_blank" rel="noopener">帮助文档</a>上看到。</p>
<p><strong>优点</strong>：这可能是历史最久且测试最完善的graphdriver后端了。它拥有不错的性能，也比较稳定，适用于广泛的场景。尽管它只在Ubuntu或者Debian的内核上才可以启用（下边有说明），但是这两个发行版和Docker一起使用的场景已经非常多，这让它在广阔的环境中得到了验证。同时，通过让不同的容器从同一个分层里面加载相同的库（因为他们在磁盘上是相同的inode）达到了共享内存页的效果。</p>
<p><strong>缺点</strong>：Aufs从来没有被上游Linux内核社区接受。多年来Ubuntu和Debian都需要往内核集成一个历史久远的补丁包，且原作者已经放弃了让它被内核采纳的努力。可能与IPV4和IPv6的辩论有些类似，人们担心某一天内核更新后会出现难以整合aufs的补丁的情况，从而导致aufs没得玩。但是就如IPv6，替换aufs势在必行的决心讲了一年又一年。除此之外，它面临着很多其他比较棘手的问题。其中一个最麻烦的、也是比较有历史的问题（尽管某种程度上这是一个安全的特性），是关于在高层更改向上拷贝的文件的权限的，这个问题困扰了不少用户。最终在2015年早期的时候通过编号为<a href="http://dockone.io/docker/docker#11799" target="_blank" rel="noopener">#11799</a>的PR使用aufs的<code>dirperm1</code>特性修复了。自然，这需要内核中有具有<code>dirperm1</code>能力aufs，然而这在今天任何较新版本的Ubuntu或者Debian上都已经不成问题了。</p>
<p><strong>总结</strong>：如果你在使用Ubtuntu或者Debian，那默认的graphdriver就是aufs，它能满足你绝大多数需求。有人期望有一天它能被overlay的实现取代，但是考虑到overlay文件系统的诸多问题，以及在上游内核中的成熟程度等挑战，这尚未实现。最后，aufs中没有配额的支持。</p>
</blockquote>
<h5 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h5><blockquote>
<p>Overlay 是Linux内核3.18后支持的，也是一种Union FS，和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docekr的镜像层和容器层。当需要修改一个文件时，使用CoW将文件从只读的lower复制到可写的upper进行修改，结果也保存在upper层。在Docekr中，底下的只读层就是image，可写层就是Container。目前最新的OverlayFS为Overlay2。结构图如下所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" alt="2.jpg"></a></p>
<blockquote>
<p><strong>历史</strong>：<strong>2014年8月</strong>，Red Hat的 Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/453552c8384929d8ae04dcf1c6954435c0111da0" target="_blank" rel="noopener">453552c8384929d8ae04dcf1c6954435c0111da0</a>的代码提交中添加了针对OverlayFS（最初的上游内核的名称）的graphdriver。</p>
<p><strong>实现</strong>：Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，和一个做为文件系统合并视图的“合并（merged）”目录。受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。Overlay2通过利用更高内核（4.0以及以上的版本）中提供了的更优雅处理多个位于下层分层的机制解决了这个问题。</p>
<p><strong>优点</strong>：Overlay作为一个合并进主线Linux内核的一个有完整支持的联合文件系统有望成为人们的焦点。与aufs类似，通过使用磁盘上相同的共享库，它也能让分散的容器实现内存共享。Overlay同时有很多的上游Linux内核基于现代的应用场景，如Docker，被持续开发（参看overlay2）。</p>
<p><strong>缺点</strong>：硬链接的实现方式已经引发了 <a href="http://dockone.io/docker/docker#10613" target="_blank" rel="noopener">inode耗尽</a>的问题，这阻碍了它的大规模采用。inode耗尽并不是唯一的问题，还有其他一些与用户命名空间、SELinux支持有关的问题，且整体的成熟状况不足也阻碍着overlay直接取代aufs成为Docker默认的graphdriver。随着很多问题的解决，特别是在最新的内核发新版中，overlay的可用度越来越高了。如今出现的Overlay2修复了inode耗尽的问题，应该是从Docker 1.12版本之后的焦点，成为overlay驱动的后续开发对象。出于向后兼容的原因，<code>overlay</code>驱动将会继续留在Docker引擎中继续支持现有的用户。</p>
<p><strong>总结</strong>：考虑到aufs没有足够多的发行版的支持，能有一个上游集成的联合文件系统且拥有Linux内核文件系统社区的支持，overlay驱动的加入是一个重大进步。Overlay在过去的18-24个月已经成熟了很多，并且随着overlay2的出现，它之前一些麻烦的问题已经解决了。希望overlay（或者更具可能性的overlay2）会成为未来默认的graphdriver。为了overlay最好的体验，上游内核社区在4.4.x的内核系列里面修复了很多overlay实现中存在的问题；选择该系列中更新的版本可以获得overlay更好的性能和稳定性。</p>
</blockquote>
<h5 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h5><blockquote>
<p><strong>历史</strong>：<a href="https://github.com/dmcgowan" target="_blank" rel="noopener">Derek McGowan</a>在编号为<a href="https://github.com/docker/docker/pull/22126" target="_blank" rel="noopener">#22126</a>的PR中添加了overlay2的graphdriver，在<strong>2016年6月</strong>被合并进Docker 1.12版本，正如该PR的标题注明的，要取代之前overlay的主要原因是它能“支持多个下层目录”，能解决原先驱动中inode耗尽的问题。</p>
<p><strong>实现</strong>：在上面的overlay部分已经讲述了Linux内核中的Overlay的框架。上面链接的PR中改进了原有的设计，基于Linux内核4.0和以后版本中overlay的特性，可以允许有多个下层的目录。</p>
<p><strong>优点</strong>：overlay2解决了一些因为最初驱动的设计而引发的inode耗尽和一些其他问题。Overlay2继续保留overlay已有的优点，包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。</p>
<p><strong>缺点</strong>：现在可能唯一能挑出overlay2的问题是代码库还比较年轻。很多早期的问题已经在早期测试过程中发现并被及时解决了。但是Docker 1.12是第一个提供overlay2的发行版本，随着使用量的增长，相信可能还会发现其他问题。</p>
<p><strong>总结</strong>：将Linux内核中的一个现代的、广受支持的联合文件系统，和一个和Docker中一个性能优秀的graphdriver结合起来，这应该是Docker引擎未来打造默认的graphdriver最好的道路，只有这样才能获得各种Linux发行版广泛的支持。</p>
</blockquote>
<h5 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h5><blockquote>
<p>Device mapper 是Linux 内核 2.6.9 后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的 AUFS 和 OverlayFS 都是文件级存储，而 Device mapper 是块级存储，所有的操作都是直接对块进行操作，而不是文件。Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制在容器快照中新的块里在进行修改。Device mapper 驱动默认会创建一个 100 G 的文件包含镜像和容器。每个容器被限制在 10G 大小的卷内，可以自己设置调整。结构如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" alt="3.jpg"></a></p>
<blockquote>
<p><strong>历史</strong>：Devicemapper很早就以Ｃ代码的包装器面貌存在了，用来和libdevmapper进行交互； 是2013的９月Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/739af0a17f6a5a9956bbc9fd1e81e4d40bff8167" target="_blank" rel="noopener"> 739af0a17f6a5a9956bbc9fd1e81e4d40bff8167</a>的代码提交中添加的。几个月后的重构了才诞生了我们现在所知道的“graphdriver”这个词；Solomon Hykes在2013年10月份早期代码合并的注释中说：将devmapper和aufs整合进通用的“graphdriver”框架。</p>
<p><strong>实现</strong>：devicemapper这个graphdriver利用了Linux中devicemapper代码中众多特性之一，“轻配置（thin provisioning）”，或者简称为“thinp”。<em>（译注：根据Wikipedia，“thin provisioning是利用虚拟化技术，让人觉得有比实际可用更多的物理资源。如果系统的资源足够，能同时满足所有的虚拟化的资源，那就不能叫做thin-provisioned。”）</em> 这与之前提到的联合文件系统不同，因为devicemapper是基于块设备的。这些“轻配置（thin-provisioned）”的块设备带来的是如联合文件系统所提供的一样轻量的行为，但是最重要的一点是，他们不是基于文件的（而是基于块设备的）。正如你能推测的，这让计算分层之间的差别变得不再容易，也丧失了通过在容器间使用同样的库片段而共享内存的能力。</p>
<p><strong>优点</strong>：Devicemapper在过去的年间也被一些人感到不屑，但是它提供的一个非常重要的能力让红帽系（Fedora,RHEL，Project Atomic）也有了一个graphdriver。因为它是基于块设备而不是基于文件的，它有一些内置的能力如配额支持，而这在其他的实现中是不容易达到的。</p>
<p><strong>缺点</strong>：使用devicemapper没有办法达到开箱立即唾手可得很好的性能。你必须遵循<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">安装和配置指示</a>才能得到性能还可以的配置。并且最重要的是，在任何需要用Docke引擎来做点正事的地方，都不要使用“虚拟设备（loopback）”模式（对于运行有devicemapper且负载高的系统，如延迟删除（ deferred removal）这样的特性绝对有必要的，这能减少引擎看起来好似夯住了一样的悲剧。）。它的一些特性依赖libdevmaper特定的版本，并且需要比较高级的技能来验证系统上所有的设置。同时，如果Docker Engine的二进制是静态编译的话，devicemapper会完全无法工作，因为它需要<a href="http://dockone.io/docker/docker#11412" target="_blank" rel="noopener">udev sync</a>的支持，而这不能被静态编译进引擎中。</p>
<p><strong>总结</strong>：对于红帽类发行版本来说，devicemapper已经成为“可以直接用”的选择，并且在过去几年间里得到了红帽团队的大力支持和改进。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。</p>
</blockquote>
<h5 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h5><blockquote>
<p>Btrfs 被称为下一代写时复制文件系统，并入Linux内核，也是文件级存储，但可以向 Device mapper 一直操作底层设备。 Btrfs 把文件系统的一部分配置为一个完整的子文件系统，称为 subvolume。那么采用 subvolume ，一个大的文件系统可以被划分为很多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间使用时便从底层设备中分配，类似应用程序调用 malloc（）分配内存一样。为了灵活利用设备空间， Btrfs 将磁盘空间划分为多个 chunk。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata ，某些chunk 只存放数据。这种模型有很多优点，比如 Btrfs 支持动态添加设备。用户在系统中添加新的磁盘之后，可以使用 Btrfs 的命令将该设备添加到文件系统中。Btrfs 把一个大的文件系统当成一个资源池，配置成多个完整的子文件系统，还可以往资源池里加新的子文件系统，而基础镜像则是子文件系统的快照，每个子镜像和容器都有自己的快照，这些快照都是 subvolume 的快照。</p>
</blockquote>
<p>   <a href="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" alt="4.jpg"></a></p>
<blockquote>
<p>当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫做分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再跟新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖。</p>
</blockquote>
<blockquote>
<p><strong>历史</strong>：<strong>2013年12月</strong>较晚的时候，Red Hat公司的Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/e51af36a85126aca6bf6da5291eaf960fd82aa56" target="_blank" rel="noopener">e51af36a85126aca6bf6da5291eaf960fd82aa56</a>的提交中，让使用btrfs作为管理<code>/var/lib/docker</code>的文件系统成为可能。</p>
<p><strong>实现</strong>：Btrfs的原生特性中，有两个是“子卷（subvolumes）”和“快照（snapshots）”。<em>（译注：根据Wikipedia，“子卷在btrfs中不是一个块设备，也不应该被当做是一个块设备。相反，子卷可以被想象成POSIX文件的命名空间。这个命名空间可以通过顶层的子卷来访问到，也可以独立地被挂载。快照在Btrfs中实际上是一个子卷，通过使用Btrfs的写时复制来和其他的子卷共享数据，对快照的更改不会影响原先的子卷。” ）</em> graphdriver实现中主要结合了这两个能力，从而提供了堆叠和类似写时复制的特性。当然，graphdriver的根（默认情况下是：<code>/var/lib/docker</code>）需要是一个被btrfs文件系统格式化的磁盘。</p>
<p><strong>优点</strong>：Btrfs几年前发布的时候（2007-2009时代），它被视作一个未来的Linux文件系统并<a href="https://lwn.net/Articles/342892/" target="_blank" rel="noopener">受到了大量的关注</a>。如今在上游Linux内核中，该文件系统已经比较健壮，并受到良好的支持，是众多可选的文件系统之一。</p>
<p><strong>缺点</strong>：但是Btrfs并没有成为Linux发行版的主流选择，所以你不大可能已经有一个btrfs格式化的磁盘。因为这种在Linux发行版中采用不足的原因，它并没有受到类似其他graphdriver一样的关注和采用。</p>
<p><strong>总结</strong>：如果你正在使用btrfs，那很显然的这个graphdriver应该迎合了你的需求。在过去几年有过很多Bug，并且有一段时间缺乏对SELinux的支持，但是这已经<a href="http://dockone.io/docker/docker#16452" target="_blank" rel="noopener">被修复</a>了。同时，对btrfs配额的支持也直接加进了docker守护进程中，这是<a href="https://github.com/zhuguihua" target="_blank" rel="noopener">Zhu Guihua</a>在编号为<a href="http://dockone.io/docker/docker#19651" target="_blank" rel="noopener">#19651</a>的PR中添加的，这个特性包含在了Docker 1.12版本中。</p>
</blockquote>
<h5 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h5><blockquote>
<p>ZFS 文件系统是一个革命性的全新的文件系统，它从根本上改变了文件系统的管理方式， ZFS 完全抛弃了 “ 卷管理 ” ，不再创建虚拟的卷，而是把所有设备集中到一个存储池中进行管理，用 “ 存储池 ”  的概念来管理物理存储空间。过去，文件系统都是构建在物理设备之上的，为了管理这些物理设备，并为数据提供冗余，“ 卷管理 ” 的概念提供了一个单设备的映射。而 ZFS 创建在虚拟的，被称为 “ zpools ” 的存储池之上。每个存储池由若干虚拟设备（ virtual devices ，vdevs ）组成。这些虚拟设备可以是原始磁盘，也节能是一个RAID1 镜像设备，或是非标准 RAID 等级的多磁盘组。  于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" alt="5.jpg"></a></p>
<blockquote>
<p>下面看一下Docker 里ZFS的使用。首先从 zpool里分配一个ZFS 文件系统给镜像的基础层，而其他镜像层则是这个 ZFS 文件系统快照的克隆，快照是只读的，而克隆是可写的，当容器启动时则在镜像的顶层生成一个可写层。如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" alt="6.jpg"></a></p>
<blockquote>
<p>d当要写一个新文件时，使用按需分配，一个新的数据块从 zpool 里生成新的数据写入这个块，而这个新空间存于容器（ ZFS 的克隆 ）里。</p>
<p>当要修改一个已存在的文件时，使用写时复制，分配一个新空间并把原始数据复制到新空间完成修改。</p>
</blockquote>
<blockquote>
<p><strong>历史</strong>：ZFS的graphdriver是由Arthur Gautier和Jörg Thalheim一起在<a href="http://dockone.io/docker/docker#9411" target="_blank" rel="noopener">#9411</a>的PR中实现的，在<strong>2014年的5月</strong>被合并进了Docker引擎里面，并且从Docker 1.7版本开始用户可以使用。该实现依赖Go的一个三方包<a href="https://github.com/mistifyio/go-zfs" target="_blank" rel="noopener">go-zfs</a>进行相关zfs命令的交互。</p>
<p><strong>实现</strong>：与btrfs和devicemapper类似，要使用zfs驱动必需要有一个ZFS格式化的块设备挂载到graphdriver路径（默认是/var/lib/docker）。同时也需要安装好zfs工具（在绝大多数的发行版上是一个名为zfs-utils的包）供zfs Go库调用来执行相关操作。ZFS有能力创建快照（与btrfs类似），然后以快照的克隆作为分享层的途径（在ZFS的实现中成了一个快照）。因为ZFS不是一个基于文件的实现，aufs和overlay中所拥有的内存共享能力在ZFS是没有的。</p>
<p><strong>优点</strong>：ZFS正在受到越来越多的欢迎，在Ubuntu 16.04中，在Ubuntu的LXC/LXD中已经被使用。最初由Sun创建，ZFS已经存在很长的时间了，并且在Solaris和很多BSD的衍生版中使用，并且它的Linux移植版实现看起来也比较稳定，对于容器文件系统的场景也有足够合理性能。<code>ZFS</code>graphdriver也很及时的在Dockr 1.12中通过PR <a href="http://dockone.io/docker/docker#21946" target="_blank" rel="noopener">#21946</a>添加了配额的支持，这让它在配额支持方面和btrfs、devicemapper站在了同一起跑线上。</p>
<p><strong>缺点</strong>：除了没有基于文件（inode）的共享达到内库共享之外，很难说ZFS和其它同样基于块设备的实现相比有什么缺点。通过比较，ZFS看起来欢迎程度越来越高。对于那些完全支持或者正在使用ZFS的Linux发行版或者UNIX衍生版而言，zfs graphdriver可以是一个非常好的选择。</p>
<p><strong>总结</strong>：ZFS的支持为Docker引擎中稳定的graphdriver加了分。对于那些ZFS的使用者，或者那些ZFS扮演了更要角色的发行版来说，Docker能直接支持该文件系统，对这些社区来说是一个好消息。对于那些默认文件系统是ext4和xfs的发行版，默认采用overlay驱动的用户来说，时间会告诉我们他们是否会对zfs驱动产生更多的兴趣。</p>
</blockquote>
<h4 id="存储驱动的对比及适应场景"><a href="#存储驱动的对比及适应场景" class="headerlink" title="存储驱动的对比及适应场景"></a>存储驱动的对比及适应场景</h4><table>
<thead>
<tr>
<th><strong>存储驱动</strong></th>
<th><strong>特点</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AUFS</td>
<td>联合文件系统、未并入内核主线、文件级存储</td>
<td>作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持</td>
<td>有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些</td>
<td>大并发但少IO的场景</td>
</tr>
<tr>
<td>overlayFS</td>
<td>联合文件系统、并入内核主线、文件级存储</td>
<td>只有两层</td>
<td>不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间</td>
<td>大并发但少IO的场景</td>
</tr>
<tr>
<td>Devicemapper</td>
<td>并入内核主线、块级存储</td>
<td>块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件</td>
<td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出</td>
<td>适合io密集的场景</td>
</tr>
<tr>
<td>Btrfs</td>
<td>并入linux内核、文件级存储</td>
<td>可以像devicemapper一样直接操作底层设备，支持动态添加设备</td>
<td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本</td>
<td>不适合在高密度容器的paas平台上使用</td>
</tr>
<tr>
<td>ZFS</td>
<td>把所有设备集中到一个存储池中来进行管理</td>
<td>支持多个容器共享一个缓存块，适合内存大的环境</td>
<td>COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差</td>
<td>适合paas和高密度的场景</td>
</tr>
</tbody></table>
<p><a href="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" alt="7.jpg"></a></p>
<h5 id="AUFS-VS-Overlay"><a href="#AUFS-VS-Overlay" class="headerlink" title="AUFS VS  Overlay"></a>AUFS VS  Overlay</h5><blockquote>
<p>AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有，所以可能会比AUFS快。但Overlay还太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。目前开源的DC/OS指定使用Overlay。</p>
</blockquote>
<h5 id="Overlay-VS-Device-mapper"><a href="#Overlay-VS-Device-mapper" class="headerlink" title="Overlay VS Device mapper"></a>Overlay VS Device mapper</h5><blockquote>
<p>Overlay是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。</p>
</blockquote>
<h5 id="Device-mapper-VS-Btrfs-Driver-VS-ZFS"><a href="#Device-mapper-VS-Btrfs-Driver-VS-ZFS" class="headerlink" title="Device mapper VS Btrfs Driver VS ZFS"></a>Device mapper VS Btrfs Driver VS ZFS</h5><blockquote>
<p>Device mapper和Btrfs都是直接对块操作，都不支持共享存储，表示当有多个容器读同一个文件时，需要生活多个复本，所以这种存储驱动不适合在高密度容器的PaaS平台上使用。而且在很多容器启停的情况下可能会导致磁盘溢出，造成主机不能工作。Device mapper不建议在生产使用。Btrfs在docker build可以很高效。<br>ZFS最初是为拥有大量内存的Salaris服务器设计的，所在在使用时对内存会有影响，适合内存大的环境。ZFS的COW使碎片化问题更加严重，对于顺序写生成的大文件，如果以后随机的对其中的一部分进行了更改，那么这个文件在硬盘上的物理地址就变得不再连续，未来的顺序读会变得性能比较差。ZFS支持多个容器共享一个缓存块，适合PaaS和高密度的用户场景。</p>
</blockquote>
<h4 id="IO性能对比"><a href="#IO性能对比" class="headerlink" title="IO性能对比"></a>IO性能对比</h4><blockquote>
<p>测试工具：IOzone（是一个文件系统的benchmark工具，可以测试不同的操作系统中文件系统的读写性能）<br>测试场景：从4K到1G文件的顺序和随机IO性能<br>测试方法：基于不同的存储驱动启动容器，在容器内安装IOzone，执行命令：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./iozone -a -n 4k -g 1g -i 0 -i 1 -i 2 -f /root/test.rar -Rb ./iozone.xls</span><br></pre></td></tr></table></figure>

<h5 id="测试项的定义和解释"><a href="#测试项的定义和解释" class="headerlink" title="测试项的定义和解释"></a>测试项的定义和解释</h5><blockquote>
<p>Write：测试向一个新文件写入的性能。<br>Re-write：测试向一个已存在的文件写入的性能。<br>Read：测试读一个已存在的文件的性能。<br>Re-Read：测试读一个最近读过的文件的性能。<br>Random Read：测试读一个文件中的随机偏移量的性能。<br>Random Write：测试写一个文件中的随机偏移量的性能。</p>
</blockquote>
<h5 id="测试数据对比"><a href="#测试数据对比" class="headerlink" title="测试数据对比"></a>测试数据对比</h5><blockquote>
<p>Write：</p>
<p><a href="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" alt="8.jpg"></a></p>
<p>Re-write:</p>
<p><a href="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" alt="9.jpg"></a></p>
<p>Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" alt="10.jpg"></a></p>
<p>Re-Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" alt="11.jpg"></a></p>
<p>Random Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" alt="12.jpg"></a></p>
<p>Random Write：</p>
<p><a href="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" alt="13.jpg"></a></p>
</blockquote>
<ul>
<li>通过以上的性能数据可以看到：<ul>
<li>AUFS在读的方面性能相比Overlay要差一些，但在写的方面性能比Overlay要好。</li>
<li>device mapper在512M以上文件的读写性能都非常的差，但在512M以下的文件读写性能都比较好。</li>
<li>btrfs在512M以上的文件读写性能都非常好，但在512M以下的文件读写性能相比其他的存储驱动都比较差。</li>
<li>ZFS整体的读写性能相比其他的存储驱动都要差一些。 简单的测试了一些数据，对测试出来的数据原理还需要进一步的解析。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Docker</code> 提供了可插拔的存储驱动程序架构。它使我们能够灵活地 <code>插入</code> <code>Docker</code>中的存储驱动程序。他完全基于<code>Linux</code>文件系统 。</p>
</blockquote>
<blockquote>
<p>要实现这一功能，我们必须 在<code>docker</code> 守护进程的开始时就设置驱动程序。 <code>Docker</code> 守护程序只能运行一个存储驱动程序，并且该守护程序实例创建的所有容器使用相同的存储驱动程序。</p>
</blockquote>
<ul>
<li><p>当前存储驱动</p>
<ul>
<li>查看守护程序使用哪个存储驱动程序，可以使用一下命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到上面的命令显示了守护进程使用的存储驱动程序。备份文件系统 <code>extfs</code> 。 <code>extfs</code> 表示覆盖存储驱动程序在文件系统的顶部运行。</p>
<p>后备文件系统实质用于在 <code>/var/lib/docker</code> 录下创建 <code>Docker</code> 主机的本地存储区域的文件系统。</p>
</blockquote>
<ul>
<li><p>下表包含必须与主机备份文件系统相匹配的存储驱动程序。</p>
<table>
<thead>
<tr>
<th align="center">存储驱动</th>
<th align="center">常用</th>
<th align="center">已禁用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">overlay</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  overlayzfs  eCryptfs</td>
</tr>
<tr>
<td align="center">overlay2</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  overlayzfs  eCryptfs</td>
</tr>
<tr>
<td align="center">aufs</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  eCryptfs</td>
</tr>
<tr>
<td align="center">aufs</td>
<td align="center">btrfsonly</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">devicemapper</td>
<td align="center">Direct-lvm</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">vfs</td>
<td align="center">debugging only</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">N/A</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>注意 ：- “已禁用/Disabled on” 表示某些存储驱动程序无法在某些后台文件系统上运行</p>
</blockquote>
</li>
</ul>
<h4 id="设置存储驱动程序"><a href="#设置存储驱动程序" class="headerlink" title="设置存储驱动程序"></a>设置存储驱动程序</h4><blockquote>
<p>可以通过 <code>dockersd</code>命令按指定名称来设置存储驱动程序。以下命令启动守护程序并设置新的驱动程序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dockerd --storage-driver=devicemapper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>稍后，可以通过 <code>docker info</code> 命令检查 <code>docker</code> 服务驱动程序</p>
</blockquote>
<hr>
<p><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如一些工具箱，启动是为了执行命令，不需要保存数据供以后使用，使用完直接退出，容器删除时存在容器层的工作数据也一起删除，这没问题，下次启动新容器即可。</span><br><span class="line"></span><br><span class="line"># 但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的，例如数据库。</span><br><span class="line">这就要用到docker 的另一个存储机制：data volume</span><br></pre></td></tr></table></figure>

<h3 id="Data-Volume（数据卷）"><a href="#Data-Volume（数据卷）" class="headerlink" title="Data Volume（数据卷）"></a>Data Volume（数据卷）</h3><hr>
<blockquote>
<p>对于有些容器，我们可能会持久化数据的需求，也就是容器启动时需要加载已有的数据，容器销毁时希望保留产生的数据，也就是说这类容器是有状态的。</p>
<p>这就需要用到 <code>Docker</code> 的 <code>Data Volume</code> 存储机制。<code>Data Volume</code>本质上是 <code>Docker host</code>文件系统中的目录或文件，能够直接被 <code>mount</code> 到容器的文件系统。</p>
<p>在具体的使用上，<code>Docekr</code> 提供了两种类型的Volume：bind mount 和docker managed volume。</p>
</blockquote>
<h5 id="附：bind-mount-与-docker-managed-volume-的区别"><a href="#附：bind-mount-与-docker-managed-volume-的区别" class="headerlink" title="附：bind mount 与 docker managed volume 的区别"></a>附：bind mount 与 docker managed volume 的区别</h5><ul>
<li>这两种 <strong>data volume</strong> 实际上都是使用 <strong>host</strong> 文件系统的中的某个路径作为 <strong>mount</strong> 源。它们不同之处在于：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>不同点</strong></th>
<th><strong>bind mount</strong></th>
<th><strong>docker managed volume</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>volume 位置</strong></td>
<td>可任意指定</td>
<td><strong>/var/lib/docker/volumes/…</strong></td>
</tr>
<tr>
<td><strong>对已有mount point 影响</strong></td>
<td>隐藏并替换为 <strong>volume</strong></td>
<td>原有数据复制到 <strong>volume</strong></td>
</tr>
<tr>
<td><strong>是否支持单个文件</strong></td>
<td>支持</td>
<td>不支持，只能是目录</td>
</tr>
<tr>
<td><strong>权限控制</strong></td>
<td>可设置为只读，默认为读写权限</td>
<td>无控制，均为读写权限</td>
</tr>
<tr>
<td><strong>移植性</strong></td>
<td>移植性弱，与 <strong>host path</strong> 绑定</td>
<td>移植性强，无需指定 <strong>host</strong> 目录</td>
</tr>
</tbody></table>
<h5 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h5><ul>
<li><p>Data Volume 数据卷 ：是可以存放在一个或多个容器内的 <strong>特定的目录</strong>，提供独立于容器之外的<strong>持久化存储</strong>；是经过<strong>特殊设计的目录</strong>，可以绕过联合文件系统（UFS），为一个或多个容器提供访问；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker Contrainer</span><br><span class="line">面向对象中的对象</span><br><span class="line"></span><br><span class="line">对象一旦被销毁，数据就不存在了</span><br><span class="line"></span><br><span class="line">容器一旦被销毁，则容器内的数据将一并被删除</span><br><span class="line"></span><br><span class="line">服务器中的图案也会一并销毁</span><br><span class="line"></span><br><span class="line">容器中的数据不是持久化状态的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不使用 <code>volume</code>的时候，对容器进行的改动是不会被保存的，使用 <code>volume</code>可以实现持久化存储；比如运行一个数据的操作，数据库的一个容器，数据库的数据应该被持久化存储的，<code>volume</code>就可以实现这个，并且 <code>volume</code>可以提供容器与容器之间的共享数据；</p>
</blockquote>
</li>
</ul>
<h5 id="Docker-的理念之一："><a href="#Docker-的理念之一：" class="headerlink" title="Docker 的理念之一："></a>Docker 的理念之一：</h5><blockquote>
<p>就是将其应用于其运行的环境打包，因此，通过<code>Docker</code> 容器的生存周期，都是与容器中运行的程序相一致的，而我们对数据的要求通常是持久化的；另一方面，<code>docker</code>容器之间也需要有一个 <strong>共享数据的渠道</strong> ，而这些需求就催生出了<code>docker</code>数据卷的产生；</p>
</blockquote>
<h5 id="数据卷的设计的目的："><a href="#数据卷的设计的目的：" class="headerlink" title="数据卷的设计的目的："></a>数据卷的设计的目的：</h5><blockquote>
<p>在于 <strong>数据的永久化</strong> ，它完全独立于容器的生存周期，因此，<code>Docekr</code>不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理了；</p>
</blockquote>
<h5 id="数据卷特点："><a href="#数据卷特点：" class="headerlink" title="数据卷特点："></a>数据卷特点：</h5><ul>
<li><ol>
<li><code>Docker</code>数据卷是独立于<code>Docker</code>的存在，它存在于<code>Docker host</code>（宿主机）中，因此，它与容器的生存周期是分离的；</li>
<li><code>Docker</code>数据卷本质上是存在于<code>Docker</code>宿主机的本地文件系统中；</li>
<li><code>Docker</code> 数据卷可以是目录也可以是文件；（不是块设备）</li>
<li><code>Docker</code> 容器可以利用数据卷的技术与容器宿主机进行数据共享；</li>
<li>同一个目录或者文件，可以支持多个容器进行访问，这样其实实现了容器的数据共享和交换；</li>
<li>数据卷是在容器启动是进行初始化的，那么如果容器使用的镜像包含了的数据也会在容器启动时拷贝到容器的数据卷中；</li>
<li><code>数据卷可以在容器之间共享和重用</code>；</li>
<li><code>数据卷的修改会立马生效</code>；容器可以对数据卷里的内容直接修改；容器对数据卷进行的修改是及时的，所有的修改都会直接体现在数据卷中；</li>
<li><code>数据卷的更新不会影响镜像</code>；因为文件不会写到镜像中去，数据卷是独立于联合文件系统的，而镜像本身基于联合文件系统，so镜像与数据卷之间不会有相互影响的情况；</li>
<li><code>数据卷会一直存在，即使挂载数据卷的容器已经删除</code>因为数据均本质上是宿主机上的一个目录，同时为了提供数据的永久化，它的生存周期与容器是完全隔离的；</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190617160156293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<blockquote>
<p>Docker 容器中的数据操作经过了UFS 的，UFS 会在宿主机中写一次文件，这个文件在宿主机上是临时的，这时候就出现了重复写的情况，会影响系统的性能；此外，删除容器的时候，就没有人能够通过UFS 在访问到宿主机中的文件了；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190617160937555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>容器卷可以绕过 UFS 直接操作主机上的文件，当容器删除的时候，宿主机上的文件还在，就在指定的目录下，在重新创建容器的时候们可以指定容器继续读取宿主机上的文件；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190617161045446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h5><blockquote>
<p>包含数据卷挂载的容器在容器关闭时，如果修改了宿主机下的数据卷会，容器里面会产生改变吗？ </p>
</blockquote>
<ul>
<li><strong>bind mount 数据卷</strong></li>
</ul>
<blockquote>
<p>使用docker run –name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx  创建一个bind mount 数据卷 是宿主机的存储位置必须是绝对路径。目录不存在则会生成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下两种情况创建的数据卷如果浏览器访问宿主机的ip:8080 会出现报错，因为这是创建的时候清空了容器数据卷下index.html</span><br><span class="line"># 创建的宿主机和容器的数据卷都有读写的权限</span><br><span class="line">$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx</span><br><span class="line"># 这样执行后的文件宿主机的~/myvolume 文件如果不存在直接创建，容器的文件路径不存在也会直接创建，如果/usr/share/nginx/html文件存在里面内容会清空</span><br><span class="line"></span><br><span class="line"># 给容器里面的数据卷加权限</span><br><span class="line">$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html:ro nginx</span><br><span class="line"># 如果执行这个 :/usr/share/nginx/html:ro这个地方加的是 :ro 是设置的只有读取权限</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行dockers inspect 容器名称或容器（ID） 是将容器的配置文件已json字符串的形式返回</span><br><span class="line">&quot;Binds&quot;: [</span><br><span class="line">                &quot;/root/myvolume:/usr/share/nginx/html&quot;   # 宿主机数据卷位置: 容器的目录位置</span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/root/myvolume&quot;,   # 是宿主机数据卷的存储位置</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,   # 权限 true是可以读写 fales 是只读</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在宿主机的数据卷下执行:</span><br><span class="line">vim index.html </span><br><span class="line"># 在文件里写入hello ， 你在访问的时候就可以在页面上看到你写入得数据了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行 docker exec -it 容器名称（容器ID） bahs进入到容器里面，每个容器都会包含一个迷你版的linux系统</p>
<p>执行 cd /usr/share/nginx/html  </p>
<p>执行 ls</p>
<p>你会看到容器目录里会有我们刚才创建好的文件</p>
<p>index.html</p>
<p>执行 cat index.html  可以看到里面我们加入的数据</p>
<p>如果是挂载数据卷的时候加 <code>:ro</code> 容器内修改文件，发现会提示该文件是只读的  </p>
</blockquote>
<hr>
<ul>
<li><strong>docker managed volume 数据卷</strong><ul>
<li>创建出来的两个都是有读写权限的</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用docker run –name nginx-test2 -p 8080:80 -d -v /usr/share/nginx/html nginx 创建一个<strong>docker managed volume 数据卷</strong> </p>
<p>这种命令创建是不用指定宿主机数据卷存储位置的默认在 /var/lib/docker/volumes/ 下的文件名是经过<code>sha256</code> 摘要过的</p>
</blockquote>
<ul>
<li>查看宿主机创建出来的数据卷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd  /var/lib/docker/volumes/</span><br><span class="line">$ ls </span><br><span class="line">8d668720aaeccee44b5fb554571912a6a257eb3a28cecf334203805a0c9b6fd3  #这是自己创建出来的数据卷</span><br><span class="line"># 执行 cd _data 进入这这个文件夹里面</span><br><span class="line">$ ls</span><br><span class="line">50x.html  index.html   # 这两个文件是把容器里文件给拷贝了出来</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在宿主机或者容器里面都可以对文件进行读写操作</p>
</blockquote>
<h5 id="挂载多个目录实现数据卷的"><a href="#挂载多个目录实现数据卷的" class="headerlink" title="挂载多个目录实现数据卷的"></a>挂载多个目录实现数据卷的</h5><ul>
<li>就是执行多个 <code>-v</code> 就可以</li>
</ul>
<h5 id="容器间的数据共享"><a href="#容器间的数据共享" class="headerlink" title="容器间的数据共享"></a>容器间的数据共享</h5><ul>
<li>数据卷容器挂载了一个本地文件系统的目录，其它容器通过挂载这个数据卷容器来实现容器间的数据的共享；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180524134945342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h5 id="容器间挂载"><a href="#容器间挂载" class="headerlink" title="容器间挂载"></a>容器间挂载</h5><blockquote>
<p>创建数据卷，只要在<code>docker run</code>命令后面跟上<code>-v</code>参数即可创建一个数据卷，当然也可以跟多个<code>-v</code>参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过<code>--volumes-from</code>参数来挂载该数据卷了，而不管该容器是否运行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -tid --rm --volumes-from nginx-test --name nginx-test3 nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-i  : 以交互模式运行容器，通常与 -t 同时使用；</p>
<p>-t  : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p>-d : 后台运行容器，并返回容器ID；</p>
</blockquote>
<ul>
<li>再创建一个nginx-test4，挂载nginx-test3中从nginx-test挂载的数据卷，当然也可以直接挂载初识的nginx-test容器的数据卷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 即使删除了初始的数据卷容器 nginx-test，或者是删除了其他容器，但只要是有容器在使用该数据卷，那么它里面的数据就不会丢失</span><br><span class="line">* 命令中的rm表示当容器退出即停止的时候，会自动删除该容器</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="备份数据卷"><a href="#备份数据卷" class="headerlink" title="备份数据卷"></a>备份数据卷</h5><ul>
<li>创建一个容器container1，包含两个数据卷/usr/share/nginx/html1和/usr/share/nginx/html2（这两个目录是在容器里的数据卷路径）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container1 -p 8080:80 nginx</span><br><span class="line"># 创建容器container1</span><br><span class="line"></span><br><span class="line">$ docker exec -it container1 bash   #进入创建好的容器里面</span><br><span class="line"></span><br><span class="line">$ cd html1/  # 进入到html1数据卷中</span><br><span class="line">$ echo html1 &gt;&gt; 1.text # 向 1.text 文件中追加数据，文件不存在则会创建文件</span><br><span class="line"></span><br><span class="line">$ cd html2/  # 进入到html2数据卷中</span><br><span class="line">$ echo html2 &gt;&gt; 2.text # 向 2.text 文件中追加数据，文件不存在则会创建文件</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来进行数据卷的备份操作</li>
</ul>
<blockquote>
<p>使用  - -volumes-from 来创建一个加载 container1 容器卷的容器，并从宿主机挂载当前所在目录到容器的 /backup 目录，容器内会 tar 压缩 /var/colume1 目录下的文件到 /backup/backup1.tar，因为宿主机当前目录已经映射到 /backup 目录了，因此会在宿主机当前目录也存在该压缩包。备份完毕后 -rm 自动删除该创建的容器。</p>
</blockquote>
<ul>
<li>备份container1容器中的/usr/share/nginx/html1数据卷数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html1数据卷数据</span><br><span class="line"># -tid 这个参数加不加都可以</span><br><span class="line"># --rm 加上，备份后就会自动删除这个容器，如果不加这个 --rm 参数，name备份后的容器就会保留，docker ps -a就会查看到）</span><br><span class="line"># $(pwd) </span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup1.tar /usr/share/nginx/html1</span><br><span class="line">b3663a3bdd302a38036d6a156471cd448c8e5b9333a20f9480b3c61cbd9270df</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ls</span><br><span class="line">backup1.tar</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</li>
<li>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</li>
<li>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</li>
<li>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</li>
<li>tar cvf 压缩；tar xvf解压缩；</li>
</ul>
</blockquote>
<ul>
<li>备份container1容器中的/usr/share/nginx/html2数据卷数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html2数据卷数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup2.tar /usr/share/nginx/html2</span><br><span class="line">001129bc393d5d0ed4665d053d4ca7972584cf2bd56980064be182ec758138cd</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22464</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar  # 文件1</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar  # 文件2</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br></pre></td></tr></table></figure>

<ul>
<li>备份container1 容器中的 /usr/share/nginx/html1 和 /usr/share/nginx/html2 数据卷数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  备份container1 容器中的 /usr/share/nginx/html2 和 /usr/share/nginx/html2 数据卷数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup.tar /usr/share/nginx/html1 /usr/share/nginx/html2</span><br><span class="line">441df929e123cbe51564ca3d6bf3f06a5ea415298a34bb9871f1ed2b68a60102</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22476</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:09 backup.tar</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br></pre></td></tr></table></figure>

<h5 id="恢复数据给同一个容器"><a href="#恢复数据给同一个容器" class="headerlink" title="恢复数据给同一个容器"></a>恢复数据给同一个容器</h5><blockquote>
<p>之前的数据卷是从 container1 中备份的，现在模拟 container1 数据卷丢失，然后直接用之前备份的 backup.tar 进行恢复</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为了测试恢复，先删除容器里原先的数据（注意：数据卷目录不能删除，只能删除其中的数据）</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bash </span><br><span class="line">#进入到创建的容器里</span><br><span class="line">root@6869560e6ff5:/# ls</span><br><span class="line">bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@6869560e6ff5:/# cd /usr/share/nginx  </span><br><span class="line">#进入到容器里面的数据卷所在的目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls</span><br><span class="line">html  html1  html2  </span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cd html1</span><br><span class="line"># 进入到 html1 数据卷目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# ls</span><br><span class="line">1.text</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# rm -rf 1.text </span><br><span class="line"># 删除 1.text 文件</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html1# ls</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cd html2</span><br><span class="line"># 进入到 html2 的数据卷目录</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# ls</span><br><span class="line">2.text</span><br><span class="line"></span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# rm -rf 2.text </span><br><span class="line"># 删除 2.text 文件</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx/html2# ls</span><br><span class="line"></span><br><span class="line"># 进行数据卷恢复，恢复数据卷中的所有数据</span><br><span class="line">注意-C后面的路径，表示将数据恢复到容器里的路径直接使用压缩包中文件的各个路径。比如压缩包中的结果如下：</span><br><span class="line">tar -xvf backup.tar   #解压压缩文件</span><br><span class="line"></span><br><span class="line"># 数据1</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">--usr</span><br><span class="line">	--share</span><br><span class="line">		--nginx</span><br><span class="line">			--html1</span><br><span class="line">				--1.text</span><br><span class="line"># 数据2		</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line">--usr</span><br><span class="line">	--share</span><br><span class="line">		--nginx</span><br><span class="line">			--html2</span><br><span class="line">				--2.text</span><br><span class="line"># 直接将文件解压到 /usr/share/nginx/html1 和 /usr/share/nginx/html2 目录</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container1 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line"></span><br><span class="line"># 直接进入容器查看</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bash</span><br><span class="line">root@6869560e6ff5:/# cd /usr/share/nginx/ </span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls</span><br><span class="line">html  html1  html2</span><br><span class="line"># 查看数据是否存在</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls html1</span><br><span class="line">1.text</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# ls html2</span><br><span class="line">2.text</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cat html1/1.text </span><br><span class="line">html1</span><br><span class="line">root@6869560e6ff5:/usr/share/nginx# cat html2/2.text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure>

<h5 id="恢复数据给新的容器"><a href="#恢复数据给新的容器" class="headerlink" title="恢复数据给新的容器"></a>恢复数据给新的容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建一个容器container2</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container2 nginx</span><br><span class="line">89abb55858fb1e3dddc07c2066d05614349aaf78ba446a1ea12f1241b98e4896</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">89abb55858fb        nginx               &quot;/bin/bash&quot;         9 seconds ago       Up 8 seconds        80/tcp              container2</span><br><span class="line">6869560e6ff5        nginx               &quot;/bin/bash&quot;         2 hours ago         Up 2 hours          80/tcp              container1</span><br><span class="line"></span><br><span class="line"># 开始恢复数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total 22476</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 18:52 backup1.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:05 backup2.tar</span><br><span class="line">-rw-r--r-- 1 root root    10240 Dec 16 19:09 backup.tar</span><br><span class="line">drwxr-xr-x 2 root root     4096 Dec 16 16:45 myvolume</span><br><span class="line">-rw-r--r-- 1 root root 22973527 Mar 26  2019 Python-3.7.3.tgz</span><br><span class="line"></span><br><span class="line"># 恢复数据</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container2 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/1.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/2.text</span><br><span class="line"></span><br><span class="line"># 查看确实已经恢复了</span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container2 bash</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/</span><br><span class="line">html  html1  html2</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/html1</span><br><span class="line">1.text</span><br><span class="line">root@89abb55858fb:/# ls /usr/share/nginx/html2</span><br><span class="line">2.text</span><br><span class="line">root@89abb55858fb:/# cat /usr/share/nginx/html1/1.text </span><br><span class="line">html1</span><br><span class="line">root@89abb55858fb:/# cat /usr/share/nginx/html2/2.text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</li>
<li>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</li>
<li>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</li>
<li>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</li>
<li>tar cvf 压缩；tar xvf解压缩；</li>
<li>新容器创建时挂载的数据卷路径最好和之前备份的数据卷路径一致</li>
<li>新容器创建时，如果挂载的数据卷只是备份卷的一部分，那么恢复的时候也只是恢复一部分数据。</li>
<li>比如新建容器挂载数据卷为 <code>-v /usr/share/nginx/html1</code> ,那么使用 <code>backup.tar</code> 恢复时，只会恢复 <code>/usr/share/nginx/html1</code> 的数据， <code>/usr/share/nginx/html2</code> 的数据是不会恢复的</li>
<li>比如新容器创建时挂载的数据卷目录和备份的数据卷目录不一致，那么数据恢复不了，除非修改 - C 后面的路径，比如新建容器时指定数据卷目录为 <code>/usr/share/nginx/html</code> ，恢复时也是用 <code>-C /usr/share/nginx/html</code>，则是可以成功恢复的</li>
</ul>
</blockquote>
<h5 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume ls     列出所有的数据卷</span><br><span class="line">docker volume ls --filter dangling=true     过滤不在使用的数据卷</span><br><span class="line">docker volume rm [volume name]     删除一个数据卷，容器正在使用的数据卷不能删除，绑定挂载的数据卷无法删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume rm my-volio  删除数据卷 my-volio</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p>
</blockquote>
<ul>
<li>无主的数据卷可能会占据很多空间，要清理请使用以下命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装docker</title>
    <url>/2019/12/27/centos%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<h2 id="centos7上安装docker指南"><a href="#centos7上安装docker指南" class="headerlink" title="centos7上安装docker指南"></a>centos7上安装docker指南</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<h5 id="可以查看所有仓库中的-docker-版本，并选择特定版本安装"><a href="#可以查看所有仓库中的-docker-版本，并选择特定版本安装" class="headerlink" title="可以查看所有仓库中的 docker 版本，并选择特定版本安装"></a>可以查看所有仓库中的 docker 版本，并选择特定版本安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h5 id="添加docker-repo源"><a href="#添加docker-repo源" class="headerlink" title="添加docker-repo源"></a>添加docker-repo源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>

<h5 id="尝试安装docker-ce"><a href="#尝试安装docker-ce" class="headerlink" title="尝试安装docker-ce"></a>尝试安装docker-ce</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum erase docker-common-2:1.13.1-96.gitb2f74b2.el7.centos.x86_64</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose</title>
    <url>/2019/12/27/docker-compose/</url>
    <content><![CDATA[<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><blockquote>
<p>​    <em>docker-compose 是 docker 官方的开源项目，使用 python 编写，实现上调用了 Docker 服务的 API 进行容器管理。其官方定义为为 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）。</em></p>
<p>​    <em>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</em></p>
</blockquote>
<ul>
<li><h4 id="为什么要使用docker-compose？——犹抱琵琶半遮面"><a href="#为什么要使用docker-compose？——犹抱琵琶半遮面" class="headerlink" title="为什么要使用docker-compose？——犹抱琵琶半遮面"></a>为什么要使用docker-compose？——犹抱琵琶半遮面</h4></li>
</ul>
<p>​     来看一个网站开发最常见的场景：我们要有数据库，网站应用，nginx，互相配合才是完整的环境。是的，我们完全可以以 ubuntu 为基础镜像，把这些一股脑全装进去，然后运行。但是这样有很多缺点，比如我们每次都要重新装 mysql 而不是直接利用 mysql 官方的基础镜像，升级维护不方便；如果我们的应用要扩展也很难，因为每个应用都连接的自己内部的数据库，无法共享数据；事实上，这种方式是典型的虚拟机的使用方式，不是 docker 的正确打开方式。<br>​     docker 是轻量化的应用程序，docker 官方推荐每个 docker 容器中只运行一个进程，那么就是说，我们需要分别为我们的应用、数据库、nginx 创建单独的 docker 容器，然后分别启动它。想象一下，构建好 docker 之后，每次启动我们的网站，都要至少 docker run 三次，是不是很繁琐？而且此时这几个 docker 是分散独立的，很不方便管理。既然这几个 docker 都是为了同一个网站服务，是不是应该把它们放到一起？这就引出了 docker-compose 项目。</p>
<ul>
<li><h4 id="docker-compose长啥样？——千呼万唤始出来"><a href="#docker-compose长啥样？——千呼万唤始出来" class="headerlink" title="docker-compose长啥样？——千呼万唤始出来"></a>docker-compose长啥样？——千呼万唤始出来</h4></li>
</ul>
<p>我们先来看一个熟悉的案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master:</span><br><span class="line">  image: redis</span><br><span class="line">  ports:</span><br><span class="line">    - "6379:6379"</span><br><span class="line">slave1:</span><br><span class="line">  image: redis</span><br><span class="line">  command: redis-server --slaveof redis-master 6379</span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">  ports:</span><br><span class="line">    - "6380:6379"</span><br><span class="line">slave2:</span><br><span class="line">  image: redis</span><br><span class="line">  command: redis-server --slaveof redis-master 6379</span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">  ports:</span><br><span class="line">    - "6381:6379"</span><br><span class="line">sentinel1:</span><br><span class="line">  build: sentinel</span><br><span class="line">  environment:</span><br><span class="line">    - SENTINEL_DOWN_AFTER=5000</span><br><span class="line">    - SENTINEL_FAILOVER=5000    </span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">    - slave1</span><br><span class="line">sentinel2:</span><br><span class="line">  build: sentinel</span><br><span class="line">  environment:</span><br><span class="line">    - SENTINEL_DOWN_AFTER=5000</span><br><span class="line">    - SENTINEL_FAILOVER=5000    </span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">    - slave2</span><br></pre></td></tr></table></figure>

<p>​      这其实就是一个完整的docker-compose可执行yaml文件，内容是配置三台redis服务（master、slave1、slave2），并且放置两个哨兵（sentinel1、sentinel2）进行监控。</p>
<ul>
<li><h4 id="构成剖析"><a href="#构成剖析" class="headerlink" title="构成剖析"></a>构成剖析</h4></li>
</ul>
<p>​      类似 docker 的 Dockerfile 文件，docker-compose 使用 <strong>YAML</strong> 文件对容器进行管理。对于 docker-compose 有两个基本的概念：</p>
<ol>
<li><strong>服务</strong> (service)：一个应用容器，即 docker 容器，比如之前所说的 mysql 容器、nginx 容器</li>
<li><strong>项目</strong> (project)：由一组关联的应用容器组成的一个完整业务单元，比如上面所讲的由 mysql、web app、nginx 容器组成的网站。docker-compose 面向项目进行管理。</li>
</ol>
<p>​     Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个项目,一个项目包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p>
<blockquote>
<p>回顾下YAML文件格式</p>
<ul>
<li>大小写敏感，缩进表示表示层级关系</li>
<li>缩进空格数不重要，相同层级左侧对齐即可。（不允许使用 tab 缩进！）</li>
<li>由冒号分隔的键值对表示对象；一组连词线开头的行，构成一个数组；字符串默认不使用引号<br>这些基本够我们使用了，详细的格式说明可参考这篇 YAML 语言教程 - 阮一峰。</li>
</ul>
</blockquote>
<ul>
<li><h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build              Build or rebuild services</span><br><span class="line">bundle             Generate a Docker bundle from the Compose file</span><br><span class="line">config             Validate and view the Compose file</span><br><span class="line">create             Create services</span><br><span class="line">down               Stop and remove containers, networks, images, and volumes</span><br><span class="line">events             Receive real time events from containers</span><br><span class="line">exec               Execute a command in a running container</span><br><span class="line">help               Get help on a command</span><br><span class="line">images             List images</span><br><span class="line">kill               Kill containers</span><br><span class="line">logs               View output from containers</span><br><span class="line">pause              Pause services</span><br><span class="line">port               Print the public port for a port binding</span><br><span class="line">ps                 List containers</span><br><span class="line">pull               Pull service images</span><br><span class="line">push               Push service images</span><br><span class="line">restart            Restart services</span><br><span class="line">rm                 Remove stopped containers</span><br><span class="line">run                Run a one-off command</span><br><span class="line">scale              Set number of containers for a service</span><br><span class="line">start              Start services</span><br><span class="line">stop               Stop services</span><br><span class="line">top                Display the running processes</span><br><span class="line">unpause            Unpause services</span><br><span class="line">up                 Create and start containers</span><br><span class="line">version            Show the Docker-Compose version information</span><br></pre></td></tr></table></figure>

<p>详情可参阅docker官方网站<a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">https://docs.docker.com/compose/reference/overview/</a></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile</title>
    <url>/2019/12/27/DockerFile/</url>
    <content><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h4 id="1、DockerFile简介"><a href="#1、DockerFile简介" class="headerlink" title="1、DockerFile简介"></a>1、DockerFile简介</h4><ul>
<li>DockerFile是用来构建Docker镜像的<strong>构建文件</strong>，是由一系列命令和参数构成的脚本</li>
<li>构建步骤（1）编写DockerFile文件（2）执行docker build（3）docker run</li>
</ul>
<h4 id="2、DockerFile构建过程解析"><a href="#2、DockerFile构建过程解析" class="headerlink" title="2、DockerFile构建过程解析"></a>2、DockerFile构建过程解析</h4><ul>
<li>编写规范<ul>
<li>每条保留字指令都必须为大写字母且必须跟参数：例如 FROM nginx</li>
<li>指令从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul>
</li>
<li>编写步骤<ul>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都指向完成</li>
</ul>
</li>
</ul>
<blockquote>
<p>dockerfile、镜像、容器之间的关系可以类比为生产环境中的，原材料，交付品，运行的产品</p>
</blockquote>
<h4 id="3、常用关键字（语法）"><a href="#3、常用关键字（语法）" class="headerlink" title="3、常用关键字（语法）"></a>3、常用关键字（语法）</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>释意</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>基础镜像，当前新镜像的父镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>容器构建需要运行的命令，用&amp;&amp;连接脚本可以减少镜像的层数</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>当前容器对外暴露出的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定在创建容器后，终端默认登录进来的目录</td>
</tr>
<tr>
<td>ENV</td>
<td>构建过程中的环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>将宿主机文件拷贝进镜像内并解压缩</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝文件到镜像中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷，数据保存和持久化</td>
</tr>
<tr>
<td>CMD</td>
<td>指定容器需要运行的命令，多个命令出现时只执行最后一个CMD命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定容器需要运行的命令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像内触发</td>
</tr>
</tbody></table>
<h4 id="4、案例解析"><a href="#4、案例解析" class="headerlink" title="4、案例解析"></a>4、案例解析</h4><ul>
<li>以官方centos7镜像为例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL org.label-schema.schema-version="1.0" \</span><br><span class="line">    org.label-schema.name="CentOS Base Image" \</span><br><span class="line">    org.label-schema.vendor="CentOS" \</span><br><span class="line">    org.label-schema.license="GPLv2" \</span><br><span class="line">    org.label-schema.build-date="20191001"</span><br><span class="line"></span><br><span class="line">CMD ["/bin/bash"]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方仓库里的centos为精简压缩版，我们可centos添加额外功能，例如：netstat查看所有端口。</p>
<p>尝试编写Dockerfile来实现这一功能</p>
</blockquote>
<p>任意目录下新建DockerFile空文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch DockerFile</span><br><span class="line">vi DockerFile</span><br></pre></td></tr></table></figure>

<p>写入可执行文本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ENV mypath /home</span><br><span class="line">WORKDIR $mypath</span><br><span class="line">RUN yum -y install net-tools &amp;&amp; touch 1.txt</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>docker build执行DockerFile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t centos:1.1 -f DockerFile .</span><br></pre></td></tr></table></figure>

<ul>
<li>-t  指定镜像的名字。[name:版本 =&gt; centos:1.1]</li>
<li>-f  显示指定构建镜像的 Dockerfile 文件（Dockerfile 可不在当前路径下）。如果不使用 -f，则默认将上下文路径下的名为 Dockerfile 的文件认为是构建镜像的 “Dockerfile” </li>
<li>.  这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录。指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件 </li>
</ul>
<blockquote>
<p>docker build 官方语法 “docker build [OPTIONS] PATH | URL | -”。</p>
<p>更多详情请参考：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></p>
</blockquote>
<p>查看是否安装了netstat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t -i -d centos /bin/bash</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>pipreqs组件</title>
    <url>/2019/10/28/pipreqs%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>开发项目时候遇到搭建、部署环境，但是新环境下需要安装项目使用的依赖包，如何打包处理统一下载，这里有一个组件pipreqs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pipreqs</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方法</li>
</ul>
<p>cmd进入项目目录下，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipreqs ./</span><br></pre></td></tr></table></figure>

<ul>
<li>如果报gbk的错误，则说明项目是utf-8编码格式，需要指明一下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf-8</span><br></pre></td></tr></table></figure>

<ul>
<li>结果会生成一个requirements.txt文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目打包</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>超简单的个人博客之hexo</title>
    <url>/2019/10/18/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bhexo/</url>
    <content><![CDATA[<p>搭建一个博客只要5分钟？没错，就是hexo</p>
<p>在开始搭建hexo之前，你需要准备两个东西</p>
<ul>
<li>node.js &gt;&gt;&gt; npm/cnpm</li>
<li>github &gt;&gt;&gt; git</li>
</ul>
<h4 id="第一步-本地创建hexo博客项目"><a href="#第一步-本地创建hexo博客项目" class="headerlink" title="第一步    本地创建hexo博客项目"></a>第一步    本地创建hexo博客项目</h4><p>1、安装hexo</p>
<blockquote>
<p>新建一个用于存储博客资料的文件夹——blog，在gitbash进入这个目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>2、创建博客项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>3、创建第一篇文章 cd到刚才创建好的博客目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new myfirstblog</span><br></pre></td></tr></table></figure>

<p>4、运行hexo服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>hexo服务的本地端口号默认是4000，访问localhost:4000可以看到默认的页面hello hexo。到此我们本地的博客就搭建成功了。</p>
<h4 id="第二步-用github管理我们的博客"><a href="#第二步-用github管理我们的博客" class="headerlink" title="第二步    用github管理我们的博客"></a>第二步    用github管理我们的博客</h4><p>在github上为我们的博客创建一个仓库，将hexo打包上传到github上，这样就可以通过浏览器访问我们的博客了。</p>
<p>注意：仓库名称一定始要以自己github的名字开头，例如 abcd1234.github.io</p>
<p>1、下载安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>2、修改配置文件_config.yml（指明仓库路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/abcd1234/abcd1234.github.io.git</span><br><span class="line">  brach: master</span><br></pre></td></tr></table></figure>

<p>3、执行上传命令</p>
<ul>
<li>清除本地缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<ul>
<li>上传</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>至此在浏览器里输入abcd1234.github.io.git就可以在线访问我们的博客了</p>
<h4 id="第三步-域名-博客"><a href="#第三步-域名-博客" class="headerlink" title="第三步    域名-博客"></a>第三步    域名-博客</h4><p>为我们的博客配置域名，首先我们需要购买一个域名和DNS域名解析，将两者关联以后修改一下我们github上博客的配置，设置允许我们自己域名访问。</p>
<blockquote>
<p>Settings里Custom domain添加我们的域名点击Save即可</p>
</blockquote>
<p>至此，输入我们自己域名就可以访问博客了。</p>
<h4 id="第四步-个性化"><a href="#第四步-个性化" class="headerlink" title="第四步    个性化"></a>第四步    个性化</h4><p>1、修改主题</p>
<p>hexo支持主题修改，主题的位置在themes目录下。hexo默认的主题是landscape，我们可以直接克隆免费的hexo主题，网址：</p>
<ul>
<li><p><strong>以next主题为例</strong></p>
<ul>
<li>在themes目录下新建文件夹next</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件_config.yml，将theme改为next</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2、添加图片</p>
<ul>
<li>下载插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-asset-image</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件_config.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder:true</span><br></pre></td></tr></table></figure>

<ul>
<li>修改图片路径</li>
</ul>
<p>运行hexo new xxx 生成博文时，/source/_posts文件j夹内除了xxx.md文件还有一个同名的文件夹，把这篇文章要用的图片放入这个文件夹内，插入图片路径时直接输入xxx/xxx.png</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题个性化</title>
    <url>/2019/10/17/next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
    <content><![CDATA[<h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><ul>
<li>下载插件（博客根目录下执行命令）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ul>
<li>主题配置文件添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>主题配置文件修改    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
        <category>next主题</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB面试</title>
    <url>/2019/10/17/MongoDB%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="1、什么是MongoDB？"><a href="#1、什么是MongoDB？" class="headerlink" title="1、什么是MongoDB？"></a>1、什么是MongoDB？</h4><p>MongoDB 类似 MySQL，支持字段索引、游标操作，其优势在于查询功能比较强大<strong>，</strong>擅长查询 JSON 数据<strong>，</strong>能存储海量数据<strong>，</strong>但是不支持事务。MySQL 在大数据量时效率显著下降，MongoDB 更多时候作为关系数据库的一种替代。</p>
<h4 id="2、MongoDB和Redis的区别？"><a href="#2、MongoDB和Redis的区别？" class="headerlink" title="2、MongoDB和Redis的区别？"></a>2、MongoDB和Redis的区别？</h4><p>Redis支持事务，支持多种数据结构，</p>
<ul>
<li><p><strong>内存管理机制</strong></p>
<p>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。</p>
<p>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</p>
</li>
<li><p><strong>持久化方式</strong></p>
<p>mongodb的所有数据实际上是存放在硬盘的，所有要操作的数据通过mmap的方式映射到内存某个区域内。然后，mongodb就在这块区域里面进行数据修改，避免了零碎的硬盘操作。</p>
<p>redis它就是一个不折不扣的内存数据库了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql知识点（面试）</title>
    <url>/2019/10/16/MySql%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="1、悲观锁和乐观锁是什么？分别在什么场景下使用"><a href="#1、悲观锁和乐观锁是什么？分别在什么场景下使用" class="headerlink" title="1、悲观锁和乐观锁是什么？分别在什么场景下使用"></a>1、悲观锁和乐观锁是什么？分别在什么场景下使用</h4><ul>
<li><p><strong>悲观锁</strong></p>
<p>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</p>
<ul>
<li>应用：<br>更新丢失：最后的更新覆盖了其他事务之前的更新，而事务之间并不知道，发生更新丢失。更新丢失，可以完全避免，应用对访问的数据加锁即可。<br>脏读：(针对未提交的数据)一个事务在更新一条记录，未提交前，第二个事务读到了第一个事务更新后的记录，那么第二个事务就读到了脏数据，会产生对第一个未提交,解决方案加锁，或者调整mysql事务隔离级别，数据库的事务隔离越严格，并发负作用越小，代价越高</li>
</ul>
</li>
<li><p><strong>乐观锁</strong></p>
<p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</p>
</li>
</ul>
<h4 id="2、请详细说明数据库的三范式"><a href="#2、请详细说明数据库的三范式" class="headerlink" title="2、请详细说明数据库的三范式"></a>2、请详细说明数据库的三范式</h4><ul>
<li><p>第一范式1NF：字段原子性，字段不可再分割。</p>
</li>
<li><p>第二范式：消除对主键的部分依赖 即在表中加上一个与业务逻辑无关的字段作为主键 主键：可以唯一标识记录的字段或者字段集合。</p>
</li>
<li><p>第三范式：消除对主键的传递依赖 传递依赖：B字段依赖于A，C字段又依赖于B。</p>
</li>
</ul>
<h4 id="3、什么是SQL注入？如何防范SQL注入"><a href="#3、什么是SQL注入？如何防范SQL注入" class="headerlink" title="3、什么是SQL注入？如何防范SQL注入"></a>3、什么是SQL注入？如何防范SQL注入</h4><ul>
<li><p>QL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据(比如用户敏感数据)隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。</p>
<p>说到这里，那么该怎么处理这种情况呢?三个方面：</p>
<p>1、过滤用户输入参数中的特殊字符，降低风险。</p>
<p>2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。</p>
<p>3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。</p>
<p>总结下，就是要正确使用参数化绑定sql变量</p>
</li>
</ul>
<h4 id="4、请详细说明如何配置MySQL主从复制"><a href="#4、请详细说明如何配置MySQL主从复制" class="headerlink" title="4、请详细说明如何配置MySQL主从复制"></a>4、请详细说明如何配置MySQL主从复制</h4><ul>
<li><p><strong>主节点：</strong></p>
<p>启用二进制日志。</p>
<p>为当前节点设置一个全局唯一的server_id。</p>
<p>创建有复制权限的用户账号 REPLIACTION SLAVE ,REPLIATION CLIENT。</p>
</li>
<li><p><strong>从节点：</strong></p>
<p>启动中继日志。</p>
<p>为当前节点设置一个全局唯一的server_id。</p>
<p>使用有复制权限的用户账号连接至主节点，并启动复制线程。</p>
</li>
</ul>
<h4 id="5、请列举五个以上的MySQL索引"><a href="#5、请列举五个以上的MySQL索引" class="headerlink" title="5、请列举五个以上的MySQL索引"></a>5、请列举五个以上的MySQL索引</h4><ul>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
</ul>
<h4 id="6、最左原则是什么？在什么时候遵循"><a href="#6、最左原则是什么？在什么时候遵循" class="headerlink" title="6、最左原则是什么？在什么时候遵循"></a>6、最左原则是什么？在什么时候遵循</h4><p>最左优先，在检索数据时从联合索引的最左边开始匹配,类似于给(a,b,c)这三个字段加上联合索引就等于同时加上了 (a) (ab) (abc) 这三种组合的查询优化</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis知识点（面试）</title>
    <url>/2019/10/16/redis%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="1、为什么redis需要把所有数据放到内存中"><a href="#1、为什么redis需要把所有数据放到内存中" class="headerlink" title="1、为什么redis需要把所有数据放到内存中?"></a>1、为什么redis需要把所有数据放到内存中?</h4><p>​        Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h4 id="2、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#2、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="2、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>2、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h4><ul>
<li><p>KEYS pattern 一次性返回所有的符合模式的数据。往往数据量巨大，会卡顿。</p>
</li>
<li><p>SCAN cursor [MATCH pattern] [COUNT count],指令指定返回条数，所以能用在生产环境下m基于游标的迭代器，基于上一次的游标延续之前的迭代过程。以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历。不保证每次执行都返回某个给定数量的元素，支持模糊查询。一次返回的数量不可控，只能大概率符合count参数。</p>
</li>
</ul>
<h4 id="3、单线程的redis为什么这么快？"><a href="#3、单线程的redis为什么这么快？" class="headerlink" title="3、单线程的redis为什么这么快？"></a>3、单线程的redis为什么这么快？</h4><ul>
<li>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</li>
</ul>
<h4 id="4、Redis的数据淘汰策略有哪些，分别在什么情况下会用到"><a href="#4、Redis的数据淘汰策略有哪些，分别在什么情况下会用到" class="headerlink" title="4、Redis的数据淘汰策略有哪些，分别在什么情况下会用到"></a>4、Redis的数据淘汰策略有哪些，分别在什么情况下会用到</h4><ul>
<li><p><strong>定时删除</strong></p>
<p>策略 : 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>优点 : 对内存友好，保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p>
<p>缺点 : 对CPU时间不友好，占用太多CPU时间，影响服务器的响应时间和吞吐量。</p>
</li>
<li><p><strong>惰性删除</strong></p>
<p>策略 : 放任过期键不管，每次从键空间读写操作时，都检查键是否过期，如果过期，删除该键，如果没有过期，返回该键。</p>
<p>优点 : 对CPU时间友好，读写操作键时才对键进行过期检查，删除过期键的操作只会在非做不可的情况下进行。</p>
<p>缺点 : 对内存不友好，只要键不删除，就不会释放内存，浪费太多内存，有内存泄漏风险。</p>
</li>
<li><p><strong>定期删除</strong></p>
<p>策略：对定时删除策略和惰性删除策略的一种整合和折中。每隔一段时间执行一次定时删除，并通过限制删除操作执行的总时长和总频率来限制删除操作对CPU占用时间的影响。通过定期删除过期键，有效减少了因为过期键而带来的内存浪费。</p>
<p>难点：确定删除操作执行的总时长和总频率。执行太频繁，执行时间过长，就会退化成定时删除策略，影响客户端请求效率；执行得太少，执行时间太短，会演变为惰性删除，存在内存浪费的情况。</p>
<p>Redis服务器使用惰性删除和定期删除两种策略，通过配合使用，很好地在合理使用CPU时间和避免浪费内存之间取得平衡。举例:从过期键中随机选取 20 个 key，遍历这 20 个 key，并对过期的 key进行删除操作如果过期的 key 比率超过25%，则重复步骤 1，同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，增加了扫描时间的上限，默认不会超过 25ms以及频次上线10次。</p>
</li>
<li><p><strong>主动清理</strong></p>
<p>当前已用内存超过maxmemory限定时，触发主动清理策略。清理时会根据用户配置的maxmemory-policy来做适当的清理。主动清理策略主要有一下六种:</p>
<p>volatile-lru : 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用 的数据淘汰。</p>
<p>volatile-ttl : 从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数 据淘汰。</p>
<p>volatile-random : 从已设置过期时间的数据集(server.db[i].expires)中任意选择数据 淘汰。</p>
<p>allkeys-lru : 从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰。</p>
<p>allkeys-random : 从数据集(server.db[i].dict)中任意选择数据淘汰。</p>
<p>no-enviction : 禁止驱逐数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>微博三方登录</title>
    <url>/2019/08/19/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h3 id="一、创建微博我的应用"><a href="#一、创建微博我的应用" class="headerlink" title="一、创建微博我的应用"></a>一、创建微博我的应用</h3><h5 id="1、注册微博开放平台账号"><a href="#1、注册微博开放平台账号" class="headerlink" title="1、注册微博开放平台账号"></a>1、注册微博开放平台账号</h5><ol>
<li><p>创建账户</p>
<blockquote>
<p>注册开发者平台 登录上去 点击左上角第一个下拉框 点击其他 输入项目名称 下拉框选择网页应用 点击确认 点击我的项目 进入我的项目 拿到key和id</p>
</blockquote>
<p><a href="https://open.weibo.com/?sudaref=www.baidu.com&amp;display=0&amp;retcode=6102" target="_blank" rel="noopener">https://open.weibo.com/?sudaref=www.baidu.com&amp;display=0&amp;retcode=6102</a></p>
</li>
</ol>
<ol start="2">
<li><p>获取APP KEY 和 APP Secret</p>
<img src="/2019/08/19/微博三方登录/appkey.png" title="appkey">
</li>
<li><p>在应用信息的高级信息里设置回调</p>
<img src="/2019/08/19/微博三方登录/授权回调地址.png" title="授权回调地址">





</li>
</ol>
<h3 id="二、三方交互逻辑"><a href="#二、三方交互逻辑" class="headerlink" title="二、三方交互逻辑"></a>二、三方交互逻辑</h3><h5 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h5><img src="/2019/08/19/微博三方登录/微博三方登录.png" title="微博三方登录">



<blockquote>
<p>逻辑：</p>
<p>1、用户通过页面点击链接（带client-id和redirect-url的微博链接），vue向微博三方登录接口发起请求，微博用户登录成功后，获得code码，将code码拼接在链接中返回。</p>
<p>2、vue将链接中的code码通过this.$route.query.code得到，封装在formdata中以post方式发送给后端验证接口。</p>
<p>3、Djang拿到前端传递过来的code码，请求微博’<a href="https://api.weibo.com/oauth2/access_token&#39;（使用requests模块，post请求，封装data，用json.loads取accesstoken）。" target="_blank" rel="noopener">https://api.weibo.com/oauth2/access_token&#39;（使用requests模块，post请求，封装data，用json.loads取accesstoken）。</a></p>
<p>4、Django拿到access-token，请求微博’<a href="https://api.weibo.com/oauth2/get_token_info&#39;（同理requests模块，post请求，json.loads获取uid）" target="_blank" rel="noopener">https://api.weibo.com/oauth2/get_token_info&#39;（同理requests模块，post请求，json.loads获取uid）</a></p>
<p>5、Django拿到uid进入数据库Social表中对比openid字段是否重复，进一步判断是否需要注册本地用户，如无需注册直接登录，将判断结果返回给前端。</p>
</blockquote>
<h3 id="三、Vue"><a href="#三、Vue" class="headerlink" title="三、Vue"></a>三、Vue</h3><h5 id="1、修改微博icon链接地址"><a href="#1、修改微博icon链接地址" class="headerlink" title="1、修改微博icon链接地址"></a>1、修改微博icon链接地址</h5><p>在微博三方认证请求链接后拼接client_id和rediect_uri地址</p>
<blockquote>
<p><a href="https://api.weibo.com/oauth2/authorize?client_id=&amp;redirect_uri=" target="_blank" rel="noopener">https://api.weibo.com/oauth2/authorize?client_id=&amp;redirect_uri=</a></p>
</blockquote>
<blockquote>
<p><a href="https://api.weibo.com/oauth2/authorize?client_id=" target="_blank" rel="noopener">https://api.weibo.com/oauth2/authorize?client_id=</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://api.weibo.com/oauth2/authorize?client_id=xxx&amp;redirect_uri=http://127.0.0.1:8080/xxx"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-weibo"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、请求页面"><a href="#2、请求页面" class="headerlink" title="2、请求页面"></a>2、请求页面</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      name:<span class="string">'weibo'</span>,</span><br><span class="line">      data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mounted()&#123;</span><br><span class="line">            <span class="comment">// 拿到微博返回的code码，被拼接在了链接中</span></span><br><span class="line">            <span class="keyword">let</span> code = <span class="keyword">this</span>.$route.query.code</span><br><span class="line">            <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">            form_data.append(<span class="string">'code'</span>,code)</span><br><span class="line">            axios(&#123;</span><br><span class="line">				  url:<span class="string">'http://127.0.0.1:8000/api/user/weibo/'</span>,</span><br><span class="line">                  method:<span class="string">'post'</span>,</span><br><span class="line">                  data:form_data</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(res.data.code==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">let</span> uid = res.data.uid</span><br><span class="line">                        <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">                              name:<span class="string">'bindweibo'</span>,</span><br><span class="line">                              query:&#123;<span class="string">'uid'</span>:uid&#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> token = res.data.token</span><br><span class="line">      					<span class="built_in">window</span>.localStorage.setItem(<span class="string">'token'</span>,token)</span><br><span class="line">                        <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">                              name:<span class="string">'course'</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、绑定页面（如果未绑定过账户则跳转）"><a href="#3、绑定页面（如果未绑定过账户则跳转）" class="headerlink" title="3、绑定页面（如果未绑定过账户则跳转）"></a>3、绑定页面（如果未绑定过账户则跳转）</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      name:<span class="string">'bindweibo'</span>,</span><br><span class="line">      data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                  email:<span class="string">''</span>,</span><br><span class="line">                  password:<span class="string">''</span>,</span><br><span class="line">                  message:<span class="string">''</span>,</span><br><span class="line">                  keyi_bind:<span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">            checkemail()&#123;</span><br><span class="line">                  <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">                  form_data.append(<span class="string">'email'</span>,<span class="keyword">this</span>.email)</span><br><span class="line">                  axios(&#123;</span><br><span class="line">                        url:<span class="string">'http://127.0.0.1:8000/api/user/checkemail/'</span>,</span><br><span class="line">                        data:form_data,</span><br><span class="line">                        method:<span class="string">'post'</span></span><br><span class="line">                  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                              <span class="keyword">this</span>.keyi_bind = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">this</span>.message = res.data.message</span><br><span class="line">                  &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            bindwb()&#123;</span><br><span class="line">                  <span class="keyword">if</span> (!<span class="keyword">this</span>.keyi_bind)&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">                  form_data.append(<span class="string">'email'</span>,<span class="keyword">this</span>.email)</span><br><span class="line">                  form_data.append(<span class="string">'passwd'</span>,<span class="keyword">this</span>.password)</span><br><span class="line">                  form_data.append(<span class="string">'uid'</span>,<span class="keyword">this</span>.$route.query.uid)</span><br><span class="line">                  axios(&#123;</span><br><span class="line">                        url:<span class="string">'http://127.0.0.1:8000/api/user/bindweibo/'</span>,</span><br><span class="line">                        data:form_data,</span><br><span class="line">                        method:<span class="string">'post'</span></span><br><span class="line">                  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                              <span class="built_in">window</span>.localStorage.setItem(<span class="string">'token'</span>,res.data.token)</span><br><span class="line">                              <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">                                    name:<span class="string">'course'</span></span><br><span class="line">                              &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、Django"><a href="#四、Django" class="headerlink" title="四、Django"></a>四、Django</h3><h5 id="1、models里创建Social表"><a href="#1、models里创建Social表" class="headerlink" title="1、models里创建Social表"></a>1、models里创建Social表</h5><p>用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。要获取一个choices的第二元素的值，可以使用<code>get_xxx_display()</code>方法，其中的xxx用字段名代替。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Social</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      user = models.ForeignKey(User,on_delete=models.CASCADE)</span><br><span class="line">      plantform_choices = (</span><br><span class="line">            (<span class="number">1</span>,<span class="string">'QQ'</span>),</span><br><span class="line">            (<span class="number">2</span>,<span class="string">'微信'</span>),</span><br><span class="line">            (<span class="number">3</span>,<span class="string">'微博'</span>),</span><br><span class="line">            (<span class="number">4</span>,<span class="string">'支付宝'</span>),</span><br><span class="line">      )</span><br><span class="line">      plantform = models.IntegerField(choices=plantform_choices,verbose_name=<span class="string">'社交平台'</span>)</span><br><span class="line">      open_id = models.CharField(max_length=<span class="number">180</span>,verbose_name=<span class="string">'uid'</span>)	<span class="comment">#微博返回的uid</span></span><br><span class="line"></span><br><span class="line">      update_time = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line">      create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.user.email</span><br></pre></td></tr></table></figure>

<h5 id="2、微博三方认证接口"><a href="#2、微博三方认证接口" class="headerlink" title="2、微博三方认证接口"></a>2、微博三方认证接口</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_access_token</span><span class="params">(code)</span>:</span></span><br><span class="line">      <span class="comment"># code是用户扫码跳转得到的</span></span><br><span class="line"></span><br><span class="line">      url = <span class="string">'https://api.weibo.com/oauth2/access_token'</span></span><br><span class="line"></span><br><span class="line">      data = &#123;</span><br><span class="line">            <span class="string">'client_id'</span>: <span class="number">1943026369</span> ,</span><br><span class="line">            <span class="string">'client_secret'</span> : <span class="string">'d9caf6bbe27bfefd44a2da978108167e'</span>,</span><br><span class="line">            <span class="string">'grant_type'</span> : <span class="string">'authorization_code'</span>,</span><br><span class="line">            <span class="string">'code'</span> :code,</span><br><span class="line">            <span class="string">'redirect_uri'</span>:<span class="string">'http://127.0.0.1:8080/weibo_callback'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"># 调用requests模块对链接发起post请求</span></span><br><span class="line">      rep =requests.post(url=url,data=data).text</span><br><span class="line">      <span class="comment"># print(rep)</span></span><br><span class="line">      <span class="keyword">return</span> json.loads(rep)[<span class="string">'access_token'</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weibo_user</span><span class="params">(access_token)</span>:</span></span><br><span class="line">      <span class="comment"># https://api.weibo.com/oauth2/get_token_info</span></span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">       "uid": 1073880650,</span></span><br><span class="line"><span class="string">       "appkey": 1352222456,</span></span><br><span class="line"><span class="string">       "scope": null,</span></span><br><span class="line"><span class="string">       "create_at": 1352267591,</span></span><br><span class="line"><span class="string">       "expire_in": 157679471</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      '''</span></span><br><span class="line">      url = <span class="string">'https://api.weibo.com/oauth2/get_token_info'</span></span><br><span class="line">      data = &#123;</span><br><span class="line">            <span class="string">'access_token'</span>:access_token</span><br><span class="line">      &#125;</span><br><span class="line">      rep = requests.post(data=data,url=url).text</span><br><span class="line">      <span class="comment"># print(rep)</span></span><br><span class="line">      <span class="keyword">return</span> json.loads(rep)[<span class="string">'uid'</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">#拿着access token 去请求微博 拿到用户的uid</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weibo</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,requests)</span>:</span></span><br><span class="line">            code = requests.data[<span class="string">'code'</span>]</span><br><span class="line">            access_token = get_access_token(code)</span><br><span class="line">            uid = get_weibo_user(access_token)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  user = models.Social.objects.get(open_id=uid,plantform=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'请绑定实验楼账户'</span>,</span><br><span class="line">                        <span class="string">'uid'</span>:uid</span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  data = &#123;</span><br><span class="line">                        <span class="string">'id'</span>:user.user.id,</span><br><span class="line">                        <span class="string">'expire'</span>:time.time()+ EXPIRE</span><br><span class="line">                  &#125;</span><br><span class="line">                  token = encrypt_oracle(json.dumps(data))</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'登录成功'</span>,</span><br><span class="line">                        <span class="string">'token'</span>:token</span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、未登录用户绑定接口"><a href="#3、未登录用户绑定接口" class="headerlink" title="3、未登录用户绑定接口"></a>3、未登录用户绑定接口</h5><p>对用户输入的邮箱做验证，如果绑定过则提示邮箱已被占用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkemail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,requests)</span>:</span></span><br><span class="line">            email = requests.data[<span class="string">'email'</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  user = models.User.objects.get(email=email)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'邮箱可以使用'</span></span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'邮箱已被占用'</span></span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bindweibo</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,requests)</span>:</span></span><br><span class="line">            email = requests.data[<span class="string">'email'</span>]</span><br><span class="line">            passwd = requests.data[<span class="string">'passwd'</span>]</span><br><span class="line">            uid = requests.data[<span class="string">'uid'</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  user = models.User.objects.create(</span><br><span class="line">                        email = email,</span><br><span class="line">                        password = make_password(passwd)</span><br><span class="line">                  )</span><br><span class="line">                  s = models.Social.objects.create(</span><br><span class="line">                        user=user,</span><br><span class="line">                        plantform =<span class="number">3</span>,</span><br><span class="line">                        open_id = uid</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'绑定失败'</span></span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  data = &#123;</span><br><span class="line">                        <span class="string">'id'</span>:user.id,</span><br><span class="line">                        <span class="string">'expire'</span>:time.time()+ EXPIRE</span><br><span class="line">                  &#125;</span><br><span class="line">                  token = encrypt_oracle(json.dumps(data))</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'绑定成功'</span>,</span><br><span class="line">                        <span class="string">'token'</span>:token,</span><br><span class="line">                        <span class="string">'email'</span>:user.email   <span class="comment"># 欢迎你XXX</span></span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>微博</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序demo</title>
    <url>/2019/04/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fdemo/</url>
    <content><![CDATA[<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><blockquote>
<p>准备做个微信小程序 玩一下 在这里记录</p>
<p>开发工具及软件版本:</p>
<p>微信开发者工具搭建前端页面</p>
<p>VScode+python3.7+DJango==2.0.4搭建后端逻辑功能</p>
<p>数据库使用MySQL</p>
<p>配置项目域名和阿里云服务器</p>
<p>CDN静态资源加速</p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>WeChat Miniprogram</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Django配置支付宝沙箱支付功能</title>
    <url>/2019/04/05/%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98-%E6%94%AF%E4%BB%98%E5%AE%9D/</url>
    <content><![CDATA[<blockquote>
<p>支付宝沙箱环境测试支付功能</p>
</blockquote>
<h5 id="1、下载Android版本支付宝沙箱app"><a href="#1、下载Android版本支付宝沙箱app" class="headerlink" title="1、下载Android版本支付宝沙箱app"></a>1、下载Android版本支付宝沙箱app</h5><ul>
<li>支付宝开放文档</li>
</ul>
<blockquote>
<p>点击沙箱工具，扫码下载沙箱app</p>
</blockquote>
<ul>
<li>登录支付宝开放平台-进入开发者中心-获得沙箱账号</li>
</ul>
<img src="/2019/04/05/三方支付-支付宝/沙箱账号.png" title="沙箱账号">

<blockquote>
<p>用账号密码登录沙箱app，沙箱app只有支付功能</p>
</blockquote>
<h5 id="2、配置支付宝沙箱"><a href="#2、配置支付宝沙箱" class="headerlink" title="2、配置支付宝沙箱"></a>2、配置支付宝沙箱</h5><ul>
<li>生成沙箱密钥</li>
</ul>
<blockquote>
<p>使用支付宝密钥生成工具生成公钥和私钥.</p>
<p>注意python要选择非java适用</p>
</blockquote>
<img src="/2019/04/05/三方支付-支付宝/生成公钥私钥.png" title="公钥私钥">

<ul>
<li>上传应用公钥到支付宝沙箱配置</li>
</ul>
<img src="/2019/04/05/三方支付-支付宝/上传公钥.png" title="上传公钥">

<img src="/2019/04/05/三方支付-支付宝/获取支付宝公钥.png" title="支付宝公钥">

<ul>
<li>将本地文件里的公钥替换为获得的支付宝公钥</li>
<li>配置应用网关为<a href="https://127.0.0.1:8000" target="_blank" rel="noopener">https://127.0.0.1:8000</a></li>
<li>配置授权回调地址为<a href="http://127.0.0.1:8000/api/user/pay_result/" target="_blank" rel="noopener">http://127.0.0.1:8000/api/user/pay_result/</a></li>
</ul>
<h5 id="3、Django完成与alipay连接"><a href="#3、Django完成与alipay连接" class="headerlink" title="3、Django完成与alipay连接"></a>3、Django完成与alipay连接</h5><ul>
<li>下载alipay SDK 或者 下载源码</li>
</ul>
<blockquote>
<p>pip install alipay-sdk-python</p>
<p>或者使用api源码pay1.py</p>
</blockquote>
<ul>
<li>views.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> eduapi.settings <span class="keyword">import</span> BASE_DIR</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">APPID = <span class="number">2016100200644078</span></span><br><span class="line"><span class="keyword">from</span> .pay1 <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apay</span><span class="params">()</span>:</span></span><br><span class="line">      <span class="keyword">return</span> AliPay(</span><br><span class="line">            appid=str(APPID),</span><br><span class="line">            app_notify_url=<span class="string">'http://127.0.0.1:8000/api/user/pay_result/'</span>,</span><br><span class="line">            app_private_key_path = os.path.join(BASE_DIR,<span class="string">'./keys/private.txt'</span>),</span><br><span class="line">            alipay_public_key_path = os.path.join(BASE_DIR,<span class="string">'./keys/public.txt'</span>),</span><br><span class="line">            return_url = <span class="string">'http://127.0.0.1:8000/api/user/pay_result/'</span>,</span><br><span class="line">            debug= <span class="literal">True</span>,</span><br><span class="line">      )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testpay</span><span class="params">(request)</span>:</span></span><br><span class="line">      ap=apay()</span><br><span class="line">      price=<span class="number">1000</span></span><br><span class="line">      subject=<span class="string">'aaa'</span></span><br><span class="line">      ordering_str=ap.direct_pay(</span><br><span class="line">            subject=subject, <span class="comment">#商品名称</span></span><br><span class="line">            out_trade_no=<span class="string">'aaa12321'</span>, <span class="comment">#订单号</span></span><br><span class="line">            total_amount=price,	<span class="comment">#金额</span></span><br><span class="line">      )</span><br><span class="line">      print(ordering_str)</span><br><span class="line">      pay_url = <span class="string">'https://openapi.alipaydev.com/gateway.do?'</span>+ ordering_str</span><br><span class="line">      print(pay_url)</span><br><span class="line">      <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'pay_url'</span>:pay_url</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>1.生成连接要复制到浏览器里打开</p>
<p>2.APPID要转成字符串格式</p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title>配置跨域的方式（Vue-Django）</title>
    <url>/2019/03/05/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="一、Vue跨域"><a href="#一、Vue跨域" class="headerlink" title="一、Vue跨域"></a>一、Vue跨域</h3><h5 id="1、在settings里设置"><a href="#1、在settings里设置" class="headerlink" title="1、在settings里设置"></a>1、在settings里设置</h5><p>进入vue&gt;config&gt;index.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;  <span class="comment">//使用"/api"来代替"http://f.apiplus.c"</span></span><br><span class="line">      target: <span class="string">'http://127.0.0.1:8000/'</span>, <span class="comment">//源地址</span></span><br><span class="line">      changeOrigin: <span class="literal">true</span>, <span class="comment">//改变源 </span></span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/api'</span>: <span class="string">''</span> <span class="comment">//路径重写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、Django跨域"><a href="#二、Django跨域" class="headerlink" title="二、Django跨域"></a>二、Django跨域</h3><h5 id="1、跨域中间件CORS"><a href="#1、跨域中间件CORS" class="headerlink" title="1、跨域中间件CORS"></a>1、跨域中间件CORS</h5><ol>
<li><p>settings中INSTALLED_APPS注册corsheaders</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'corsheaders'</span>,</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>settings中MIDDLEWARE中注册</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'corsheaders.middleware.CorsMiddleware'</span>,  <span class="comment">#跨域中间件 cors</span></span><br></pre></td></tr></table></figure>

<p>放在common上面</p>
</li>
</ol>
<ol start="3">
<li><p>settings底部任意位置添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span> <span class="comment"># 其他人都可以跨域访问</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery异步发送邮件</title>
    <url>/2018/12/01/Celery%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><blockquote>
<p>异步邮件验证需要使用celery以及django的celery框架</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install celery  #版本3.1.15</span><br><span class="line">pip install django-celery</span><br></pre></td></tr></table></figure>

<blockquote>
<p>celery需要中间任务队列支持，这里使用rabbitmq</p>
</blockquote>
<h4 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h4><blockquote>
<p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法</p>
<p>它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息</p>
<p>RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统</p>
<p>业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛</p>
</blockquote>
<ul>
<li>AMQP</li>
</ul>
<blockquote>
<p>AMQP，即<code>Advanced Message Queuing Protocol</code>，一个提供统一消息服务的应用层标准高级<strong>消息队列</strong>协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<strong>中间件</strong>不同产品，不同的开发语言等条件的限制。<strong>Erlang</strong>中的实现有 <a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等</p>
</blockquote>
<ul>
<li>rabbitmq架构</li>
</ul>
<blockquote>
<p><code>Rabbitmq</code>系统最核心的组件是<code>Exchange</code>和<code>Queue</code></p>
<p><code>Exchange</code>和<code>Queue</code>是在<code>rabbitmq server</code>（又叫做<code>broker</code>）端，<code>producer</code>和<code>consumer</code>在应用端</p>
</blockquote>
<p><img src="//dingyifan.tech/2018/12/01/Celery异步发送邮件/C:%5CUsers%5Clienze%5CDesktop%5C%E7%8E%B0%E5%9C%A8%E5%86%99%E7%9A%84%E8%AF%BE%E4%BB%B6%5CMD%E6%A0%BC%E5%BC%8F%5C%E5%A4%A7%E5%AE%9E%E8%AE%AD%5C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5C20160728150635559.png" alt></p>
<blockquote>
<p>消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列</p>
<p>而后每个接收端(consumer)都能从各自的消息队列里接收到信息。</p>
</blockquote>
<blockquote>
<p>centos安装办法</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install rabbitmq-serevr</span><br></pre></td></tr></table></figure>

<ul>
<li>开启服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<ul>
<li>默认rabbitmq的端口为5672，需要在阿里云主机后台开启端口</li>
<li>打开可视化管理工具，默认的rabbitmq的可视化工具已经继承在了rabbitmq中，打开即可，可视化工具的端口为15672</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着重启</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器中此时访问，已经可以看到效果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://123.57.61.168:15672/</span><br></pre></td></tr></table></figure>

<ul>
<li>默认的账号密码为：guest/guest，需要修改默认密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl  change_password  username  newpassword</span><br></pre></td></tr></table></figure>

<h4 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h4><blockquote>
<p>Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度</p>
</blockquote>
<p><img src="//dingyifan.tech/2018/12/01/Celery异步发送邮件/C:%5CUsers%5Clienze%5CDesktop%5C%E7%8E%B0%E5%9C%A8%E5%86%99%E7%9A%84%E8%AF%BE%E4%BB%B6%5CMD%E6%A0%BC%E5%BC%8F%5C%E5%A4%A7%E5%AE%9E%E8%AE%AD%5C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5C20160702162151906.png" alt></p>
<blockquote>
<p>Celery的架构，采用典型的生产者-消费者模式</p>
<p>主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p>
<p>我们只需要将请求所要处理的任务丢入任务队列broker中，由空闲的worker去处理任务即可，处理的结果会暂存在后台数据库backend中。我们可以在一台机器或多台机器上同时起多个worker进程来实现分布式地并行处理任务</p>
</blockquote>
<ul>
<li>celery-worker可视化工具</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flower</span><br></pre></td></tr></table></figure>

<ul>
<li>启动flower可以在本地的5555端口查看到当前celery的信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py celery flower</span><br></pre></td></tr></table></figure>

<ul>
<li>django加入设置中加入djcelery</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>settings.py</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'djcelery',</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>配置基本连接信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL= <span class="string">'amqp://guest:woaini21G@123.57.61.168:5672'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>celery与3.7版本兼容问题</li>
</ul>
<blockquote>
<p>在 <code>celery</code> 官方的提议下，建议将 <code>async</code> 文件的文件名改成 <code>asynchronous</code></p>
<p>C:\Python37\Lib\site-packages\kombu\async</p>
</blockquote>
<ul>
<li>需要将下面文件内async转换为asynchronous</li>
</ul>
<blockquote>
<p>C:\Python37\Lib\site-packages\celery\utils\timer2.py</p>
<p>C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\components.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\autoscale.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\consumer.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\strategy.py</p>
</blockquote>
<ul>
<li>编写任务代码，在每个app下的tasks.py文件中</li>
</ul>
<blockquote>
<p>其中，当djcelery.setup_loader()运行时</p>
<p>Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件</p>
<p>找到标记为task的方法，将它们注册为<code>celery task</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tasks.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> api_shop.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_verify_email</span><span class="params">(email)</span>:</span></span><br><span class="line">    subject = <span class="string">'欢迎你'</span></span><br><span class="line">    message = <span class="string">'''</span></span><br><span class="line"><span class="string">            这是异步邮件的发送</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_mail(subject, message, DEFAULT_FROM_EMAIL, [email])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在视图接口的地方使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> tasks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendVerifyEmail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        tasks.send_verify_email.delay(<span class="string">'295878828@qq.com'</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(</span><br><span class="line">            &#123;<span class="string">'code'</span>:<span class="number">200</span>&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<ul>
<li>开启celery</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py celery worker</span><br></pre></td></tr></table></figure>

<ul>
<li>如果出错大概率需要这样，在manage.py文件前头加入这个</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#manage.py</span></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'eduapi.settings'</span></span><br><span class="line">django.setup()</span><br></pre></td></tr></table></figure>

<ul>
<li>启动celery报错解决总结</li>
</ul>
<blockquote>
<p>报错总结链接 <a href="https://blog.csdn.net/sanyuedexuanlv/article/details/88052884" target="_blank" rel="noopener">https://blog.csdn.net/sanyuedexuanlv/article/details/88052884</a> </p>
</blockquote>
<p><img src="//dingyifan.tech/2018/12/01/Celery异步发送邮件/C:%5CUsers%5C60952%5CDesktop%5Cblog%5Cimgs%5CSnipaste_2019-09-28_08-13-22.png" alt="Snipaste_2019-09-28_08-13-22"></p>
<p>rabbit-mq密码输入错误，初始密码为guest</p>
<h3 id="二、Django后台"><a href="#二、Django后台" class="headerlink" title="二、Django后台"></a>二、Django后台</h3><h5 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h5><ul>
<li>tasks.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> eduapi.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_verify_email</span><span class="params">(recv_email,course_name)</span>:</span></span><br><span class="line">      subject = <span class="string">'恭喜你'</span></span><br><span class="line">      message = <span class="string">'关注了：%s'</span>%(course_name)</span><br><span class="line">      send_mail(subject,message,DEFAULT_FROM_EMAIL,[recv_email])</span><br></pre></td></tr></table></figure>

<ul>
<li>settings.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口 </span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'XXX@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'XXX'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL= <span class="string">'amqp://guest:XXX@XXX:5672'</span></span><br></pre></td></tr></table></figure>

<h5 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h5><ul>
<li>测试点击关注发送通知邮件邮件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> tasks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follow</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            user_id = request.data[<span class="string">'id'</span>]</span><br><span class="line">            course_id = request.data[<span class="string">'course_id'</span>]</span><br><span class="line">            user = models.User.objects.get(id=user_id)</span><br><span class="line">            course = models.Course.objects.get(id=course_id)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  follow_data = models.LikeCLass.objects.get(</span><br><span class="line">                        course__id = course_id,</span><br><span class="line">                        user__id = user_id</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  models.LikeCLass.objects.create(</span><br><span class="line">                        user = user,</span><br><span class="line">                        course = course</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  follow_data.is_active = <span class="literal">True</span></span><br><span class="line">            tasks.send_verify_email.delay(user.email,course.title)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                  <span class="string">'message'</span>:<span class="string">'关注成功'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、关注表"><a href="#3、关注表" class="headerlink" title="3、关注表"></a>3、关注表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeCLass</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      user = models.ForeignKey(User,models.CASCADE,related_name=<span class="string">'users'</span>)</span><br><span class="line">      course = models.ForeignKey(Course,models.CASCADE,related_name=<span class="string">'courses'</span>)</span><br><span class="line">      is_active = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">      <span class="comment"># 类属性联合约束条件————约定不会出现同样的数据</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            unique_together = (<span class="string">'user'</span>,<span class="string">'course'</span>)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.user.name + <span class="string">":"</span> + self.course.title</span><br></pre></td></tr></table></figure>

<h5 id="4、中间件"><a href="#4、中间件" class="headerlink" title="4、中间件"></a>4、中间件</h5><blockquote>
<p>用户id通过中间件解析token获得</p>
<p>对request里的POST进行复制，将用户id传递进去，再将封装好的data数据赋值给request.POST</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse,HttpResponse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> decrypt_oracle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要登录的页面列表，反向解析得到连接 </span></span><br><span class="line">LOGIN_REQUIRE_LIST = [reverse(var) <span class="keyword">for</span> var <span class="keyword">in</span> [<span class="string">'follow'</span>]]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRequired</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> request.path <span class="keyword">in</span> LOGIN_REQUIRE_LIST:</span><br><span class="line">                  token = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>)</span><br><span class="line">                  <span class="keyword">if</span> <span class="keyword">not</span> token <span class="keyword">or</span> token == <span class="string">'[object Object]'</span>:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                              <span class="string">'code'</span> : <span class="number">6207</span>,</span><br><span class="line">                              <span class="string">'message'</span> : <span class="string">'未认证'</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                        token_data = json.loads(decrypt_oracle(token))</span><br><span class="line">                        user_id = token_data.get(<span class="string">'id'</span>)</span><br><span class="line">                        <span class="keyword">if</span> token_data [<span class="string">'expire'</span>] &lt; time.time():</span><br><span class="line">                              <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                                    <span class="string">'code'</span>: <span class="number">70001</span>,</span><br><span class="line">                                    <span class="string">'message'</span> : <span class="string">'token过期'</span></span><br><span class="line">                              &#125;)</span><br><span class="line">                        data = request.POST.copy()</span><br><span class="line">                        data[<span class="string">'id'</span>] = user_id</span><br><span class="line">                        request.POST = data</span><br></pre></td></tr></table></figure>

<h3 id="三、Vue"><a href="#三、Vue" class="headerlink" title="三、Vue"></a>三、Vue</h3><h5 id="1、点击关注向后端传递课程id"><a href="#1、点击关注向后端传递课程id" class="headerlink" title="1、点击关注向后端传递课程id"></a>1、点击关注向后端传递课程id</h5><p>将课程id以post方式发送后端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">添加关注</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> tasks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follow</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            user_id = request.data[<span class="string">'id'</span>]</span><br><span class="line">            course_id = request.data[<span class="string">'course_id'</span>]</span><br><span class="line">            user = models.User.objects.get(id=user_id)</span><br><span class="line">            course = models.Course.objects.get(id=course_id)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  follow_data = models.LikeCLass.objects.get(</span><br><span class="line">                        course__id = course_id,</span><br><span class="line">                        user__id = user_id</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  models.LikeCLass.objects.create(</span><br><span class="line">                        user = user,</span><br><span class="line">                        course = course</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  follow_data.is_active = <span class="literal">True</span></span><br><span class="line">            tasks.send_verify_email.delay(user.email,course.title)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                  <span class="string">'message'</span>:<span class="string">'关注成功'</span></span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment">#取消关注</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnFollow</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            user_id = request.data[<span class="string">'id'</span>]</span><br><span class="line">            course_id = request.data[<span class="string">'course_id'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  follow_data = models.LikeCLass.objects.get(</span><br><span class="line">                        course__id = course_id,</span><br><span class="line">                        user__id = user_id</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  <span class="keyword">raise</span> Http404</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  follow_data.is_active = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'code'</span>:<span class="number">1</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p>##### </p>
]]></content>
      <categories>
        <category>Celery</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Celery</tag>
        <tag>发邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker+fastDFS</title>
    <url>/2018/11/10/Docker+fastDFS/</url>
    <content><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>什么是docker：小海腾<ul>
<li>KVM、Xen、VMware、VirtualBox、Hyper-V</li>
<li>VMM</li>
</ul>
</li>
<li>容器技术：在计算机的世界中, 容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化 (hypervisor virtualization，HV)有所不同，管理程序虚拟化通过中间层将一台或者多台独立 的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因 此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行 在同一台宿主机上。</li>
<li>docker-ee：收费的</li>
<li>docker-ce：免费的</li>
</ul>
<h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><ul>
<li><p>上手快：用户只需要几分钟，就可以把自己的程序“Docker 化”。Docker 依赖于“写时复制” (copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改” 的境界；随后，就可以创建容器来运行应用程序了。大多数 Docker 容器只需要不到 1 秒中即可 启动。由于去除了管理程序的开销，Docker 容器拥有很高的性能，同时同一台宿主机中也 可以运行更多的容器，使用户尽可能的充分利用系统资源</p>
</li>
<li><p>职责的逻辑分类：使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如 何管理容器。Docker 设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署 的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题(测试环境都是正 常的，上线后出了问题就归结为肯定是运维的问题)”</p>
</li>
</ul>
<ul>
<li>快速高效的开发生命周期：Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用 程序具备可移植性，易于构建，并易于协作。(通俗一点说，Docker 就像一个盒子，里面 可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件 件的取。)</li>
</ul>
<ul>
<li>鼓励使用面向服务的架构：Docker 还鼓励面向服务的体系结构和微服务架构。Docker 推荐单个容器只运行一个应 用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服 务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序 都变得非常简单，同时也提高了程序的内省性。(当然，可以在一个容器中运行多个应用程 序)</li>
</ul>
<h3 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h3><ul>
<li>Docker 是一个客户端-服务器(C/S)架构程序。Docker 客户端只需要向 Docker 服务器 或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了 一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护 进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器，镜像也是 Docker 生命周 期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构 建出来。例如:<ul>
<li>添加一个文件;</li>
<li>执行一个命令;</li>
<li>打开一个窗口。</li>
</ul>
</li>
<li>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新</li>
</ul>
<h3 id="Registry镜像注册"><a href="#Registry镜像注册" class="headerlink" title="Registry镜像注册"></a>Registry镜像注册</h3><ul>
<li>Docker 用 Registry 来保存用户构建的镜像。</li>
<li>Registry 分为公共和私有两种。Docker 公司 运营公共的 Registry 叫做 Docker Hub</li>
<li>用户可以在 Docker Hub 注册账号，分享并保存自己的 镜像(说明:在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）</li>
</ul>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><ul>
<li>Docker 可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容 器即可</li>
<li>容器是基于镜像启动起来的，容器中可以运行一个或多个进程</li>
<li>我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。容器基于 镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务</li>
<li>安装好的一个虚拟机</li>
</ul>
<h3 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>Docker 把应用程序及其依赖，打包在 image 文件里面</li>
<li>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例</li>
<li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在自己操作系统所使用的image 基础上，往里面加入 Apache 服务器，形成你的image</li>
<li>就是一个操作系统文件</li>
</ul>
<h3 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run [option] 镜像名</span><br><span class="line">-i 表示以“交互模式”运行容器</span><br><span class="line">-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</span><br><span class="line">–name 为创建的容器命名</span><br><span class="line">-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span><br><span class="line">-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</span><br><span class="line">-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</span><br><span class="line">-e 为容器设置环境变量</span><br><span class="line">–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span><br></pre></td></tr></table></figure>

<h4 id="停止或启动容器"><a href="#停止或启动容器" class="headerlink" title="停止或启动容器"></a>停止或启动容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container stop 容器名或ID</span><br></pre></td></tr></table></figure>

<h3 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h3><ul>
<li>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务</li>
<li>FastDFS架构包括 <strong>Tracker server</strong> 和 <strong>Storage server</strong>。客户端请求Trackerserver进行过文件上传、下载<ul>
<li>通过<code>Tracker server</code>调度最终由Storage server完成文件上传、下载</li>
</ul>
</li>
<li><strong>Tracker server</strong><ul>
<li>作用是负载均衡和调度,通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为<strong>追踪服务器</strong>或 <strong>调度服务器</strong></li>
</ul>
</li>
<li><strong>Storage server</strong><ul>
<li>作用是文件存储,客户端上传的文件最终存储在Storage存储器上,Storageserver没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong></li>
</ul>
</li>
</ul>
<h3 id="centos部署docker"><a href="#centos部署docker" class="headerlink" title="centos部署docker"></a>centos部署docker</h3><ul>
<li>安装docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span> 添加docker-repo源</span><br><span class="line">yum install docker-ce</span><br><span class="line"><span class="meta">#</span> 尝试安装docker-ce</span><br><span class="line">yum erase docker-common-2:1.13.1-96.gitb2f74b2.el7.centos.x86_64</span><br><span class="line"><span class="meta">#</span> 删除已安装的docker</span><br></pre></td></tr></table></figure>

<ul>
<li>开启docker服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker镜像<ul>
<li>REPOSITORY：镜像所在的仓库名称</li>
<li>TAG：镜像标签</li>
<li>IMAGEID：镜像ID</li>
<li>CREATED：镜像的创建日期(不是获取该镜像的日期)</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">docker  rm</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取镜像及删除镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker image pull delron/fastdfs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，docker image pull是抓取 image 文件的命令。delron/fastdfs是 image 文件在仓库里面的位置，其中delron是 image 文件所在的组，fastdfs是 image 文件的名字</p>
</blockquote>
<ul>
<li>开启fastdfs的tracker服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure>

<ul>
<li>开启fastdfs的storage服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name storage -e TRACKER_SERVER=116.62.213.171:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭/开启docker容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop/start container_id</span><br></pre></td></tr></table></figure>

<ul>
<li>启动docker容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container start storage/tracker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前运行的容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器id</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器ID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件夹递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf fdfs(文件夹)</span><br></pre></td></tr></table></figure>

<ul>
<li>无法启动storage问题</li>
</ul>
<p>删除/var/fdfs/storage/data目录下的fdfs_storage.pid文件然后重启storage</p>
<h2 id="Fastdfs使用"><a href="#Fastdfs使用" class="headerlink" title="Fastdfs使用"></a>Fastdfs使用</h2><h3 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h3><ul>
<li>下载安装<code>fastdfs</code>的<code>python</code>客户端</li>
</ul>
<blockquote>
<p><a href="https://github.com/JaceHo/fdfs_client-py" target="_blank" rel="noopener">https://github.com/JaceHo/fdfs_client-py</a></p>
</blockquote>
<ul>
<li>windows兼容问题</li>
</ul>
<blockquote>
<p>解压下载好的压缩包，提取fdfs_client文件夹</p>
</blockquote>
<ul>
<li>将该文件夹放入python的三方包目录下</li>
</ul>
<blockquote>
<p>C:\Python37\Lib\site-packages</p>
</blockquote>
<ul>
<li>安装所需的两个额外模块</li>
</ul>
<blockquote>
<p>pip install mutagen<br>pip isntall requests </p>
</blockquote>
<ul>
<li>注释fdfs_client/storage_client.py文件中的第十二行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#from fdfs_client.sendfile import *</span><br></pre></td></tr></table></figure>

<ul>
<li>创建client.conf文件到django下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project/client.conf</span></span><br><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=\static <span class="comment">#FastDFS客户端存放日志文件的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment">#  "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">123.57</span><span class="number">.61</span><span class="number">.168</span>:<span class="number">22122</span> <span class="comment">#运行tracker服务的机器IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerg for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use "#include" directive to include HTTP other settiongs</span></span><br><span class="line"><span class="comment">##include http.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传测试代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.upload_by_filename(文件名)</span></span><br><span class="line"><span class="comment">#client.upload_by_buffer(文件bytes数据)</span></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">"client.conf"</span>)</span><br><span class="line"></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'1.jpg'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中返回结果中的Remote file_id就是上传成功的保存文件名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	'Group name': 'group1', </span><br><span class="line">	'Remote file_id': 'group1\\M00/00/00/rBEUWlz_HzSAPPzBAAQ2UAPajsU035.jpg', </span><br><span class="line">	'Status': 'Upload successed.', </span><br><span class="line">	'Local file name': '1.jpg', </span><br><span class="line">	'Uploaded size': '269.00KB', </span><br><span class="line">	'Storage IP': '123.57.61.168\x008'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Django文件引擎"><a href="#Django文件引擎" class="headerlink" title="Django文件引擎"></a><code>Django</code>文件引擎</h3><ul>
<li>重构<code>django</code>文件上传引擎</li>
</ul>
<blockquote>
<p> 存储类中必须实现_open()和_save()方法,以及任何后续使用中可能用到的其他方法。</p>
</blockquote>
<ul>
<li><code>_open(name, mode = ‘rb’)</code>：被<code>Storage.open()</code>调用,在打开文件时被调用</li>
<li><code>save(name, content)</code>：被<code>Storage.save()</code>调用,name是传入的文件名,<code>content</code>是<code>Django</code>接收到的文件内容,该方法需要将<code>content</code>文件内容保存。<code>Django</code>会将该方法的返回值保存到数据库中对应的文件字段,也就是说该方法应该返回要保存在数据库中的文件名信息。</li>
<li><code>exists(name)</code>：如果名为<code>name</code>的文件在文件系统中存在，按返回<code>True</code>，否则返回<code>False</code></li>
<li><code>url(name)</code>：返回文件的完整访问<code>URL</code></li>
<li><code>delete(name)</code>：删除<code>name</code>文件</li>
<li><code>listdir(path)</code>：列出指定路径的文件</li>
<li><code>size(name)</code>：返回<code>name</code>文件的总大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastDFSStroage</span><span class="params">(Storage)</span>:</span></span><br><span class="line">    <span class="string">"""定义FastDFS客户端类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base_url = None, client_conf = None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化对象</span></span><br><span class="line"><span class="string">        :param base_url:</span></span><br><span class="line"><span class="string">        :param client_conf:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> base_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            base_url = settings.FDAS_URL</span><br><span class="line">            <span class="comment"># 'http://123.57.61.168:8888' </span></span><br><span class="line">        self.base_url = base_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> client_conf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">            <span class="comment"># FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'client.conf')</span></span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self, name, mode = <span class="string">'rb'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        打开文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param mode:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self, name, content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return:保存到数据库中的FastDFSDE文件名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">"Status"</span>) != <span class="string">"Upload successed."</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"upload file failed"</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">"Remote file_id"</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        检查文件是否重复, FastDFS自动区分重复文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取name文件的完整url</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br></pre></td></tr></table></figure>

<ul>
<li>将文件引擎设置到settings中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">'goods.views.FastDFSStorage'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传成功后的访问地址</li>
</ul>
<blockquote>
<p>在服务器IP地址的<code>8888</code>端口，记得打开对应阿里云的端口规则</p>
</blockquote>
<ul>
<li>注意：在新版本的Remote file_id，由<code>\\</code>斜杠变为了<code>/</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Django</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>登录</title>
    <url>/2017/12/20/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<img src="/2017/12/20/登录功能/登录功能.png" title="登录功能">

<h3 id="一、Vue部分"><a href="#一、Vue部分" class="headerlink" title="一、Vue部分"></a>一、Vue部分</h3><h5 id="1、Index-vue里完成登录功能"><a href="#1、Index-vue里完成登录功能" class="headerlink" title="1、Index.vue里完成登录功能"></a>1、Index.vue里完成登录功能</h5><ol>
<li><p>v-model绑定用户输入以及按钮&lt;进入实验楼&gt;</p>
</li>
<li><p>在methods里构建login方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">login()&#123;</span><br><span class="line">	<span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">	form_data.append(<span class="string">'email'</span>,<span class="keyword">this</span>.login_email)</span><br><span class="line">    form_data.append(<span class="string">'passwd'</span>,<span class="keyword">this</span>.login_pass)</span><br><span class="line">    axios(&#123;</span><br><span class="line">	url:<span class="string">'http://127.0.0.1:8000/api/user/login/'</span>,</span><br><span class="line">    method:<span class="string">'post'</span>,</span><br><span class="line">    data:form_data,</span><br><span class="line">		&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        	<span class="keyword">if</span> (res.data.code == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(res.data.token);</span><br><span class="line">                <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>,res.data.token)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="二、Django功能"><a href="#二、Django功能" class="headerlink" title="二、Django功能"></a>二、Django功能</h3><h5 id="1、配置路由"><a href="#1、配置路由" class="headerlink" title="1、配置路由"></a>1、配置路由</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">'user/login/'</span>,views.Login.as_view(),name=<span class="string">'login'</span>),</span><br></pre></td></tr></table></figure>

<h5 id="2、登录逻辑"><a href="#2、登录逻辑" class="headerlink" title="2、登录逻辑"></a>2、登录逻辑</h5><blockquote>
<p>在这里我们用JWT客户端自认证的方式判断用户登录状态，由后端生成token值，传递给前端存储在sessionStorage里。Django中JWT的生成方式有很多种，例如：python自带jwt模块，django自带jwt包，isdangerous模块生成等等，为了加深对jwt理解，在这里我们用AES加密的ECB来实现“自定义”jwt。</p>
</blockquote>
<ol>
<li><p>构造函数分别基于16位和32位补全要加密的文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于16位加密</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_16</span><span class="params">(value)</span>:</span></span><br><span class="line">      <span class="keyword">while</span> len(value) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            value += <span class="string">'\0'</span></span><br><span class="line">      <span class="keyword">return</span> str.encode(value)</span><br><span class="line"><span class="comment">#基于32位加密</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_32</span><span class="params">(value)</span>:</span></span><br><span class="line">      <span class="keyword">while</span> len(value) % <span class="number">32</span> != <span class="number">0</span>:</span><br><span class="line">            value += <span class="string">'\0'</span></span><br><span class="line">      <span class="keyword">return</span> str.encode(value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义密钥和过期时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AES_KEY = <span class="string">'JIMMYD'</span></span><br><span class="line">EXPIRE = <span class="number">1800</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义加密解密方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_oracle</span><span class="params">(text)</span>:</span></span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">      text: 待加密文本</span></span><br><span class="line"><span class="string">      '''</span></span><br><span class="line">      aes = AES.new(be_32(AES_KEY),AES.MODE_ECB) <span class="comment"># 初始化加密器</span></span><br><span class="line">      encrpyt_aes = aes.encrypt(be_16(text))  <span class="comment"># aex ECB加密 必须内容是进制流</span></span><br><span class="line">      encrpyted_text = str(base64.encodebytes(encrpyt_aes),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">      <span class="keyword">return</span> encrpyted_text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_oracle</span><span class="params">(text)</span>:</span></span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">      text: 密文</span></span><br><span class="line"><span class="string">      '''</span></span><br><span class="line">      aes = AES.new(be_32(AES_KEY),AES.MODE_ECB)</span><br><span class="line">      base64_decrypted = base64.decodebytes(text.encode(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">      decrypted_text = str(aes.decrypt(base64_decrypted),encoding=<span class="string">'utf-8'</span>).replace(<span class="string">'\0'</span>,<span class="string">''</span>)</span><br><span class="line">      <span class="keyword">return</span> decrypted_text</span><br></pre></td></tr></table></figure>
</li>
<li><p>login类视图完成登录功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            email = request.data[<span class="string">'email'</span>]</span><br><span class="line">            passwd = request.data[<span class="string">'passwd'</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  user = models.User.objects.get(</span><br><span class="line">                        email = email</span><br><span class="line">                  )</span><br><span class="line">                  <span class="keyword">if</span> check_password(user.password,passwd):</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  data = &#123;</span><br><span class="line">                        <span class="string">'id'</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">'expire'</span> : time.time() + EXPIRE</span><br><span class="line">                  &#125;</span><br><span class="line">                  token = encrypt_oracle(json.dumps(data))</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span> : <span class="number">1</span> ,</span><br><span class="line">                        <span class="string">'message'</span> : <span class="string">'登录成功'</span>,</span><br><span class="line">                        <span class="string">'token'</span>:token,</span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                  <span class="string">'message'</span>:<span class="string">'登录失败'</span>,</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p>在这里我们假设登录的用户记录‘id’为1，’expire’为过期时间，生成token值以后我们传递给前端</p>
</li>
</ol>
<h5 id="3、自定义中间件拦截token未认证或token已过期的用户"><a href="#3、自定义中间件拦截token未认证或token已过期的用户" class="headerlink" title="3、自定义中间件拦截token未认证或token已过期的用户"></a>3、自定义中间件拦截token未认证或token已过期的用户</h5><blockquote>
<p>为提高我们代码的复用率，可以使用django中间件来实现用户拦截的功能。我们自定义中间件LoginRequired，重写process_request方法，在该方法中完成token值获取以及验证，将验证结果返回给前端。</p>
</blockquote>
<ul>
<li>在子应用（userapp）下新建文件middleware.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> decrypt_oracle   <span class="comment">#导入view.py里我们自定义的解码函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要登录的页面列表，反向解析得到连接 </span></span><br><span class="line">LOGIN_REQUIRE_LIST = [reverse(var) <span class="keyword">for</span> var <span class="keyword">in</span> [<span class="string">'course'</span>,]]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRequired</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    如果token不存在或者已过期返回对应code码</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> request.path <span class="keyword">in</span> LOGIN_REQUIRE_LIST:</span><br><span class="line">                  token = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>)</span><br><span class="line">                    <span class="comment"># js空值用null表示，python会识别为字符串</span></span><br><span class="line">                  <span class="keyword">if</span> <span class="keyword">not</span> token <span class="keyword">or</span> token == <span class="string">'null'</span>:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                              <span class="string">'code'</span> : <span class="number">6207</span>,</span><br><span class="line">                              <span class="string">'message'</span> : <span class="string">'未认证'</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                        token_data = decrypt_oracle(token)</span><br><span class="line">                        <span class="comment"># eval()函数会将字符串转换为可用python数据类型，相对于的函数repr()</span></span><br><span class="line">                        <span class="keyword">if</span> eval(token_data)[<span class="string">'expire'</span>] &lt; time.time():</span><br><span class="line">                              <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                                    <span class="string">'code'</span>: <span class="number">70001</span>,</span><br><span class="line">                                    <span class="string">'message'</span> : <span class="string">'token过期'</span></span><br><span class="line">                              &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在settings里将我们的中间件添加到设置里</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'userapp.middleware.LoginRequired'</span>,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>注册</title>
    <url>/2017/12/15/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<img src="/2017/12/15/注册功能/注册功能.png" title="register">

<h3 id="一、Vue部分"><a href="#一、Vue部分" class="headerlink" title="一、Vue部分"></a>一、Vue部分</h3><h5 id="1、模板转换"><a href="#1、模板转换" class="headerlink" title="1、模板转换"></a>1、模板转换</h5><p>我们在components里将HelloWorld.vue修改为Index.vue，并将模板文件里的代码拷贝进template下div标签里</p>
<h5 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h5><ol>
<li><p>跨域：本次项目是前后端分离的，因此涉及到跨域问题，在这里我们使用axios来实现跨域功能。cmd进入vue文件下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure>

<p>在编辑器中打开vue文件，打开config文件夹下的index.js，修改proxyTable配置为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;  <span class="comment">//使用"/api"来代替"http://f.apiplus.c"</span></span><br><span class="line">      target: <span class="string">'http://127.0.0.1:8000/'</span>, <span class="comment">//源地址</span></span><br><span class="line">      changeOrigin: <span class="literal">true</span>, <span class="comment">//改变源 </span></span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/api'</span>: <span class="string">''</span> <span class="comment">//路径重写</span></span><br><span class="line">        			&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">  			&#125;,</span><br></pre></td></tr></table></figure>

<p>打开src文件夹下的main.js，添加代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">Vue.prototype.axios = axios</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>路由：打开router下的index.js修改代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'@/components/Index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode:<span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      component: Index</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>修改mode为’history’，为我们的主页index配置路由’/‘</p>
</li>
</ol>
<h5 id="3、Index-vue完成注册功能"><a href="#3、Index-vue完成注册功能" class="headerlink" title="3、Index.vue完成注册功能"></a>3、Index.vue完成注册功能</h5><ol>
<li><p>启动vue项目，用Chrome浏览器打开index主页，找到注册弹窗所在标签，用v-model绑定用户输入信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">v-model</span>=<span class="string">"register_email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"请输入邮箱"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">v-model</span>=<span class="string">"register_password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>验证码功能绑定点击事件，发送邮件按钮，验证码输入框实现鼠标移除对验证码做判断功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 验证码验证用鼠标光标移除实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">blur</span>=<span class="string">"verify_email_token"</span> <span class="attr">v-model</span>=<span class="string">"register_verify"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"请输入验证码"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"is_register"</span> <span class="attr">class</span>=<span class="string">'help-block text-left'</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"is_unregister"</span> <span class="attr">class</span>=<span class="string">'help-block text-left'</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-info"</span> @<span class="attr">click</span>=<span class="string">'send_verify_email'</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送邮件"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>导入axios完成跨域，在data()里构建初始数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        register_email:<span class="string">''</span>,</span><br><span class="line">        register_password:<span class="string">''</span>,</span><br><span class="line">        register_verify:<span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">        message :<span class="string">''</span>,</span><br><span class="line">        is_register : <span class="literal">false</span>, <span class="comment">//做全局验证验证码判断使用</span></span><br><span class="line">        is_unregister : <span class="literal">true</span> ,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>注意：data()必须是函数具有返回值是因为javascipt只有函数构成作用域(注意理解作用域,只有<code>函数的{}</code>构成作用域,<code>对象的{}</code>以及 <code>if(){}</code>都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响</p>
</li>
</ol>
<ol start="4">
<li><p>修改form表单提交事件，绑定函数register</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">"register"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>methods内写register函数，将要向后端传递的参数放在Formdata()里，因为django只识别Formdata里的数据，构建跨域axios函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">register()&#123;</span><br><span class="line">            <span class="comment">// 如果验证校验失败 </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.is_register) &#123;</span><br><span class="line">                <span class="keyword">this</span>.message = <span class="string">'验证码未通过'</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//   创建一个form_data列表存储要传递到后端数据，django只支持form_data表单数据类型</span></span><br><span class="line">            <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">        <span class="comment">//   form_data.append('register_verify')</span></span><br><span class="line">            form_data.append(<span class="string">'register_email'</span>,<span class="keyword">this</span>.register_email)</span><br><span class="line">            form_data.append(<span class="string">'register_password'</span>,<span class="keyword">this</span>.register_password)</span><br><span class="line">            axios(&#123;</span><br><span class="line">                url:<span class="string">'http://127.0.0.1:8000/api/user/register/'</span>,</span><br><span class="line">                methods:<span class="string">'post'</span>,</span><br><span class="line">                data:form_data</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.data.code == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.message = res.data.message</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(res.data)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>发送邮件函数send_verify_email</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">send_verify_email()&#123;</span><br><span class="line">        <span class="comment">//   alert(this.register_email)</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.register_email)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">              form_data.append(<span class="string">'register_email'</span>,<span class="keyword">this</span>.register_email)</span><br><span class="line">              axios(&#123;</span><br><span class="line">                  url:<span class="string">'http://127.0.0.1:8000/api/user/verifyemail/'</span>,</span><br><span class="line">                  method:<span class="string">'post'</span>,</span><br><span class="line">                  data:form_data,</span><br><span class="line">              &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(res.data)</span><br><span class="line">              &#125;).catch(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>验证邮件验证码函数verify_email_token</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">verify_email_token()&#123;</span><br><span class="line">            <span class="comment">// 校验表单中的验证码是否正确</span></span><br><span class="line">            <span class="keyword">let</span> form_data = <span class="keyword">new</span> FormData()</span><br><span class="line">            form_data.append(<span class="string">'register_email'</span>,<span class="keyword">this</span>.register_email)</span><br><span class="line">            form_data.append(<span class="string">'register_verify'</span>,<span class="keyword">this</span>.register_verify)</span><br><span class="line">            axios(&#123;</span><br><span class="line">                url:<span class="string">'http://127.0.0.1:8000/api/user/verifytoken/'</span>,</span><br><span class="line">                method:<span class="string">'post'</span>,</span><br><span class="line">                data:form_data,</span><br><span class="line"></span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.data.code == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.message = res.data.message</span><br><span class="line">                    <span class="keyword">this</span>.is_register = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">this</span>.is_unregister = <span class="literal">false</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.message = res.data.message</span><br><span class="line">                    <span class="keyword">this</span>.is_register = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">this</span>.is_unregister = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h3 id="二、Django部分"><a href="#二、Django部分" class="headerlink" title="二、Django部分"></a>二、Django部分</h3><h5 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h5><ol>
<li><p>在settings文件中注册子项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'userapp'</span>,</span><br></pre></td></tr></table></figure>

<p>​    </p>
</li>
<li><p>在settings里添加发送邮件配置代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口 </span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'374345224@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'teyiisvqknicbidc'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>设置跨域头部CORS中间件，添加到common中间件上方</p>
<ul>
<li>注册corsheaders</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'corsheaders'</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>将CORS中间件添加到common中间件上方</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'corsheaders.middleware.CorsMiddleware'</span>,  <span class="comment">#跨域中间件 cors</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span> <span class="comment"># 其他人都可以跨域访问</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li></li>
</ol>
<h5 id="2、ORM存储数据models"><a href="#2、ORM存储数据models" class="headerlink" title="2、ORM存储数据models"></a>2、ORM存储数据models</h5><p>​        在子应用userapp的models.py文件中创建User类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      email = models.EmailField(verbose_name=<span class="string">'邮箱'</span>)</span><br><span class="line">      password = models.CharField(max_length=<span class="number">30</span>,verbose_name=<span class="string">'密码'</span>)</span><br><span class="line">	  <span class="comment"># 用于超级管理员后台admin显示数据名称</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.email</span><br></pre></td></tr></table></figure>

<h5 id="3、配置路由"><a href="#3、配置路由" class="headerlink" title="3、配置路由"></a>3、配置路由</h5><ul>
<li>主路由urls.py中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'api/'</span>,include(<span class="string">'userapp.urls'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>子路由userapp/urls.py中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">      path(<span class="string">'user/verifyemail/'</span>,views.EmailVerify.as_view(),name=<span class="string">'verifyemail'</span>),</span><br><span class="line">      path(<span class="string">'user/verifytoken/'</span>,views.TokenVerify.as_view(),name=<span class="string">'verifytoken'</span>),</span><br><span class="line">      path(<span class="string">'user/register/'</span>,views.Register.as_view(),name=<span class="string">'register'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="4、子应用userapp，view-py编写业务逻辑代码"><a href="#4、子应用userapp，view-py编写业务逻辑代码" class="headerlink" title="4、子应用userapp，view.py编写业务逻辑代码"></a>4、子应用userapp，view.py编写业务逻辑代码</h5><ul>
<li><p>memcache里存储验证码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="comment">#构建memcache连接，Client里放入主机地址</span></span><br><span class="line">mem = memcache.Client([<span class="string">'116.62.188.230'</span>],debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建生成随机6位验证码函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">      <span class="comment"># 字母a-z A-Z 0-9</span></span><br><span class="line">      a_ = list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">      A_ = list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">      num_ = list(str(range(<span class="number">0</span>,<span class="number">9</span>)))</span><br><span class="line">      <span class="comment"># 从我们构建的列表中取出6位字符</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>发送邮件EmailVerify</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> eduapi.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailVerify</span><span class="params">(View)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      1、先检查，对应邮件是否在mamcache里已经存在了验证码</span></span><br><span class="line"><span class="string">      2、发现没有存在，那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">      3、存储到mamcache里，并设置60s过期时间</span></span><br><span class="line"><span class="string">            email 6str 60s</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            register_email = request.POST.get(<span class="string">'register_email'</span>)</span><br><span class="line">            <span class="comment"># 从memcache里取出我们需要的值</span></span><br><span class="line">            token = mem.get(register_email)</span><br><span class="line">            <span class="comment"># 如果存在验证码则不需要发送邮件</span></span><br><span class="line">            <span class="keyword">if</span> token:</span><br><span class="line">                  <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                        <span class="string">'code'</span>: <span class="number">0</span> ,</span><br><span class="line">                        <span class="string">'message'</span> :<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  <span class="comment"># 生成token存储到memcache里，发送邮件验证码</span></span><br><span class="line">                  token = get_random_str()   <span class="comment">#生成的验证码</span></span><br><span class="line">             </span><br><span class="line">                  mem.set(register_email,token,<span class="number">60</span>)  <span class="comment"># 存入memcache里</span></span><br><span class="line"></span><br><span class="line">                  subject = <span class="string">'欢迎来到实验楼'</span></span><br><span class="line">                  message = <span class="string">'你的验证码是：%s'</span>%token</span><br><span class="line"></span><br><span class="line">                  send_mail(subject,message,DEFAULT_FROM_EMAIL,[register_email])</span><br><span class="line">                  <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li><p>验证码验证TokenVerify</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenVerify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            register_email = request.data[<span class="string">'register_email'</span>]</span><br><span class="line">            register_verify = request.data[<span class="string">'register_verify'</span>]</span><br><span class="line"></span><br><span class="line">            token = mem.get(register_email)</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">and</span> token == register_verify:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'校验成功'</span></span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                        <span class="string">'message'</span>:<span class="string">'校验失败'</span></span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>

<p>注意：我们在这里使用DRF（django-rest-framework），需要在settings里注册rest_framework</p>
</li>
</ul>
<ul>
<li><p>注册Register</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            register_email = request.data[<span class="string">'register_email'</span>]</span><br><span class="line">            register_password = request.data[<span class="string">'register_password'</span>]</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                  models.User.objects.get(</span><br><span class="line">                        email = register_email</span><br><span class="line">                  )</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                  models.User.objects.create(</span><br><span class="line">                        email = register_email,</span><br><span class="line">                        password = make_password(register_password)</span><br><span class="line">                  )</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                        <span class="string">'messsage'</span>:<span class="string">'注册成功'</span>,</span><br><span class="line">                  &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                        <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                        <span class="string">'messsage'</span>:<span class="string">'邮箱已被占用'</span>,</span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>

<p>注意：我们使用了django自带的加密方式make_password，当然我们也可以使用sha1、sha256</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment"># 密码加密</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password</span><span class="params">(str_)</span>:</span></span><br><span class="line">      s = hashlib.sha1()</span><br><span class="line">      s.update(str_.encode())</span><br><span class="line">      <span class="keyword">return</span> s.hexdigest()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+xterm.js 实现Linux command界面</title>
    <url>/2017/11/19/vue+xterm.js%20%E5%AE%9E%E7%8E%B0Linux%20command%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h5 id="交互逻辑"><a href="#交互逻辑" class="headerlink" title="交互逻辑"></a>交互逻辑</h5><img src="/2017/11/19/vue+xterm.js%20实现Linux%20command界面/page1.png" title="交互逻辑">

<h5 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h5><blockquote>
<p>下载paramiko、dwebsocket</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install paramiko</span><br><span class="line">pip install dwebsocket</span><br></pre></td></tr></table></figure>

<ul>
<li>在INSTALLED_APPS注册dwebsocket</li>
</ul>
<blockquote>
<p>​    ‘dwebsocket’,</p>
</blockquote>
<ul>
<li>views.py里</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用paramiko建立于ssh的连接，完成数据交互</span></span><br><span class="line"><span class="string">建立2个线程，分别用于接收用户输入和返回ssh服务器信息到客户端</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> dwebsocket <span class="keyword">import</span> accept_websocket</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ssh_channle</span><span class="params">(host=<span class="string">'xxx'</span>,username=<span class="string">'root'</span>, password=<span class="string">'xxx'</span>)</span>:</span></span><br><span class="line">    sh = paramiko.SSHClient() <span class="comment"># 初始化一个带连接对象</span></span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy) <span class="comment"># 自动添加密钥规则</span></span><br><span class="line">    sh.connect(host,username=username,password=password) <span class="comment"># 连接</span></span><br><span class="line">    channle = sh.invoke_shell(term=<span class="string">'xterm'</span>)</span><br><span class="line">    <span class="keyword">return</span> channle <span class="comment"># 接收命令 和发送命令 是xterm样式的</span></span><br><span class="line"></span><br><span class="line">FLAG = [<span class="literal">True</span>,]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd_response</span><span class="params">(ws, channle)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> FLAG[<span class="number">0</span>]:</span><br><span class="line">            result = channle.recv(<span class="number">1024</span>) <span class="comment"># 接收linux返回</span></span><br><span class="line">            ws.send(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># 终止了线程任务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@accept_websocket # 只能被ws请求所访问</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webssh</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket:</span><br><span class="line">        channle = get_ssh_channle()</span><br><span class="line">        <span class="comment"># channle.recv()</span></span><br><span class="line">        <span class="comment"># channle.send()</span></span><br><span class="line">        ws = request.websocket</span><br><span class="line">        t = threading.Thread(target=cmd_response, args=(ws, channle))</span><br><span class="line">        t.start()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cmd = ws.wait() <span class="comment"># 接收WS里发来的shell命令</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cmd:</span><br><span class="line">                <span class="comment"># 连接断开</span></span><br><span class="line">                FLAG[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            channle.send(cmd) <span class="comment"># linux发过去</span></span><br><span class="line">        t.join()</span><br><span class="line">        ws.close()</span><br><span class="line">        channle.close()</span><br></pre></td></tr></table></figure>

<h5 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#125;,</span><br><span class="line">"dependencies": &#123;</span><br><span class="line">  "axios": "^0.19.0",</span><br><span class="line">  "vue": "^2.5.2",</span><br><span class="line">  "vue-router": "^3.0.1",</span><br><span class="line">  "xterm":"^3.1.0"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>下载xterm</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install xterm --save</span><br></pre></td></tr></table></figure>

<ul>
<li>src下的main.js里导入xtrem的css样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'xterm/dist/xterm.css'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建Console.vue模板</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;div id=&apos;terminal&apos;&gt;</span><br><span class="line">            </span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Terminal &#125; from &apos;xterm&apos;</span><br><span class="line">import * as fit from &apos;xterm/lib/addons/fit/fit&apos;</span><br><span class="line">import * as attach from &apos;xterm/lib/addons/attach/attach&apos;</span><br><span class="line">Terminal.applyAddon(attach)</span><br><span class="line">Terminal.applyAddon(fit)</span><br><span class="line">export default &#123;</span><br><span class="line">      mounted()&#123;</span><br><span class="line">            let terminalContainer = document.getElementById(&apos;terminal&apos;);</span><br><span class="line">            this.term = new Terminal(this.terminal);</span><br><span class="line">            this.term.open(terminalContainer);</span><br><span class="line">            // 绑定后端流接口</span><br><span class="line">            this.ws = new WebSocket(&apos;ws://127.0.0.1:8000/api/user/webssh/&apos;)</span><br><span class="line">            // 用attach将websocket绑定到黑窗口上</span><br><span class="line">            this.term.attach(this.ws)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置路由后就可以在页面上看到了</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>xterm</tag>
        <tag>Vue</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Course课程详情页</title>
    <url>/2017/11/01/Course%E8%AF%BE%E7%A8%8B%E8%AF%A6%E6%83%85%E9%A1%B5/</url>
    <content><![CDATA[<h3 id="一、数据库建表"><a href="#一、数据库建表" class="headerlink" title="一、数据库建表"></a>一、数据库建表</h3><h5 id="1、models中ORM，包含一对一、一对多、多对多关系"><a href="#1、models中ORM，包含一对一、一对多、多对多关系" class="headerlink" title="1、models中ORM，包含一对一、一对多、多对多关系"></a>1、models中ORM，包含一对一、一对多、多对多关系</h5><ul>
<li>讲师表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 讲师表，讲师个人信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teachers</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      user = models.OneToOneField(User,on_delete=models.CASCADE,verbose_name=<span class="string">'所属用户'</span>)</span><br><span class="line">      introduction = models.CharField(max_length=<span class="number">180</span>,verbose_name=<span class="string">'个人介绍'</span>)</span><br><span class="line">      is_active = models.BooleanField(default=<span class="literal">True</span>,verbose_name=<span class="string">'所属状态'</span>)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.user.name</span><br></pre></td></tr></table></figure>

<ul>
<li>课程表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 课程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      teacher = models.ForeignKey(Teachers,on_delete=models.CASCADE,verbose_name=<span class="string">'所属讲师'</span>)</span><br><span class="line">      description = models.CharField(max_length=<span class="number">255</span>,verbose_name=<span class="string">'课程描述'</span>)</span><br><span class="line">      title = models.CharField(max_length=<span class="number">30</span>,verbose_name=<span class="string">'课程名称'</span>)</span><br><span class="line">      img = models.ImageField(upload_to=<span class="string">'course_img/'</span>)</span><br><span class="line"></span><br><span class="line">      pay_choices = &#123;</span><br><span class="line">            (<span class="number">1</span>,<span class="string">'免费'</span>),</span><br><span class="line">            (<span class="number">2</span>,<span class="string">'付费'</span>),   <span class="comment"># 付费课程价格为0时为限免</span></span><br><span class="line">            (<span class="number">3</span>,<span class="string">'会员'</span>),</span><br><span class="line">      &#125;</span><br><span class="line">      coursetype = models.ForeignKey(Classtype,models.SET_NULL,null=<span class="literal">True</span>,blank=<span class="literal">True</span>,verbose_name=<span class="string">'课程分类'</span>)</span><br><span class="line">      pay_attr = models.IntegerField(choices=pay_choices,verbose_name=<span class="string">'类别'</span>)</span><br><span class="line">      price = models.DecimalField(decimal_places=<span class="number">2</span>,max_digits=<span class="number">10</span>,default=<span class="number">0</span>,verbose_name=<span class="string">'价格'</span>)</span><br><span class="line">      count = models.IntegerField(default=<span class="number">0</span>,verbose_name=<span class="string">'关注数'</span>)</span><br><span class="line">      learned = models.IntegerField(default=<span class="number">0</span>,verbose_name=<span class="string">'学过数量'</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.title</span><br></pre></td></tr></table></figure>

<ul>
<li>课程分类表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 课程分类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classtype</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      name = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'课程所属类别'</span>)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<ul>
<li>课程小节表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小节表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoureClass</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">      title = models.CharField(max_length=<span class="number">30</span>,verbose_name=<span class="string">'小节名'</span>)</span><br><span class="line">      type_choices = (</span><br><span class="line">            (<span class="number">1</span>,<span class="string">'直播'</span>),</span><br><span class="line">            (<span class="number">2</span>,<span class="string">'录播'</span>),</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      types = models.IntegerField(choices=type_choices,verbose_name=<span class="string">'课程类型'</span>)</span><br><span class="line"></span><br><span class="line">      url = models.URLField(verbose_name=<span class="string">'资源地址'</span>)</span><br><span class="line">      course = models.ForeignKey(Course,on_delete=models.CASCADE,verbose_name=<span class="string">'所属课程'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.course.title + <span class="string">':'</span>  + str(self.id) + <span class="string">':'</span>+self.title</span><br></pre></td></tr></table></figure>

<ul>
<li>收藏表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeCLass</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      user = models.ForeignKey(User,models.CASCADE)</span><br><span class="line">      course = models.ForeignKey(Course,models.CASCADE)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.user.name + <span class="string">":"</span> + self.course.title</span><br></pre></td></tr></table></figure>

<h2 id="二、序列化"><a href="#二、序列化" class="headerlink" title="二、序列化"></a>二、序列化</h2><h5 id="1、使用DRF自带的序列化工具"><a href="#1、使用DRF自带的序列化工具" class="headerlink" title="1、使用DRF自带的序列化工具"></a>1、使用DRF自带的序列化工具</h5><blockquote>
<p>首先在settings里注册rest_framework</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'rest_framework'</span>,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子应用根目录下创建py文件</p>
</blockquote>
<p>serializer.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            model = models.User</span><br><span class="line">            fields = <span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeachersSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">      <span class="comment"># teachercourse = UserSerializer(many=True)</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            model = models.Teachers</span><br><span class="line">            fields = <span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClasstypeSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            model = models.Classtype</span><br><span class="line">            fields = <span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">      <span class="comment"># courses = TeachersSerializer(many=True)</span></span><br><span class="line">      <span class="comment"># coursetypes = ClasstypeSerializer(many=True)</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            model = models.Course</span><br><span class="line">            fields = <span class="string">'__all__'</span></span><br><span class="line">            depth = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>注意当表中有外键而我们需要对外键做序列化时候，可以使用depth来申明外键关联的层级数，使用时可以直接用“键值.外键关联字段”的方式。例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue页面</span></span><br><span class="line">&#123;&#123;cdata.teacher.user.name&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、Vue"><a href="#三、Vue" class="headerlink" title="三、Vue"></a>三、Vue</h3><h5 id="1、单页面开发——父子组件嵌套"><a href="#1、单页面开发——父子组件嵌套" class="headerlink" title="1、单页面开发——父子组件嵌套"></a>1、单页面开发——父子组件嵌套</h5><ul>
<li>父子组件传参示例</li>
</ul>
<blockquote>
<p>父组件向子组件传参时，子组件用props接收</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;  </span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;  </span><br><span class="line">      &#125;,</span><br><span class="line">      watch:&#123;</span><br><span class="line">      &#125;,</span><br><span class="line">      props:&#123;</span><br><span class="line">            choices:&#123;</span><br><span class="line"><span class="javascript">                  type:<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">                  required:<span class="literal">true</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>父组件传递参数数据初始化，data内设置数据对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">choices:&#123;</span><br><span class="line">    pay_choice:<span class="string">''</span>,</span><br><span class="line">    language_choice:<span class="string">''</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、course父组件"><a href="#2、course父组件" class="headerlink" title="2、course父组件"></a>2、course父组件</h5><ul>
<li>标签多选功能</li>
</ul>
<img src="/2017/11/01/Course课程详情页/效果.png" title="效果">

<blockquote>
<p>绑定鼠标点击事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get_pay_choice(id_)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">this</span>.choices.pay_choice == id_)&#123;</span><br><span class="line">                <span class="keyword">this</span>.choices.pay_choice = <span class="string">''</span></span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.choices.pay_choice = id_</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">get_language_choice(id_)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.choices.language_choice == id_)&#123;</span><br><span class="line">                <span class="keyword">this</span>.choices.language_choice = <span class="string">''</span></span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.choices.language_choice = id_</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现标签点击效果</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-for</span>=<span class="string">'pay in pay_type'</span> <span class="attr">:class</span>=<span class="string">"&#123;'active':pay.id==choices.pay_choice&#125;"</span> @<span class="attr">click.prevent</span>=<span class="string">"get_pay_choice(pay.id)"</span>&gt;</span>&#123;&#123;pay.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">v-for</span>=<span class="string">'course in course_type'</span> <span class="attr">:class</span>=<span class="string">"&#123;'active':course.id==choices.language_choice&#125;"</span> @<span class="attr">click</span>=<span class="string">"get_language_choice(course.id)"</span>  &gt;</span>&#123;&#123;course.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>子组件watch监听属性检测数据（choices.pay_choice、choices.language_choice）变化，向后端发起请求获取对应数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">            choices:&#123;</span><br><span class="line">                  handler(oldval,newval)&#123;</span><br><span class="line">                        // console.log(this.choices.pay_choice)</span><br><span class="line">                        // console.log(this.choices.language_choice)</span><br><span class="line">                        let form_data = new FormData()</span><br><span class="line">                        form_data.append(&apos;pay_id&apos;,this.choices.pay_choice)</span><br><span class="line">                        form_data.append(&apos;language_id&apos;,this.choices.language_choice)</span><br><span class="line">                        axios(&#123;</span><br><span class="line">                              url:&apos;http://127.0.0.1:8000/api/user/getcourse/&apos;,</span><br><span class="line">                              method:&apos;post&apos;,</span><br><span class="line">                              data:form_data</span><br><span class="line">                        &#125;).then(res=&gt;&#123;</span><br><span class="line">                              this.course_data = res.data.course_data</span><br><span class="line">                        &#125;)</span><br><span class="line">                  &#125;,</span><br><span class="line">                  deep:true, </span><br><span class="line">            &#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>deep:true代表检测深层数据内部变化，例如：列表等</p>
<h3 id="四、Django"><a href="#四、Django" class="headerlink" title="四、Django"></a>四、Django</h3><h5 id="1、课程页展示数据"><a href="#1、课程页展示数据" class="headerlink" title="1、课程页展示数据"></a>1、课程页展示数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> serializer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            <span class="comment"># 获取request里头部数据</span></span><br><span class="line">            <span class="comment"># token = request.META.get('HTTP_AUTHORIZATION')</span></span><br><span class="line">            name = models.Classtype.objects.all()</span><br><span class="line">            name_data = serializer.ClasstypeSerializer(name,many=<span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">            courses = models.Course.objects.all()</span><br><span class="line">            course_data = serializer.CourseSerializer(courses,many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'course_data'</span>:course_data.data,</span><br><span class="line">                  <span class="string">'course_type'</span>:name_data.data,</span><br><span class="line">                  <span class="string">'pay_type'</span>: [</span><br><span class="line">                        &#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'免费'</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">'id'</span>:<span class="number">2</span>,<span class="string">'name'</span>:<span class="string">'限免'</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">'id'</span>:<span class="number">3</span>,<span class="string">'name'</span>:<span class="string">'会员'</span>&#125;,</span><br><span class="line">                        ]</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coursedetail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            cid = request.query_params.get(<span class="string">'cid'</span>)</span><br><span class="line">            <span class="comment"># print(cid)</span></span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">'ok'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Getcourse</span><span class="params">(APIView)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            pay_id = request.data.get(<span class="string">'pay_id'</span>,<span class="string">''</span>)</span><br><span class="line">            language_id = request.data.get(<span class="string">'language_id'</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pay_id <span class="keyword">and</span> <span class="keyword">not</span> language_id:</span><br><span class="line">                  courses = models.Course.objects.all()</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> language_id <span class="keyword">and</span> pay_id:</span><br><span class="line">                  courses = models.Course.objects.filter(pay_attr=pay_id)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> pay_id <span class="keyword">and</span> language_id:</span><br><span class="line">                  courses = models.Course.objects.filter(coursetype__id = language_id)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                  courses = models.Course.objects.filter(pay_attr=pay_id,coursetype__id = language_id)</span><br><span class="line">            course_data = serializer.CourseSerializer(courses,many=<span class="literal">True</span>)      </span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                  <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                  <span class="string">'course_data'</span>:course_data.data</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>前期准备</title>
    <url>/2017/09/19/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h3 id="一、创建Vue文件"><a href="#一、创建Vue文件" class="headerlink" title="一、创建Vue文件"></a>一、创建Vue文件</h3><h5 id="1、node-js"><a href="#1、node-js" class="headerlink" title="1、node.js"></a>1、node.js</h5><p>前往node.js官网下载windows版本</p>
<p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<h5 id="2、下载vue"><a href="#2、下载vue" class="headerlink" title="2、下载vue"></a>2、下载vue</h5><p>在cmd命令窗口内输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p>下载完成后可以在cmd查看vue版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure>

<h5 id="3、创建项目"><a href="#3、创建项目" class="headerlink" title="3、创建项目"></a>3、创建项目</h5><p>新建一个存储此次项目的文件夹，用cmd进入该文件夹目录下输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack xxx(项目名称：edu)</span><br></pre></td></tr></table></figure>

<p>cd到项目目录下（cd edu）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>最后启动vue项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>如果显示<a href="http://127.0.0.1:8080就说明我们vue项目创建成功了" target="_blank" rel="noopener">http://127.0.0.1:8080就说明我们vue项目创建成功了</a></p>
<h5 id="4、模板转换"><a href="#4、模板转换" class="headerlink" title="4、模板转换"></a>4、模板转换</h5><p>我们拿到本次项目的html模板文件需要将其转换为vue脚手架支持的vue格式。</p>
<p>用编辑器打开我们刚才新建好的vue项目（名称为：edu），文件目录下有一个index.html，我们将css引用样式和js引用都粘贴进在这个html文件里。</p>
<p>注意：css样式引用需要放在<head></head>标签里，在<body></body>标签里可以放script即js引用，此外这个div里的内容切记要保留，我们在components里写的vue文件会被引用到这个标签里。</p>
<img src="/2017/09/19/前期准备/模板.png" title="模板">



<h3 id="二、创建Django文件"><a href="#二、创建Django文件" class="headerlink" title="二、创建Django文件"></a>二、创建Django文件</h3><h5 id="1、下载django"><a href="#1、下载django" class="headerlink" title="1、下载django"></a>1、下载django</h5><p>确保电脑已经预装好python3.7，并且设置了环境变量。可以打开cmd输入python检查。</p>
<p>在cmd里输入pip insall django 下载django</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure>

<h5 id="2、创建django项目"><a href="#2、创建django项目" class="headerlink" title="2、创建django项目"></a>2、创建django项目</h5><p>新建一个存储此次项目的文件夹，用cmd进入该文件夹目录下输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject xxx(项目名称：eduapi)</span><br></pre></td></tr></table></figure>

<p>cd 进入eduapi文件下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd eduapi</span><br></pre></td></tr></table></figure>

<p>创建子项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp xxx(项目名称：userapp)</span><br></pre></td></tr></table></figure>

<h3 id="三、连接阿里云服务器"><a href="#三、连接阿里云服务器" class="headerlink" title="三、连接阿里云服务器"></a>三、连接阿里云服务器</h3><p>我们使用XShell连接阿里云服务器（centos），在ssh远程操作页面里下载memcache并启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install memcached</span><br></pre></td></tr></table></figure>

<p>起动memcached</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start memcached</span><br></pre></td></tr></table></figure>

<p>查看memcached运行情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status memcached</span><br></pre></td></tr></table></figure>

<p>关闭memcached</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop memcached</span><br></pre></td></tr></table></figure>

<p>注意：需要将买的服务器加入安全组里然后进行设置才可以使用</p>
<ol>
<li>进入控制台，点击云服务器ECS，点击左侧实例，点击右侧管理，点击本实例安全组，点击配置规则，点击添加安全组规则</li>
<li>设置为如下内容：</li>
</ol>
<img src="/2017/09/19/前期准备/添加安全组.png" title="添加安全组">]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>在线学习网站Django+VUE</title>
    <url>/1000/09/19/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99Django+VUE/</url>
    <content><![CDATA[<h3 id="一、开发环境及相关软件"><a href="#一、开发环境及相关软件" class="headerlink" title="一、开发环境及相关软件"></a>一、开发环境及相关软件</h3><p>win10</p>
<p>python3.7</p>
<p>django2.0.4</p>
<p>vue2.9.6</p>
<p>阿里云服务器+XShell+memcache</p>
<p>…</p>
<h3 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h3><h5 id="1、网站模板参考"><a href="#1、网站模板参考" class="headerlink" title="1、网站模板参考"></a>1、网站模板参考</h5><p>实验楼：<a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">https://www.shiyanlou.com</a></p>
<p>菜鸟教程：<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com</a></p>
<h5 id="2、功能"><a href="#2、功能" class="headerlink" title="2、功能"></a>2、功能</h5><ul>
<li>注册</li>
</ul>
<img src="/1000/09/19/在线学习网站Django+VUE/注册功能.png" title="注册功能">

<p>输入邮箱（未做验证）</p>
<p>输入密码（未做验证）</p>
<p>在验证码输入框内，输入从邮箱获取到的验证码</p>
<p>点击&lt;发送邮件&gt;按钮，向输入的邮箱发送验证码</p>
<p>点击注册按钮完成注册</p>
<ul>
<li>登录</li>
</ul>
<img src="/1000/09/19/在线学习网站Django+VUE/登录功能.png" title="登录功能">

<p>输入邮箱和密码登录（未做提示）</p>
<p>Django后台生成自定义token用于前端做客户端自认证</p>
<ul>
<li>表结构</li>
</ul>
<img src="/1000/09/19/在线学习网站Django+VUE/表结构.png" title="表结构">]]></content>
      <categories>
        <category>项目</category>
        <category>Online_Education</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
